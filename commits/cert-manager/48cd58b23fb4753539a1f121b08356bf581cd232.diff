commit 48cd58b23fb4753539a1f121b08356bf581cd232 (from 9c16efdb3f9a0a84af4d1a3fdc3c13f06dd2de9b)
Merge: 9c16efdb3 a2da614fd
Author: jetstack-bot <32282838+jetstack-bot@users.noreply.github.com>
Date:   Mon Jun 17 19:27:57 2019 +0100

    Merge pull request #1722 from cheukwing/issue-1003
    
    Add BaseController as a refactoring of common controller code

diff --git a/pkg/controller/BUILD.bazel b/pkg/controller/BUILD.bazel
index 80db00715..1f98604ad 100644
--- a/pkg/controller/BUILD.bazel
+++ b/pkg/controller/BUILD.bazel
@@ -3,6 +3,7 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 go_library(
     name = "go_default_library",
     srcs = [
+        "base_controller.go",
         "context.go",
         "helper.go",
         "register.go",
@@ -14,8 +15,10 @@ go_library(
         "//pkg/apis/certmanager/v1alpha1:go_default_library",
         "//pkg/client/clientset/versioned:go_default_library",
         "//pkg/client/informers/externalversions:go_default_library",
+        "//pkg/logs:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/resource:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/runtime:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
         "//vendor/k8s.io/client-go/informers:go_default_library",
         "//vendor/k8s.io/client-go/kubernetes:go_default_library",
         "//vendor/k8s.io/client-go/rest:go_default_library",
diff --git a/pkg/controller/acmechallenges/BUILD.bazel b/pkg/controller/acmechallenges/BUILD.bazel
index 3a795ac46..ed09b6ff4 100644
--- a/pkg/controller/acmechallenges/BUILD.bazel
+++ b/pkg/controller/acmechallenges/BUILD.bazel
@@ -27,7 +27,6 @@ go_library(
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/errors:go_default_library",
-        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
         "//vendor/k8s.io/apiserver/pkg/util/feature:go_default_library",
         "//vendor/k8s.io/client-go/listers/core/v1:go_default_library",
         "//vendor/k8s.io/client-go/tools/cache:go_default_library",
diff --git a/pkg/controller/acmechallenges/controller.go b/pkg/controller/acmechallenges/controller.go
index c3bd3357d..f71dbdb83 100644
--- a/pkg/controller/acmechallenges/controller.go
+++ b/pkg/controller/acmechallenges/controller.go
@@ -18,13 +18,10 @@ package acmechallenges
 
 import (
 	"context"
-	"fmt"
-	"sync"
 	"time"
 
 	corev1 "k8s.io/api/core/v1"
 	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
-	"k8s.io/apimachinery/pkg/util/wait"
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
 	"k8s.io/client-go/util/workqueue"
@@ -40,16 +37,11 @@ import (
 )
 
 type Controller struct {
-	// the controllers root context, containing a controller scoped logger
-	ctx context.Context
-	controllerpkg.Context
+	*controllerpkg.BaseController
 
 	helper     issuer.Helper
 	acmeHelper acme.Helper
 
-	// To allow injection for testing.
-	syncHandler func(ctx context.Context, key string) error
-
 	challengeLister     cmlisters.ChallengeLister
 	issuerLister        cmlisters.IssuerLister
 	clusterIssuerLister cmlisters.ClusterIssuerLister
@@ -61,49 +53,42 @@ type Controller struct {
 	dnsSolver  solver
 	httpSolver solver
 
-	watchedInformers []cache.InformerSynced
-	queue            workqueue.RateLimitingInterface
-
 	scheduler *scheduler.Scheduler
 }
 
 func New(ctx *controllerpkg.Context) (*Controller, error) {
-	ctrl := &Controller{Context: *ctx}
-	ctrl.syncHandler = ctrl.processNextWorkItem
-
-	ctrl.queue = workqueue.NewNamedRateLimitingQueue(workqueue.NewItemExponentialFailureRateLimiter(time.Second*5, time.Minute*30), "challenges")
+	ctrl := &Controller{}
+	bctrl := controllerpkg.New(ctx, ControllerName, ctrl.processNextWorkItem)
 
-	challengeInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Challenges()
-	challengeInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, challengeInformer.Informer().HasSynced)
+	challengeInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Challenges()
+	bctrl.AddQueuing(workqueue.NewItemExponentialFailureRateLimiter(time.Second*5, time.Minute*30), "challenges", challengeInformer.Informer())
 	ctrl.challengeLister = challengeInformer.Lister()
 
 	// issuerInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-	issuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
-	ctrl.watchedInformers = append(ctrl.watchedInformers, issuerInformer.Informer().HasSynced)
+	issuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
+	bctrl.AddWatched(issuerInformer.Informer())
 	ctrl.issuerLister = issuerInformer.Lister()
 
 	if ctx.Namespace == "" {
 		// clusterIssuerInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-		clusterIssuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
-		ctrl.watchedInformers = append(ctrl.watchedInformers, clusterIssuerInformer.Informer().HasSynced)
+		clusterIssuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
+		bctrl.AddWatched(clusterIssuerInformer.Informer())
 		ctrl.clusterIssuerLister = clusterIssuerInformer.Lister()
 	}
 
-	secretInformer := ctrl.KubeSharedInformerFactory.Core().V1().Secrets()
-	ctrl.watchedInformers = append(ctrl.watchedInformers, secretInformer.Informer().HasSynced)
+	secretInformer := ctx.KubeSharedInformerFactory.Core().V1().Secrets()
+	bctrl.AddWatched(secretInformer.Informer())
 	ctrl.secretLister = secretInformer.Lister()
 
 	// instantiate listers used by the http01 solver
-	podInformer := ctrl.KubeSharedInformerFactory.Core().V1().Pods()
-	serviceInformer := ctrl.KubeSharedInformerFactory.Core().V1().Services()
-	ingressInformer := ctrl.KubeSharedInformerFactory.Extensions().V1beta1().Ingresses()
-	ctrl.watchedInformers = append(ctrl.watchedInformers, podInformer.Informer().HasSynced)
-	ctrl.watchedInformers = append(ctrl.watchedInformers, serviceInformer.Informer().HasSynced)
-	ctrl.watchedInformers = append(ctrl.watchedInformers, ingressInformer.Informer().HasSynced)
+	podInformer := ctx.KubeSharedInformerFactory.Core().V1().Pods()
+	serviceInformer := ctx.KubeSharedInformerFactory.Core().V1().Services()
+	ingressInformer := ctx.KubeSharedInformerFactory.Extensions().V1beta1().Ingresses()
+	bctrl.AddWatched(podInformer.Informer(), serviceInformer.Informer(), ingressInformer.Informer())
 
+	ctrl.BaseController = bctrl
 	ctrl.helper = issuer.NewHelper(ctrl.issuerLister, ctrl.clusterIssuerLister)
-	ctrl.acmeHelper = acme.NewHelper(ctrl.secretLister, ctrl.Context.ClusterResourceNamespace)
+	ctrl.acmeHelper = acme.NewHelper(ctrl.secretLister, ctrl.BaseController.Context.ClusterResourceNamespace)
 
 	ctrl.httpSolver = http.NewSolver(ctx)
 	var err error
@@ -112,46 +97,10 @@ func New(ctx *controllerpkg.Context) (*Controller, error) {
 		return nil, err
 	}
 	ctrl.scheduler = scheduler.New(ctrl.challengeLister, ctx.SchedulerOptions.MaxConcurrentChallenges)
-	ctrl.ctx = logf.NewContext(ctx.RootContext, nil, ControllerName)
 
 	return ctrl, nil
 }
 
-func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
-	ctx, cancel := context.WithCancel(c.ctx)
-	defer cancel()
-	log := logf.FromContext(ctx)
-
-	log.V(logf.DebugLevel).Info("starting control loop")
-	// wait for all the informer caches we depend on are synced
-	if !cache.WaitForCacheSync(stopCh, c.watchedInformers...) {
-		// c.challengeInformerSynced) {
-		return fmt.Errorf("error waiting for informer caches to sync")
-	}
-
-	var wg sync.WaitGroup
-	for i := 0; i < workers; i++ {
-		wg.Add(1)
-		// TODO (@munnerz): make time.Second duration configurable
-		go wait.Until(func() {
-			defer wg.Done()
-			c.worker(ctx)
-		},
-			time.Second, stopCh)
-	}
-	// TODO: properly plumb in stopCh and WaitGroup to scheduler
-	// Run the scheduler once per second
-	go wait.Until(func() { c.runScheduler(ctx) }, time.Second*1, stopCh)
-
-	<-stopCh
-	log.V(logf.DebugLevel).Info("shutting down queue as workqueue signaled shutdown")
-	c.queue.ShutDown()
-	log.V(logf.DebugLevel).Info("waiting for workers to exit")
-	wg.Wait()
-	log.V(logf.DebugLevel).Info("workers exited")
-	return nil
-}
-
 // MaxChallengesPerSchedule is the maximum number of challenges that can be
 // scheduled with a single call to the scheduler.
 // This provides a very crude rate limit on how many challenges we will schedule
@@ -192,37 +141,6 @@ func (c *Controller) runScheduler(ctx context.Context) {
 	}
 }
 
-func (c *Controller) worker(ctx context.Context) {
-	log := logf.FromContext(ctx)
-	log.V(logf.DebugLevel).Info("starting worker")
-	for {
-		obj, shutdown := c.queue.Get()
-		if shutdown {
-			break
-		}
-
-		var key string
-		// use an inlined function so we can use defer
-		func() {
-			defer c.queue.Done(obj)
-			var ok bool
-			if key, ok = obj.(string); !ok {
-				return
-			}
-			log := log.WithValues("key", key)
-			log.Info("syncing resource")
-			if err := c.syncHandler(ctx, key); err != nil {
-				log.Error(err, "re-queuing item  due to error processing")
-				c.queue.AddRateLimited(obj)
-				return
-			}
-			log.Info("finished processing work item")
-			c.queue.Forget(obj)
-		}()
-	}
-	log.V(logf.DebugLevel).Info("exiting worker loop")
-}
-
 func (c *Controller) processNextWorkItem(ctx context.Context, key string) error {
 	log := logf.FromContext(ctx)
 	namespace, name, err := cache.SplitMetaNamespaceKey(key)
@@ -252,6 +170,10 @@ const (
 	ControllerName = "challenges"
 )
 
+func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
+	return c.BaseController.RunWith(c.runScheduler, time.Second, workers, stopCh)
+}
+
 func init() {
 	controllerpkg.Register(ControllerName, func(ctx *controllerpkg.Context) (controllerpkg.Interface, error) {
 		i, err := New(ctx)
diff --git a/pkg/controller/acmechallenges/sync.go b/pkg/controller/acmechallenges/sync.go
index ebd3216d5..c36bf8a90 100644
--- a/pkg/controller/acmechallenges/sync.go
+++ b/pkg/controller/acmechallenges/sync.go
@@ -190,7 +190,7 @@ func (c *Controller) Sync(ctx context.Context, ch *cmapi.Challenge) (err error)
 		}
 
 		// retry after 10s
-		c.queue.AddAfter(key, time.Second*10)
+		c.BaseController.Queue.AddAfter(key, time.Second*10)
 
 		return nil
 	}
diff --git a/pkg/controller/acmeorders/BUILD.bazel b/pkg/controller/acmeorders/BUILD.bazel
index 190bd3419..7b00a4b91 100644
--- a/pkg/controller/acmeorders/BUILD.bazel
+++ b/pkg/controller/acmeorders/BUILD.bazel
@@ -28,7 +28,6 @@ go_library(
         "//vendor/k8s.io/apimachinery/pkg/util/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/runtime:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/sets:go_default_library",
-        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
         "//vendor/k8s.io/client-go/listers/core/v1:go_default_library",
         "//vendor/k8s.io/client-go/tools/cache:go_default_library",
         "//vendor/k8s.io/client-go/util/workqueue:go_default_library",
diff --git a/pkg/controller/acmeorders/checks.go b/pkg/controller/acmeorders/checks.go
index 2dd87512a..933457656 100644
--- a/pkg/controller/acmeorders/checks.go
+++ b/pkg/controller/acmeorders/checks.go
@@ -42,7 +42,7 @@ func (c *Controller) handleGenericIssuer(obj interface{}) {
 			runtime.HandleError(err)
 			continue
 		}
-		c.queue.Add(key)
+		c.BaseController.Queue.Add(key)
 	}
 }
 
diff --git a/pkg/controller/acmeorders/controller.go b/pkg/controller/acmeorders/controller.go
index 7b41955da..917d0cc39 100644
--- a/pkg/controller/acmeorders/controller.go
+++ b/pkg/controller/acmeorders/controller.go
@@ -18,14 +18,11 @@ package acmeorders
 
 import (
 	"context"
-	"fmt"
-	"sync"
 	"time"
 
 	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/util/wait"
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
 	"k8s.io/client-go/util/workqueue"
@@ -39,72 +36,58 @@ import (
 )
 
 type Controller struct {
-	// the controllers root context, containing a controller scoped logger
-	ctx context.Context
-	controllerpkg.Context
+	*controllerpkg.BaseController
 
 	helper     issuer.Helper
 	acmeHelper acme.Helper
 
-	// To allow injection for testing.
-	syncHandler func(ctx context.Context, key string) error
-
 	orderLister         cmlisters.OrderLister
 	challengeLister     cmlisters.ChallengeLister
 	issuerLister        cmlisters.IssuerLister
 	clusterIssuerLister cmlisters.ClusterIssuerLister
 	secretLister        corelisters.SecretLister
 
-	watchedInformers []cache.InformerSynced
-	queue            workqueue.RateLimitingInterface
-
 	// used for testing
 	clock clock.Clock
 }
 
 func New(ctx *controllerpkg.Context) *Controller {
-	ctrl := &Controller{Context: *ctx}
-	ctrl.syncHandler = ctrl.processNextWorkItem
-
-	ctrl.queue = workqueue.NewNamedRateLimitingQueue(workqueue.NewItemExponentialFailureRateLimiter(time.Second*5, time.Minute*30), "orders")
+	ctrl := &Controller{}
+	bctrl := controllerpkg.New(ctx, ControllerName, ctrl.processNextWorkItem)
 
-	orderInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Orders()
-	orderInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, orderInformer.Informer().HasSynced)
+	orderInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Orders()
+	bctrl.AddQueuing(workqueue.NewItemExponentialFailureRateLimiter(time.Second*5, time.Minute*30), "orders", orderInformer.Informer())
 	ctrl.orderLister = orderInformer.Lister()
 
-	issuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
-	issuerInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, issuerInformer.Informer().HasSynced)
+	issuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
+	bctrl.AddHandled(issuerInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
 	ctrl.issuerLister = issuerInformer.Lister()
 
 	if ctx.Namespace == "" {
-		clusterIssuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
-		clusterIssuerInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
-		ctrl.watchedInformers = append(ctrl.watchedInformers, clusterIssuerInformer.Informer().HasSynced)
+		clusterIssuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
+		bctrl.AddHandled(clusterIssuerInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
 		ctrl.clusterIssuerLister = clusterIssuerInformer.Lister()
 	}
 
-	challengeInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Challenges()
-	challengeInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleOwnedResource})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, challengeInformer.Informer().HasSynced)
+	challengeInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Challenges()
+	bctrl.AddHandled(challengeInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleOwnedResource})
 	ctrl.challengeLister = challengeInformer.Lister()
 
 	// TODO: detect changes to secrets referenced by order's issuers.
-	secretInformer := ctrl.KubeSharedInformerFactory.Core().V1().Secrets()
-	ctrl.watchedInformers = append(ctrl.watchedInformers, secretInformer.Informer().HasSynced)
+	secretInformer := ctx.KubeSharedInformerFactory.Core().V1().Secrets()
+	bctrl.AddWatched(secretInformer.Informer())
 	ctrl.secretLister = secretInformer.Lister()
 
+	ctrl.BaseController = bctrl
 	ctrl.helper = issuer.NewHelper(ctrl.issuerLister, ctrl.clusterIssuerLister)
-	ctrl.acmeHelper = acme.NewHelper(ctrl.secretLister, ctrl.Context.ClusterResourceNamespace)
+	ctrl.acmeHelper = acme.NewHelper(ctrl.secretLister, ctrl.BaseController.Context.ClusterResourceNamespace)
 	ctrl.clock = clock.RealClock{}
-	ctrl.ctx = logf.NewContext(ctx.RootContext, nil, ControllerName)
 
 	return ctrl
 }
 
 func (c *Controller) handleOwnedResource(obj interface{}) {
-	log := logf.FromContext(c.ctx, "handleOwnedResource")
+	log := logf.FromContext(c.BaseController.Ctx, "handleOwnedResource")
 
 	metaobj, ok := obj.(metav1.Object)
 	if !ok {
@@ -140,74 +123,11 @@ func (c *Controller) handleOwnedResource(obj interface{}) {
 				log.Error(err, "error computing key for resource")
 				continue
 			}
-			c.queue.Add(objKey)
+			c.BaseController.Queue.Add(objKey)
 		}
 	}
 }
 
-func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
-	ctx, cancel := context.WithCancel(c.ctx)
-	defer cancel()
-	log := logf.FromContext(ctx)
-
-	log.V(logf.DebugLevel).Info("starting %s control loop")
-	// wait for all the informer caches we depend on are synced
-	if !cache.WaitForCacheSync(stopCh, c.watchedInformers...) {
-		// c.challengeInformerSynced) {
-		return fmt.Errorf("error waiting for informer caches to sync")
-	}
-
-	var wg sync.WaitGroup
-	for i := 0; i < workers; i++ {
-		wg.Add(1)
-		// TODO (@munnerz): make time.Second duration configurable
-		go wait.Until(func() {
-			defer wg.Done()
-			c.worker(ctx)
-		},
-			time.Second, stopCh)
-	}
-	<-stopCh
-	log.V(logf.DebugLevel).Info("shutting down queue as workqueue signaled shutdown")
-	c.queue.ShutDown()
-	log.V(logf.DebugLevel).Info("waiting for workers to exit...")
-	wg.Wait()
-	log.V(logf.DebugLevel).Info("workers exited")
-	return nil
-}
-
-func (c *Controller) worker(ctx context.Context) {
-	log := logf.FromContext(ctx)
-
-	log.V(logf.DebugLevel).Info("starting worker")
-	for {
-		obj, shutdown := c.queue.Get()
-		if shutdown {
-			break
-		}
-
-		var key string
-		// use an inlined function so we can use defer
-		func() {
-			defer c.queue.Done(obj)
-			var ok bool
-			if key, ok = obj.(string); !ok {
-				return
-			}
-			log := log.WithValues("key", key)
-			log.Info("syncing resource")
-			if err := c.syncHandler(ctx, key); err != nil {
-				log.Error(err, "re-queuing item  due to error processing")
-				c.queue.AddRateLimited(obj)
-				return
-			}
-			log.Info("finished processing work item")
-			c.queue.Forget(obj)
-		}()
-	}
-	log.V(logf.DebugLevel).Info("exiting worker loop")
-}
-
 func (c *Controller) processNextWorkItem(ctx context.Context, key string) error {
 	log := logf.FromContext(ctx)
 	namespace, name, err := cache.SplitMetaNamespaceKey(key)
@@ -238,6 +158,6 @@ const (
 
 func init() {
 	controllerpkg.Register(ControllerName, func(ctx *controllerpkg.Context) (controllerpkg.Interface, error) {
-		return New(ctx).Run, nil
+		return New(ctx).BaseController.Run, nil
 	})
 }
diff --git a/pkg/controller/base_controller.go b/pkg/controller/base_controller.go
new file mode 100644
index 000000000..b21242c25
--- /dev/null
+++ b/pkg/controller/base_controller.go
@@ -0,0 +1,145 @@
+/*
+Copyright 2019 The Jetstack cert-manager contributors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controller
+
+import (
+	"context"
+	"fmt"
+	"sync"
+	"time"
+
+	"k8s.io/apimachinery/pkg/util/wait"
+	"k8s.io/client-go/tools/cache"
+	"k8s.io/client-go/util/workqueue"
+
+	logf "github.com/jetstack/cert-manager/pkg/logs"
+)
+
+type BaseController struct {
+	// the controllers root context, containing a controller scoped logger
+	Ctx context.Context
+	*Context
+
+	// To allow injection for testing.
+	syncHandler func(ctx context.Context, key string) error
+
+	watchedInformers []cache.InformerSynced
+	Queue            workqueue.RateLimitingInterface
+}
+
+// New creates a basic BaseController, setting the sync call to the one given
+func New(ctx *Context, controllerName string, syncHandler func(ctx context.Context, key string) error) *BaseController {
+	bctrl := &BaseController{Context: ctx}
+	bctrl.syncHandler = syncHandler
+	bctrl.Ctx = logf.NewContext(ctx.RootContext, nil, controllerName)
+	return bctrl
+}
+
+// AddQueuing adds the Queue field onto the BaseController, sets the informer
+// to manage the queue, and sets the informer to be watched
+func (bctrl *BaseController) AddQueuing(rateLimiter workqueue.RateLimiter, name string, informer cache.SharedIndexInformer) {
+	bctrl.Queue = workqueue.NewNamedRateLimitingQueue(rateLimiter, name)
+	informer.AddEventHandler(&QueuingEventHandler{Queue: bctrl.Queue})
+	bctrl.watchedInformers = append(bctrl.watchedInformers, informer.HasSynced)
+}
+
+// AddHandled links an event handler to an informer, and sets the informer
+// to be watched
+func (bctrl *BaseController) AddHandled(informer cache.SharedIndexInformer, handler cache.ResourceEventHandler) {
+	informer.AddEventHandler(handler)
+	bctrl.watchedInformers = append(bctrl.watchedInformers, informer.HasSynced)
+}
+
+// AddWatched sets all informers to be watched
+func (bctrl *BaseController) AddWatched(informers ...cache.SharedIndexInformer) {
+	for _, informer := range informers {
+		bctrl.watchedInformers = append(bctrl.watchedInformers, informer.HasSynced)
+	}
+}
+
+// RunWith starts the controller loop, with an additional function to run alongside the loop
+func (bc *BaseController) RunWith(function func(context.Context), duration time.Duration, workers int, stopCh <-chan struct{}) error {
+	ctx, cancel := context.WithCancel(bc.Ctx)
+	defer cancel()
+	log := logf.FromContext(ctx)
+
+	log.Info("starting control loop")
+	// wait for all the informer caches we depend on are synced
+	if !cache.WaitForCacheSync(stopCh, bc.watchedInformers...) {
+		// TODO: replace with Errorf call to glog
+		return fmt.Errorf("error waiting for informer caches to sync")
+	}
+
+	var wg sync.WaitGroup
+	for i := 0; i < workers; i++ {
+		wg.Add(1)
+		// TODO (@munnerz): make time.Second duration configurable
+		go wait.Until(func() {
+			defer wg.Done()
+			bc.worker(ctx)
+		}, time.Second, stopCh)
+	}
+
+	if function != nil {
+		go wait.Until(func() { function(ctx) }, duration, stopCh)
+	}
+
+	<-stopCh
+	log.Info("shutting down queue as workqueue signaled shutdown")
+	bc.Queue.ShutDown()
+	log.V(logf.DebugLevel).Info("waiting for workers to exit...")
+	wg.Wait()
+	log.V(logf.DebugLevel).Info("workers exited")
+	return nil
+}
+
+// Run starts the controller loop
+func (bc *BaseController) Run(workers int, stopCh <-chan struct{}) error {
+	return bc.RunWith(nil, 0, workers, stopCh)
+}
+
+func (bc *BaseController) worker(ctx context.Context) {
+	log := logf.FromContext(bc.Ctx)
+
+	log.V(logf.DebugLevel).Info("starting worker")
+	for {
+		obj, shutdown := bc.Queue.Get()
+		if shutdown {
+			break
+		}
+
+		var key string
+		// use an inlined function so we can use defer
+		func() {
+			defer bc.Queue.Done(obj)
+			var ok bool
+			if key, ok = obj.(string); !ok {
+				return
+			}
+			log := log.WithValues("key", key)
+			log.Info("syncing item")
+			if err := bc.syncHandler(ctx, key); err != nil {
+				log.Error(err, "re-queuing item  due to error processing")
+				bc.Queue.AddRateLimited(obj)
+				return
+			}
+			log.Info("finished processing work item")
+			bc.Queue.Forget(obj)
+		}()
+	}
+	log.V(logf.DebugLevel).Info("exiting worker loop")
+}
diff --git a/pkg/controller/certificates/BUILD.bazel b/pkg/controller/certificates/BUILD.bazel
index 010c1c288..10f02025a 100644
--- a/pkg/controller/certificates/BUILD.bazel
+++ b/pkg/controller/certificates/BUILD.bazel
@@ -30,10 +30,8 @@ go_library(
         "//vendor/k8s.io/apimachinery/pkg/labels:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/runtime/schema:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/errors:go_default_library",
-        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
         "//vendor/k8s.io/client-go/listers/core/v1:go_default_library",
         "//vendor/k8s.io/client-go/tools/cache:go_default_library",
-        "//vendor/k8s.io/client-go/util/workqueue:go_default_library",
         "//vendor/k8s.io/utils/clock:go_default_library",
     ],
 )
diff --git a/pkg/controller/certificates/checks.go b/pkg/controller/certificates/checks.go
index ca0cc89ba..f16425a0d 100644
--- a/pkg/controller/certificates/checks.go
+++ b/pkg/controller/certificates/checks.go
@@ -29,7 +29,7 @@ import (
 )
 
 func (c *Controller) handleGenericIssuer(obj interface{}) {
-	log := logf.FromContext(c.ctx, "handleGenericIssuer")
+	log := logf.FromContext(c.BaseController.Ctx, "handleGenericIssuer")
 
 	iss, ok := obj.(cmapi.GenericIssuer)
 	if !ok {
@@ -50,12 +50,12 @@ func (c *Controller) handleGenericIssuer(obj interface{}) {
 			log.Error(err, "error computing key for resource")
 			continue
 		}
-		c.queue.Add(key)
+		c.BaseController.Queue.Add(key)
 	}
 }
 
 func (c *Controller) handleSecretResource(obj interface{}) {
-	log := logf.FromContext(c.ctx, "handleSecretResource")
+	log := logf.FromContext(c.BaseController.Ctx, "handleSecretResource")
 
 	secret, ok := obj.(*corev1.Secret)
 	if !ok {
@@ -76,7 +76,7 @@ func (c *Controller) handleSecretResource(obj interface{}) {
 			log.Error(err, "error computing key for resource")
 			continue
 		}
-		c.queue.Add(key)
+		c.BaseController.Queue.Add(key)
 	}
 }
 
@@ -129,7 +129,7 @@ func (c *Controller) certificatesForGenericIssuer(iss cmapi.GenericIssuer) ([]*c
 }
 
 func (c *Controller) handleOwnedResource(obj interface{}) {
-	log := logf.FromContext(c.ctx, "handleOwnedResource")
+	log := logf.FromContext(c.BaseController.Ctx, "handleOwnedResource")
 
 	metaobj, ok := obj.(metav1.Object)
 	if !ok {
@@ -168,7 +168,7 @@ func (c *Controller) handleOwnedResource(obj interface{}) {
 				log.Error(err, "error computing key for resource")
 				continue
 			}
-			c.queue.Add(objKey)
+			c.BaseController.Queue.Add(objKey)
 		}
 	}
 }
diff --git a/pkg/controller/certificates/controller.go b/pkg/controller/certificates/controller.go
index 598115c99..4c6b19336 100644
--- a/pkg/controller/certificates/controller.go
+++ b/pkg/controller/certificates/controller.go
@@ -18,15 +18,10 @@ package certificates
 
 import (
 	"context"
-	"fmt"
-	"sync"
-	"time"
 
 	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
-	"k8s.io/apimachinery/pkg/util/wait"
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
-	"k8s.io/client-go/util/workqueue"
 	"k8s.io/utils/clock"
 
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
@@ -39,26 +34,17 @@ import (
 )
 
 type Controller struct {
-	// the controllers root context, containing a controller scoped logger
-	ctx context.Context
-
-	*controllerpkg.Context
+	*controllerpkg.BaseController
 
 	helper        issuer.Helper
 	issuerFactory issuer.IssuerFactory
 
-	// To allow injection for testing.
-	syncHandler func(ctx context.Context, key string) error
-
 	issuerLister        cmlisters.IssuerLister
 	clusterIssuerLister cmlisters.ClusterIssuerLister
 	certificateLister   cmlisters.CertificateLister
 	secretLister        corelisters.SecretLister
 
-	queue              workqueue.RateLimitingInterface
 	scheduledWorkQueue scheduler.ScheduledWorkQueue
-	workerWg           sync.WaitGroup
-	syncedFuncs        []cache.InformerSynced
 	metrics            *metrics.Metrics
 
 	// used for testing
@@ -71,112 +57,47 @@ type Controller struct {
 // New returns a new Certificates controller. It sets up the informer handler
 // functions for all the types it watches.
 func New(ctx *controllerpkg.Context) *Controller {
-	ctrl := &Controller{Context: ctx}
-	ctrl.syncHandler = ctrl.processNextWorkItem
-	ctrl.queue = workqueue.NewNamedRateLimitingQueue(controllerpkg.DefaultItemBasedRateLimiter(), "certificates")
+	ctrl := &Controller{}
+	bctrl := controllerpkg.New(ctx, ControllerName, ctrl.processNextWorkItem)
+
+	certificateInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Certificates()
+	bctrl.AddQueuing(controllerpkg.DefaultItemBasedRateLimiter(), "certificates", certificateInformer.Informer())
+	ctrl.certificateLister = certificateInformer.Lister()
 
 	// Create a scheduled work queue that calls the ctrl.queue.Add method for
 	// each object in the queue. This is used to schedule re-checks of
 	// Certificate resources when they get near to expiry
-	ctrl.scheduledWorkQueue = scheduler.NewScheduledWorkQueue(ctrl.queue.AddRateLimited)
-
-	certificateInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Certificates()
-	certificateInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-	ctrl.certificateLister = certificateInformer.Lister()
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, certificateInformer.Informer().HasSynced)
+	ctrl.scheduledWorkQueue = scheduler.NewScheduledWorkQueue(bctrl.Queue.AddRateLimited)
 
-	issuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
-	issuerInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
+	issuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
+	bctrl.AddHandled(issuerInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
 	ctrl.issuerLister = issuerInformer.Lister()
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, issuerInformer.Informer().HasSynced)
 
 	// if scoped to a single namespace
 	if ctx.Namespace == "" {
-		clusterIssuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
-		clusterIssuerInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
+		clusterIssuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
+		bctrl.AddHandled(clusterIssuerInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleGenericIssuer})
 		ctrl.clusterIssuerLister = clusterIssuerInformer.Lister()
-		ctrl.syncedFuncs = append(ctrl.syncedFuncs, clusterIssuerInformer.Informer().HasSynced)
 	}
 
-	secretsInformer := ctrl.KubeSharedInformerFactory.Core().V1().Secrets()
-	secretsInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleSecretResource})
+	secretsInformer := ctx.KubeSharedInformerFactory.Core().V1().Secrets()
+	bctrl.AddHandled(secretsInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleSecretResource})
 	ctrl.secretLister = secretsInformer.Lister()
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, secretsInformer.Informer().HasSynced)
 
-	ordersInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Orders()
-	ordersInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleOwnedResource})
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, ordersInformer.Informer().HasSynced)
+	ordersInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Orders()
+	bctrl.AddHandled(ordersInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.handleOwnedResource})
 
+	ctrl.BaseController = bctrl
 	ctrl.helper = issuer.NewHelper(ctrl.issuerLister, ctrl.clusterIssuerLister)
 	ctrl.metrics = metrics.Default
 	ctrl.helper = issuer.NewHelper(ctrl.issuerLister, ctrl.clusterIssuerLister)
 	ctrl.issuerFactory = issuer.NewIssuerFactory(ctx)
 	ctrl.clock = clock.RealClock{}
 	ctrl.localTemporarySigner = generateLocallySignedTemporaryCertificate
-	ctrl.ctx = logf.NewContext(ctx.RootContext, nil, ControllerName)
 
 	return ctrl
 }
 
-func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
-	ctx, cancel := context.WithCancel(c.ctx)
-	defer cancel()
-	log := logf.FromContext(ctx)
-
-	log.Info("starting control loop")
-	// wait for all the informer caches we depend to sync
-	if !cache.WaitForCacheSync(stopCh, c.syncedFuncs...) {
-		return fmt.Errorf("error waiting for informer caches to sync")
-	}
-
-	log.Info("synced all caches for control loop")
-
-	for i := 0; i < workers; i++ {
-		c.workerWg.Add(1)
-		// TODO (@munnerz): make time.Second duration configurable
-		go wait.Until(func() { c.worker(ctx) }, time.Second, stopCh)
-	}
-	<-stopCh
-	log.V(logf.DebugLevel).Info("shutting down queue as workqueue signaled shutdown")
-	c.queue.ShutDown()
-	log.V(logf.DebugLevel).Info("waiting for workers to exit...")
-	c.workerWg.Wait()
-	log.V(logf.DebugLevel).Info("workers exited")
-	return nil
-}
-
-func (c *Controller) worker(ctx context.Context) {
-	log := logf.FromContext(ctx)
-	defer c.workerWg.Done()
-	log.V(logf.DebugLevel).Info("starting worker")
-	for {
-		obj, shutdown := c.queue.Get()
-		if shutdown {
-			break
-		}
-
-		var key string
-		// use an inlined function so we can use defer
-		func() {
-			defer c.queue.Done(obj)
-			var ok bool
-			if key, ok = obj.(string); !ok {
-				return
-			}
-			log := log.WithValues("key", key)
-			log.Info("syncing resource")
-			if err := c.syncHandler(ctx, key); err != nil {
-				log.Error(err, "re-queuing item  due to error processing")
-				c.queue.AddRateLimited(obj)
-				return
-			}
-			log.Info("finished processing work item")
-			c.queue.Forget(obj)
-		}()
-	}
-	log.V(logf.DebugLevel).Info("exiting worker loop")
-}
-
 func (c *Controller) processNextWorkItem(ctx context.Context, key string) error {
 	log := logf.FromContext(ctx)
 	namespace, name, err := cache.SplitMetaNamespaceKey(key)
diff --git a/pkg/controller/clusterissuers/BUILD.bazel b/pkg/controller/clusterissuers/BUILD.bazel
index e4eb49918..18f88b612 100644
--- a/pkg/controller/clusterissuers/BUILD.bazel
+++ b/pkg/controller/clusterissuers/BUILD.bazel
@@ -22,10 +22,8 @@ go_library(
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/labels:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/errors:go_default_library",
-        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
         "//vendor/k8s.io/client-go/listers/core/v1:go_default_library",
         "//vendor/k8s.io/client-go/tools/cache:go_default_library",
-        "//vendor/k8s.io/client-go/util/workqueue:go_default_library",
     ],
 )
 
diff --git a/pkg/controller/clusterissuers/controller.go b/pkg/controller/clusterissuers/controller.go
index d2ebd8326..6725b7a08 100644
--- a/pkg/controller/clusterissuers/controller.go
+++ b/pkg/controller/clusterissuers/controller.go
@@ -18,16 +18,11 @@ package clusterissuers
 
 import (
 	"context"
-	"fmt"
-	"sync"
-	"time"
 
 	corev1 "k8s.io/api/core/v1"
 	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
-	"k8s.io/apimachinery/pkg/util/wait"
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
-	"k8s.io/client-go/util/workqueue"
 
 	cmlisters "github.com/jetstack/cert-manager/pkg/client/listers/certmanager/v1alpha1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
@@ -36,43 +31,35 @@ import (
 )
 
 type Controller struct {
-	ctx context.Context
-	controllerpkg.Context
-	issuerFactory issuer.IssuerFactory
+	*controllerpkg.BaseController
 
-	// To allow injection for testing.
-	syncHandler func(ctx context.Context, key string) error
+	issuerFactory issuer.IssuerFactory
 
 	clusterIssuerLister cmlisters.ClusterIssuerLister
 	secretLister        corelisters.SecretLister
-
-	watchedInformers []cache.InformerSynced
-	queue            workqueue.RateLimitingInterface
 }
 
 func New(ctx *controllerpkg.Context) *Controller {
-	ctrl := &Controller{Context: *ctx}
-	ctrl.syncHandler = ctrl.processNextWorkItem
-	ctrl.queue = workqueue.NewNamedRateLimitingQueue(controllerpkg.DefaultItemBasedRateLimiter(), "clusterissuers")
+	ctrl := &Controller{}
+	bctrl := controllerpkg.New(ctx, ControllerName, ctrl.processNextWorkItem)
 
-	clusterIssuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
-	clusterIssuerInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, clusterIssuerInformer.Informer().HasSynced)
+	clusterIssuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
+	bctrl.AddQueuing(controllerpkg.DefaultItemBasedRateLimiter(), "clusterissuers", clusterIssuerInformer.Informer())
 	ctrl.clusterIssuerLister = clusterIssuerInformer.Lister()
 
-	secretsInformer := ctrl.KubeSharedInformerFactory.Core().V1().Secrets()
-	secretsInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.secretDeleted})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, secretsInformer.Informer().HasSynced)
+	secretsInformer := ctx.KubeSharedInformerFactory.Core().V1().Secrets()
+	bctrl.AddHandled(secretsInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.secretDeleted})
 	ctrl.secretLister = secretsInformer.Lister()
+
+	ctrl.BaseController = bctrl
 	ctrl.issuerFactory = issuer.NewIssuerFactory(ctx)
-	ctrl.ctx = logf.NewContext(ctx.RootContext, nil, ControllerName)
 
 	return ctrl
 }
 
 // TODO: replace with generic handleObjet function (like Navigator)
 func (c *Controller) secretDeleted(obj interface{}) {
-	log := logf.FromContext(c.ctx, "secretDeleted")
+	log := logf.FromContext(c.BaseController.Ctx, "secretDeleted")
 
 	var secret *corev1.Secret
 	var ok bool
@@ -95,69 +82,8 @@ func (c *Controller) secretDeleted(obj interface{}) {
 			log.Error(err, "error computing key for resource")
 			continue
 		}
-		c.queue.AddRateLimited(key)
-	}
-}
-
-func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
-	ctx, cancel := context.WithCancel(c.ctx)
-	defer cancel()
-	log := logf.FromContext(ctx)
-
-	log.Info("starting control loop")
-	// wait for all the informer caches we depend on are synced
-	if !cache.WaitForCacheSync(stopCh, c.watchedInformers...) {
-		// TODO: replace with Errorf call to glog
-		return fmt.Errorf("error waiting for informer caches to sync")
-	}
-
-	var wg sync.WaitGroup
-	for i := 0; i < workers; i++ {
-		wg.Add(1)
-		// TODO (@munnerz): make time.Second duration configurable
-		go wait.Until(func() {
-			defer wg.Done()
-			c.worker(ctx)
-		}, time.Second, stopCh)
-	}
-	<-stopCh
-	log.V(logf.DebugLevel).Info("shutting down queue as workqueue signaled shutdown")
-	c.queue.ShutDown()
-	log.V(logf.DebugLevel).Info("waiting for workers to exit...")
-	wg.Wait()
-	log.V(logf.DebugLevel).Info("workers exited.")
-	return nil
-}
-
-func (c *Controller) worker(ctx context.Context) {
-	log := logf.FromContext(ctx)
-	log.V(logf.DebugLevel).Info("starting worker")
-	for {
-		obj, shutdown := c.queue.Get()
-		if shutdown {
-			break
-		}
-
-		var key string
-		// use an inlined function so we can use defer
-		func() {
-			defer c.queue.Done(obj)
-			var ok bool
-			if key, ok = obj.(string); !ok {
-				return
-			}
-			log := log.WithValues("key", key)
-			log.Info("syncing resource")
-			if err := c.syncHandler(ctx, key); err != nil {
-				log.Error(err, "re-queuing item  due to error processing")
-				c.queue.AddRateLimited(obj)
-				return
-			}
-			log.Info("finished processing work item")
-			c.queue.Forget(obj)
-		}()
+		c.BaseController.Queue.AddRateLimited(key)
 	}
-	log.V(logf.DebugLevel).Info("exiting worker loop")
 }
 
 func (c *Controller) processNextWorkItem(ctx context.Context, key string) error {
@@ -191,6 +117,6 @@ const (
 
 func init() {
 	controllerpkg.Register(ControllerName, func(ctx *controllerpkg.Context) (controllerpkg.Interface, error) {
-		return New(ctx).Run, nil
+		return New(ctx).BaseController.Run, nil
 	})
 }
diff --git a/pkg/controller/ingress-shim/BUILD.bazel b/pkg/controller/ingress-shim/BUILD.bazel
index 238e1d93b..8efbdea94 100644
--- a/pkg/controller/ingress-shim/BUILD.bazel
+++ b/pkg/controller/ingress-shim/BUILD.bazel
@@ -12,7 +12,6 @@ go_library(
     deps = [
         "//pkg/apis/certmanager/v1alpha1:go_default_library",
         "//pkg/client/clientset/versioned:go_default_library",
-        "//pkg/client/informers/externalversions/certmanager/v1alpha1:go_default_library",
         "//pkg/client/listers/certmanager/v1alpha1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/issuer:go_default_library",
@@ -25,13 +24,10 @@ go_library(
         "//vendor/k8s.io/apimachinery/pkg/labels:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/runtime:go_default_library",
-        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
-        "//vendor/k8s.io/client-go/informers/extensions/v1beta1:go_default_library",
         "//vendor/k8s.io/client-go/kubernetes:go_default_library",
         "//vendor/k8s.io/client-go/listers/extensions/v1beta1:go_default_library",
         "//vendor/k8s.io/client-go/tools/cache:go_default_library",
         "//vendor/k8s.io/client-go/tools/record:go_default_library",
-        "//vendor/k8s.io/client-go/util/workqueue:go_default_library",
         "//vendor/k8s.io/klog:go_default_library",
     ],
 )
diff --git a/pkg/controller/ingress-shim/controller.go b/pkg/controller/ingress-shim/controller.go
index 424afd9e6..604ca95e5 100644
--- a/pkg/controller/ingress-shim/controller.go
+++ b/pkg/controller/ingress-shim/controller.go
@@ -19,27 +19,19 @@ package controller
 import (
 	"context"
 	"fmt"
-	"sync"
-	"time"
 
 	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
 	"k8s.io/apimachinery/pkg/util/runtime"
-	"k8s.io/apimachinery/pkg/util/wait"
 	"k8s.io/client-go/kubernetes"
 	extlisters "k8s.io/client-go/listers/extensions/v1beta1"
 	"k8s.io/client-go/tools/cache"
 	"k8s.io/client-go/tools/record"
-	"k8s.io/client-go/util/workqueue"
-	"k8s.io/klog"
 
 	cmv1alpha1 "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
 	clientset "github.com/jetstack/cert-manager/pkg/client/clientset/versioned"
-	cminformers "github.com/jetstack/cert-manager/pkg/client/informers/externalversions/certmanager/v1alpha1"
 	cmlisters "github.com/jetstack/cert-manager/pkg/client/listers/certmanager/v1alpha1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
 	"github.com/jetstack/cert-manager/pkg/issuer"
-	"github.com/jetstack/cert-manager/pkg/util"
-	extinformers "k8s.io/client-go/informers/extensions/v1beta1"
 )
 
 const (
@@ -54,58 +46,56 @@ type defaults struct {
 }
 
 type Controller struct {
+	*controllerpkg.BaseController
+
 	Client   kubernetes.Interface
 	CMClient clientset.Interface
 	Recorder record.EventRecorder
 
 	helper issuer.Helper
 
-	// To allow injection for testing.
-	syncHandler func(ctx context.Context, key string) error
-
 	ingressLister       extlisters.IngressLister
 	certificateLister   cmlisters.CertificateLister
 	issuerLister        cmlisters.IssuerLister
 	clusterIssuerLister cmlisters.ClusterIssuerLister
 
-	queue       workqueue.RateLimitingInterface
-	workerWg    sync.WaitGroup
-	syncedFuncs []cache.InformerSynced
-	defaults    defaults
+	defaults defaults
 }
 
-// New returns a new Certificates controller. It sets up the informer handler
-// functions for all the types it watches.
-func New(
-	certificatesInformer cminformers.CertificateInformer,
-	ingressInformer extinformers.IngressInformer,
-	issuerInformer cminformers.IssuerInformer,
-	clusterIssuerInformer cminformers.ClusterIssuerInformer,
-	client kubernetes.Interface,
-	cmClient clientset.Interface,
-	recorder record.EventRecorder,
-	defaults defaults,
-) *Controller {
-	ctrl := &Controller{Client: client, CMClient: cmClient, Recorder: recorder, defaults: defaults}
-	ctrl.syncHandler = ctrl.processNextWorkItem
-	ctrl.queue = workqueue.NewNamedRateLimitingQueue(controllerpkg.DefaultItemBasedRateLimiter(), "ingresses")
-
-	ingressInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
+func New(ctx *controllerpkg.Context) *Controller {
+	ctrl := &Controller{
+		Client:   ctx.Client,
+		CMClient: ctx.CMClient,
+		Recorder: ctx.Recorder,
+		defaults: defaults{
+			ctx.DefaultAutoCertificateAnnotations,
+			ctx.DefaultIssuerName,
+			ctx.DefaultIssuerKind,
+			ctx.DefaultACMEIssuerChallengeType,
+			ctx.DefaultACMEIssuerDNS01ProviderName,
+		},
+	}
+	bctrl := controllerpkg.New(ctx, ControllerName, ctrl.processNextWorkItem)
+
+	ingressInformer := ctx.KubeSharedInformerFactory.Extensions().V1beta1().Ingresses()
+	bctrl.AddQueuing(controllerpkg.DefaultItemBasedRateLimiter(), "ingresses", ingressInformer.Informer())
 	ctrl.ingressLister = ingressInformer.Lister()
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, ingressInformer.Informer().HasSynced)
 
-	certificatesInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.certificateDeleted})
+	certificatesInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Certificates()
+	bctrl.AddHandled(certificatesInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.certificateDeleted})
 	ctrl.certificateLister = certificatesInformer.Lister()
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, certificatesInformer.Informer().HasSynced)
 
+	issuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
+	bctrl.AddWatched(issuerInformer.Informer())
 	ctrl.issuerLister = issuerInformer.Lister()
-	ctrl.syncedFuncs = append(ctrl.syncedFuncs, issuerInformer.Informer().HasSynced)
 
-	if clusterIssuerInformer != nil {
+	if ctx.Namespace == "" {
+		clusterIssuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
+		bctrl.AddWatched(clusterIssuerInformer.Informer())
 		ctrl.clusterIssuerLister = clusterIssuerInformer.Lister()
-		ctrl.syncedFuncs = append(ctrl.syncedFuncs, clusterIssuerInformer.Informer().HasSynced)
 	}
 
+	ctrl.BaseController = bctrl
 	ctrl.helper = issuer.NewHelper(ctrl.issuerLister, ctrl.clusterIssuerLister)
 
 	return ctrl
@@ -128,64 +118,8 @@ func (c *Controller) certificateDeleted(obj interface{}) {
 			runtime.HandleError(err)
 			continue
 		}
-		c.queue.Add(key)
-	}
-}
-
-func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
-	klog.V(4).Infof("Starting %s control loop", ControllerName)
-	// wait for all the informer caches we depend to sync
-	if !cache.WaitForCacheSync(stopCh, c.syncedFuncs...) {
-		return fmt.Errorf("error waiting for informer caches to sync")
-	}
-
-	klog.V(4).Infof("Synced all caches for %s control loop", ControllerName)
-
-	for i := 0; i < workers; i++ {
-		c.workerWg.Add(1)
-		// TODO (@munnerz): make time.Second duration configurable
-		go wait.Until(func() { c.worker(stopCh) }, time.Second, stopCh)
-	}
-	<-stopCh
-	klog.V(4).Infof("Shutting down queue as workqueue signaled shutdown")
-	c.queue.ShutDown()
-	klog.V(4).Infof("Waiting for workers to exit...")
-	c.workerWg.Wait()
-	klog.V(4).Infof("Workers exited.")
-	return nil
-}
-
-func (c *Controller) worker(stopCh <-chan struct{}) {
-	defer c.workerWg.Done()
-	klog.V(4).Infof("Starting %q worker", ControllerName)
-	for {
-		obj, shutdown := c.queue.Get()
-		if shutdown {
-			break
-		}
-
-		var key string
-		// use an inlined function so we can use defer
-		func() {
-			defer c.queue.Done(obj)
-			var ok bool
-			if key, ok = obj.(string); !ok {
-				return
-			}
-			ctx, cancel := context.WithCancel(context.Background())
-			defer cancel()
-			ctx = util.ContextWithStopCh(ctx, stopCh)
-			klog.Infof("%s controller: syncing item '%s'", ControllerName, key)
-			if err := c.syncHandler(ctx, key); err != nil {
-				klog.Errorf("%s controller: Re-queuing item %q due to error processing: %s", ControllerName, key, err.Error())
-				c.queue.AddRateLimited(obj)
-				return
-			}
-			klog.Infof("%s controller: Finished processing work item %q", ControllerName, key)
-			c.queue.Forget(obj)
-		}()
+		c.BaseController.Queue.Add(key)
 	}
-	klog.V(4).Infof("Exiting %q worker loop", ControllerName)
 }
 
 func (c *Controller) processNextWorkItem(ctx context.Context, key string) error {
@@ -213,19 +147,6 @@ var keyFunc = controllerpkg.KeyFunc
 
 func init() {
 	controllerpkg.Register(ControllerName, func(ctx *controllerpkg.Context) (controllerpkg.Interface, error) {
-		var clusterIssuerInformer cminformers.ClusterIssuerInformer
-		if ctx.Namespace == "" {
-			clusterIssuerInformer = ctx.SharedInformerFactory.Certmanager().V1alpha1().ClusterIssuers()
-		}
-		return New(
-			ctx.SharedInformerFactory.Certmanager().V1alpha1().Certificates(),
-			ctx.KubeSharedInformerFactory.Extensions().V1beta1().Ingresses(),
-			ctx.SharedInformerFactory.Certmanager().V1alpha1().Issuers(),
-			clusterIssuerInformer,
-			ctx.Client,
-			ctx.CMClient,
-			ctx.Recorder,
-			defaults{ctx.DefaultAutoCertificateAnnotations, ctx.DefaultIssuerName, ctx.DefaultIssuerKind, ctx.DefaultACMEIssuerChallengeType, ctx.DefaultACMEIssuerDNS01ProviderName},
-		).Run, nil
+		return New(ctx).BaseController.Run, nil
 	})
 }
diff --git a/pkg/controller/issuers/BUILD.bazel b/pkg/controller/issuers/BUILD.bazel
index 9b208e93f..db130d8e3 100644
--- a/pkg/controller/issuers/BUILD.bazel
+++ b/pkg/controller/issuers/BUILD.bazel
@@ -22,10 +22,8 @@ go_library(
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/labels:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/errors:go_default_library",
-        "//vendor/k8s.io/apimachinery/pkg/util/wait:go_default_library",
         "//vendor/k8s.io/client-go/listers/core/v1:go_default_library",
         "//vendor/k8s.io/client-go/tools/cache:go_default_library",
-        "//vendor/k8s.io/client-go/util/workqueue:go_default_library",
     ],
 )
 
diff --git a/pkg/controller/issuers/controller.go b/pkg/controller/issuers/controller.go
index f27db5e3e..00708d566 100644
--- a/pkg/controller/issuers/controller.go
+++ b/pkg/controller/issuers/controller.go
@@ -18,16 +18,11 @@ package issuers
 
 import (
 	"context"
-	"fmt"
-	"sync"
-	"time"
 
 	corev1 "k8s.io/api/core/v1"
 	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
-	"k8s.io/apimachinery/pkg/util/wait"
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
-	"k8s.io/client-go/util/workqueue"
 
 	cmlisters "github.com/jetstack/cert-manager/pkg/client/listers/certmanager/v1alpha1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
@@ -36,47 +31,35 @@ import (
 )
 
 type Controller struct {
-	// the controllers root context, containing a controller scoped logger
-	ctx context.Context
-	*controllerpkg.Context
-	issuerFactory issuer.IssuerFactory
+	*controllerpkg.BaseController
 
-	// To allow injection for testing.
-	syncHandler func(ctx context.Context, key string) error
+	issuerFactory issuer.IssuerFactory
 
 	issuerLister cmlisters.IssuerLister
 	secretLister corelisters.SecretLister
-
-	watchedInformers []cache.InformerSynced
-	queue            workqueue.RateLimitingInterface
 }
 
 func New(ctx *controllerpkg.Context) *Controller {
-	ctrl := &Controller{
-		Context: ctx,
-	}
-
-	ctrl.syncHandler = ctrl.processNextWorkItem
-	ctrl.queue = workqueue.NewNamedRateLimitingQueue(controllerpkg.DefaultItemBasedRateLimiter(), "issuers")
+	ctrl := &Controller{}
+	bctrl := controllerpkg.New(ctx, ControllerName, ctrl.processNextWorkItem)
 
-	issuerInformer := ctrl.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
-	issuerInformer.Informer().AddEventHandler(&controllerpkg.QueuingEventHandler{Queue: ctrl.queue})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, issuerInformer.Informer().HasSynced)
+	issuerInformer := ctx.SharedInformerFactory.Certmanager().V1alpha1().Issuers()
+	bctrl.AddQueuing(controllerpkg.DefaultItemBasedRateLimiter(), "issuers", issuerInformer.Informer())
 	ctrl.issuerLister = issuerInformer.Lister()
 
-	secretsInformer := ctrl.KubeSharedInformerFactory.Core().V1().Secrets()
-	secretsInformer.Informer().AddEventHandler(&controllerpkg.BlockingEventHandler{WorkFunc: ctrl.secretDeleted})
-	ctrl.watchedInformers = append(ctrl.watchedInformers, secretsInformer.Informer().HasSynced)
+	secretsInformer := ctx.KubeSharedInformerFactory.Core().V1().Secrets()
+	bctrl.AddHandled(secretsInformer.Informer(), &controllerpkg.BlockingEventHandler{WorkFunc: ctrl.secretDeleted})
 	ctrl.secretLister = secretsInformer.Lister()
+
+	ctrl.BaseController = bctrl
 	ctrl.issuerFactory = issuer.NewIssuerFactory(ctx)
-	ctrl.ctx = logf.NewContext(ctx.RootContext, nil, ControllerName)
 
 	return ctrl
 }
 
 // TODO: replace with generic handleObjet function (like Navigator)
 func (c *Controller) secretDeleted(obj interface{}) {
-	log := logf.FromContext(c.ctx)
+	log := logf.FromContext(c.BaseController.Ctx)
 
 	var secret *corev1.Secret
 	var ok bool
@@ -97,70 +80,8 @@ func (c *Controller) secretDeleted(obj interface{}) {
 			log.Error(err, "error computing key for resource")
 			continue
 		}
-		c.queue.AddRateLimited(key)
-	}
-}
-
-func (c *Controller) Run(workers int, stopCh <-chan struct{}) error {
-	ctx, cancel := context.WithCancel(c.ctx)
-	defer cancel()
-	log := logf.FromContext(ctx)
-
-	log.Info("starting control loop")
-	// wait for all the informer caches we depend on are synced
-	if !cache.WaitForCacheSync(stopCh, c.watchedInformers...) {
-		// TODO: replace with Errorf call to glog
-		return fmt.Errorf("error waiting for informer caches to sync")
-	}
-
-	var wg sync.WaitGroup
-	for i := 0; i < workers; i++ {
-		wg.Add(1)
-		// TODO (@munnerz): make time.Second duration configurable
-		go wait.Until(func() {
-			defer wg.Done()
-			c.worker(ctx)
-		}, time.Second, stopCh)
-	}
-	<-stopCh
-	log.Info("shutting down queue as workqueue signaled shutdown")
-	c.queue.ShutDown()
-	log.V(logf.DebugLevel).Info("waiting for workers to exit...")
-	wg.Wait()
-	log.V(logf.DebugLevel).Info("workers exited")
-	return nil
-}
-
-func (c *Controller) worker(ctx context.Context) {
-	log := logf.FromContext(c.ctx)
-
-	log.V(logf.DebugLevel).Info("starting worker")
-	for {
-		obj, shutdown := c.queue.Get()
-		if shutdown {
-			break
-		}
-
-		var key string
-		// use an inlined function so we can use defer
-		func() {
-			defer c.queue.Done(obj)
-			var ok bool
-			if key, ok = obj.(string); !ok {
-				return
-			}
-			log := log.WithValues("key", key)
-			log.Info("syncing item")
-			if err := c.syncHandler(ctx, key); err != nil {
-				log.Error(err, "re-queuing item  due to error processing")
-				c.queue.AddRateLimited(obj)
-				return
-			}
-			log.Info("finished processing work item")
-			c.queue.Forget(obj)
-		}()
+		c.BaseController.Queue.AddRateLimited(key)
 	}
-	log.V(logf.DebugLevel).Info("exiting worker loop")
 }
 
 func (c *Controller) processNextWorkItem(ctx context.Context, key string) error {
@@ -193,6 +114,6 @@ const (
 
 func init() {
 	controllerpkg.Register(ControllerName, func(ctx *controllerpkg.Context) (controllerpkg.Interface, error) {
-		return New(ctx).Run, nil
+		return New(ctx).BaseController.Run, nil
 	})
 }
diff --git a/vendor/modules.txt b/vendor/modules.txt
index eb51c8101..61a162027 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -649,7 +649,6 @@ k8s.io/client-go/discovery/fake
 k8s.io/client-go/testing
 k8s.io/client-go/tools/cache
 k8s.io/client-go/util/workqueue
-k8s.io/client-go/informers/extensions/v1beta1
 k8s.io/client-go/listers/extensions/v1beta1
 k8s.io/client-go/kubernetes/fake
 k8s.io/client-go/tools/clientcmd
@@ -779,6 +778,7 @@ k8s.io/client-go/informers/coordination/v1
 k8s.io/client-go/informers/coordination/v1beta1
 k8s.io/client-go/informers/core/v1
 k8s.io/client-go/informers/events/v1beta1
+k8s.io/client-go/informers/extensions/v1beta1
 k8s.io/client-go/informers/networking/v1
 k8s.io/client-go/informers/networking/v1beta1
 k8s.io/client-go/informers/node/v1alpha1

commit 48cd58b23fb4753539a1f121b08356bf581cd232 (from a2da614fd543bb9c2a94baaa6f727dc7a57dddca)
Merge: 9c16efdb3 a2da614fd
Author: jetstack-bot <32282838+jetstack-bot@users.noreply.github.com>
Date:   Mon Jun 17 19:27:57 2019 +0100

    Merge pull request #1722 from cheukwing/issue-1003
    
    Add BaseController as a refactoring of common controller code

diff --git a/WORKSPACE b/WORKSPACE
index 96e928b74..cd4ff88c7 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -66,29 +66,12 @@ load(
 
 _go_image_repos()
 
-##Pull some standard base images
+##Use 'static' distroless image for all builds
 container_pull(
-    name = "alpine_linux-amd64",
-    digest = "sha256:cf2412cab4f40318e722d2604fa6c79b3d28a7cb37988d95ab2453577417359a",
-    registry = "index.docker.io",
-    repository = "munnerz/alpine",
-    tag = "3.8-amd64",
-)
-
-container_pull(
-    name = "alpine_linux-arm64",
-    digest = "sha256:4b8a5fc687674dd11ab769b8a711acba667c752b08697a03f6ffb1f1bcd123e5",
-    registry = "index.docker.io",
-    repository = "munnerz/alpine",
-    tag = "3.8-arm64",
-)
-
-container_pull(
-    name = "alpine_linux-arm",
-    digest = "sha256:185cad013588d77b0e78018b5f275a7849a63a33cd926405363825536597d9e2",
-    registry = "index.docker.io",
-    repository = "munnerz/alpine",
-    tag = "3.8-arm",
+    name = "static_base",
+    registry = "gcr.io",
+    repository = "distroless/static",
+    digest = "sha256:cd0679a54d2abaf3644829f5e290ad8a10688847475f570fddb9963318cf9390",
 )
 
 ## Fetch helm & tiller for use in template generation and testing
diff --git a/deploy/charts/cert-manager/cainjector/templates/rbac.yaml b/deploy/charts/cert-manager/cainjector/templates/rbac.yaml
index f2d436f69..f9c0c075a 100644
--- a/deploy/charts/cert-manager/cainjector/templates/rbac.yaml
+++ b/deploy/charts/cert-manager/cainjector/templates/rbac.yaml
@@ -17,13 +17,13 @@ rules:
     verbs: ["get", "list", "watch"]
   - apiGroups: [""]
     resources: ["configmaps", "events"]
-    verbs: ["*"]
+    verbs: ["get", "create", "update", "patch"]
   - apiGroups: ["admissionregistration.k8s.io"]
     resources: ["validatingwebhookconfigurations", "mutatingwebhookconfigurations"]
-    verbs: ["*"]
+    verbs: ["get", "list", "watch", "update"]
   - apiGroups: ["apiregistration.k8s.io"]
     resources: ["apiservices"]
-    verbs: ["*"]
+    verbs: ["get", "list", "watch", "update"]
 ---
 apiVersion: rbac.authorization.k8s.io/v1beta1
 kind: ClusterRoleBinding
diff --git a/deploy/charts/cert-manager/templates/rbac.yaml b/deploy/charts/cert-manager/templates/rbac.yaml
index dcb9c4da1..f8ff2aa2f 100644
--- a/deploy/charts/cert-manager/templates/rbac.yaml
+++ b/deploy/charts/cert-manager/templates/rbac.yaml
@@ -1,33 +1,355 @@
 {{- if .Values.global.rbac.create -}}
+
 apiVersion: rbac.authorization.k8s.io/v1beta1
 kind: ClusterRole
 metadata:
-  name: {{ template "cert-manager.fullname" . }}
+  name: {{ template "cert-manager.fullname" . }}-leaderelection
   labels:
     app: {{ template "cert-manager.name" . }}
     chart: {{ template "cert-manager.chart" . }}
     release: {{ .Release.Name }}
     heritage: {{ .Release.Service }}
 rules:
+  # Used for leader election by the controller
+  - apiGroups: [""]
+    resources: ["configmaps"]
+    verbs: ["get", "create", "update", "patch"]
+
+---
+
+# Issuer controller role
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRole
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-issuers
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+rules:
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["issuers", "issuers/status"]
+    verbs: ["update"]
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["issuers"]
+    verbs: ["get", "list", "watch"]
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get", "list", "watch", "create", "update", "delete"]
+  - apiGroups: [""]
+    resources: ["events"]
+    verbs: ["create", "patch"]
+
+---
+
+# ClusterIssuer controller role
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRole
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-clusterissuers
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+rules:
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["clusterissuers", "clusterissuers/status"]
+    verbs: ["update"]
   - apiGroups: ["certmanager.k8s.io"]
-    resources: ["certificates", "certificates/finalizers", "issuers", "clusterissuers", "orders", "orders/finalizers", "challenges",  "challenges/finalizers"]
-    verbs: ["*"]
+    resources: ["clusterissuers"]
+    verbs: ["get", "list", "watch"]
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get", "list", "watch", "create", "update", "delete"]
   - apiGroups: [""]
-    resources: ["configmaps", "secrets", "events", "services","pods"]
-    verbs: ["*"]
+    resources: ["events"]
+    verbs: ["create", "patch"]
+
+---
+
+# Certificates controller role
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRole
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-certificates
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+rules:
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["certificates", "certificates/status"]
+    verbs: ["update"]
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["certificates", "clusterissuers", "issuers", "orders"]
+    verbs: ["get", "list", "watch"]
+  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
+  #admission controller enabled:
+  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["certificates/finalizers"]
+    verbs: ["update"]
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["orders"]
+    verbs: ["create", "delete"]
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get", "list", "watch", "create", "update", "delete"]
+  - apiGroups: [""]
+    resources: ["events"]
+    verbs: ["create", "patch"]
+
+---
+
+# Orders controller role
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRole
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-orders
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+rules:
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["orders", "orders/status"]
+    verbs: ["update"]
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["orders", "clusterissuers", "issuers", "challenges"]
+    verbs: ["get", "list", "watch"]
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["challenges"]
+    verbs: ["create", "delete"]
+  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
+  #admission controller enabled:
+  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["orders/finalizers"]
+    verbs: ["update"]
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get", "list", "watch"]
+  - apiGroups: [""]
+    resources: ["events"]
+    verbs: ["create", "patch"]
+
+---
+
+# Challenges controller role
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRole
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-challenges
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+rules:
+  # Use to update challenge resource status
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["challenges", "challenges/status"]
+    verbs: ["update"]
+  # Used to watch challenges, issuer and clusterissuer resources
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["challenges", "issuers", "clusterissuers"]
+    verbs: ["get", "list", "watch"]
+  # Need to be able to retrieve ACME account private key to complete challenges
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get", "list", "watch"]
+  # Used to create events
+  - apiGroups: [""]
+    resources: ["events"]
+    verbs: ["create", "patch"]
+  # HTTP01 rules
+  - apiGroups: [""]
+    resources: ["pods", "services"]
+    verbs: ["get", "list", "watch", "create", "delete"]
   - apiGroups: ["extensions"]
-    resources: ["ingresses", "ingresses/finalizers"]
-    verbs: ["*"]
+    resources: ["ingresses"]
+    verbs: ["get", "list", "watch", "create", "delete", "update"]
 {{- if .Values.global.isOpenshift }}
+  # We require the ability to specify a custom hostname when we are creating
+  # new ingress resources.
+  # See: https://github.com/openshift/origin/blob/21f191775636f9acadb44fa42beeb4f75b255532/pkg/route/apiserver/admission/ingress_admission.go#L84-L148
   - apiGroups: ["route.openshift.io"]
-    resources: ["routes", "routes/custom-host", "routes/finalizers"]
-    verbs: ["*"]
+    resources: ["routes/custom-host"]
+    verbs: ["create"]
 {{- end }}
+  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
+  #admission controller enabled:
+  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["challenges/finalizers"]
+    verbs: ["update"]
+  #DNS01 rules (duplicated above)
+  - apiGroups: [""]
+    resources: ["secrets"]
+    verbs: ["get", "list", "watch"]
+
+---
+
+# ingress-shim controller role
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRole
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-ingress-shim
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+rules:
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["certificates"]
+    verbs: ["create", "update", "delete"]
+  - apiGroups: ["certmanager.k8s.io"]
+    resources: ["certificates", "issuers", "clusterissuers"]
+    verbs: ["get", "list", "watch"]
+  - apiGroups: ["extensions"]
+    resources: ["ingresses"]
+    verbs: ["get", "list", "watch"]
+  # We require these rules to support users with the OwnerReferencesPermissionEnforcement
+  #admission controller enabled:
+  # https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement
+  - apiGroups: ["extensions"]
+    resources: ["ingresses/finalizers"]
+    verbs: ["update"]
+  - apiGroups: [""]
+    resources: ["events"]
+    verbs: ["create", "patch"]
+
+---
+
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRoleBinding
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-leaderelection
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: {{ template "cert-manager.fullname" . }}-leaderelection
+subjects:
+  - name: {{ template "cert-manager.serviceAccountName" . }}
+    namespace: {{ .Release.Namespace | quote }}
+    kind: ServiceAccount
+
+---
+
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRoleBinding
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-issuers
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: {{ template "cert-manager.fullname" . }}-controller-issuers
+subjects:
+  - name: {{ template "cert-manager.serviceAccountName" . }}
+    namespace: {{ .Release.Namespace | quote }}
+    kind: ServiceAccount
+
+---
+
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRoleBinding
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-clusterissuers
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: {{ template "cert-manager.fullname" . }}-controller-clusterissuers
+subjects:
+  - name: {{ template "cert-manager.serviceAccountName" . }}
+    namespace: {{ .Release.Namespace | quote }}
+    kind: ServiceAccount
+
+---
+
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRoleBinding
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-certificates
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: {{ template "cert-manager.fullname" . }}-controller-certificates
+subjects:
+  - name: {{ template "cert-manager.serviceAccountName" . }}
+    namespace: {{ .Release.Namespace | quote }}
+    kind: ServiceAccount
+
+---
+
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRoleBinding
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-orders
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: {{ template "cert-manager.fullname" . }}-controller-orders
+subjects:
+  - name: {{ template "cert-manager.serviceAccountName" . }}
+    namespace: {{ .Release.Namespace | quote }}
+    kind: ServiceAccount
+
+---
+
+apiVersion: rbac.authorization.k8s.io/v1beta1
+kind: ClusterRoleBinding
+metadata:
+  name: {{ template "cert-manager.fullname" . }}-controller-challenges
+  labels:
+    app: {{ template "cert-manager.name" . }}
+    chart: {{ template "cert-manager.chart" . }}
+    release: {{ .Release.Name }}
+    heritage: {{ .Release.Service }}
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: {{ template "cert-manager.fullname" . }}-controller-challenges
+subjects:
+  - name: {{ template "cert-manager.serviceAccountName" . }}
+    namespace: {{ .Release.Namespace | quote }}
+    kind: ServiceAccount
+
 ---
+
 apiVersion: rbac.authorization.k8s.io/v1beta1
 kind: ClusterRoleBinding
 metadata:
-  name: {{ template "cert-manager.fullname" . }}
+  name: {{ template "cert-manager.fullname" . }}-controller-ingress-shim
   labels:
     app: {{ template "cert-manager.name" . }}
     chart: {{ template "cert-manager.chart" . }}
@@ -36,12 +358,14 @@ metadata:
 roleRef:
   apiGroup: rbac.authorization.k8s.io
   kind: ClusterRole
-  name: {{ template "cert-manager.fullname" . }}
+  name: {{ template "cert-manager.fullname" . }}-controller-ingress-shim
 subjects:
   - name: {{ template "cert-manager.serviceAccountName" . }}
     namespace: {{ .Release.Namespace | quote }}
     kind: ServiceAccount
+
 ---
+
 apiVersion: rbac.authorization.k8s.io/v1
 kind: ClusterRole
 metadata:
@@ -58,7 +382,9 @@ rules:
   - apiGroups: ["certmanager.k8s.io"]
     resources: ["certificates", "issuers"]
     verbs: ["get", "list", "watch"]
+
 ---
+
 apiVersion: rbac.authorization.k8s.io/v1
 kind: ClusterRole
 metadata:
@@ -74,4 +400,5 @@ rules:
   - apiGroups: ["certmanager.k8s.io"]
     resources: ["certificates", "issuers"]
     verbs: ["create", "delete", "deletecollection", "patch", "update"]
+
 {{- end }}
diff --git a/docs/generated/reference/output/reference/api-docs/index.html b/docs/generated/reference/output/reference/api-docs/index.html
index f9dc8a747..1836e2b28 100755
--- a/docs/generated/reference/output/reference/api-docs/index.html
+++ b/docs/generated/reference/output/reference/api-docs/index.html
@@ -11,7 +11,7 @@
 <link rel="stylesheet" href="stylesheet.css" type="text/css">
 </head>
 <body>
-<div id="sidebar-wrapper" class="side-nav side-bar-nav"><ul><li class="nav-level-1 strong-nav"><a href="#-strong-cert-manager-strong-" class="nav-item"><strong>cert-manager</strong></a></li></ul><ul><li class="nav-level-1"><a href="#certificate-v1alpha1" class="nav-item">Certificate v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#clusterissuer-v1alpha1" class="nav-item">ClusterIssuer v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#issuer-v1alpha1" class="nav-item">Issuer v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#order-v1alpha1" class="nav-item">Order v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#challenge-v1alpha1" class="nav-item">Challenge v1alpha1</a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-old-api-versions-strong-" class="nav-item"><strong>Old API Versions</strong></a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-field-definitions-strong-" class="nav-item"><strong>Field Definitions</strong></a></li><ul id="-strong-field-definitions-strong--nav" style="display: none;"><li class="nav-level-2"><a href="#acmecertificateconfig-v1alpha1" class="nav-item">ACMECertificateConfig v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolver-v1alpha1" class="nav-item">ACMEChallengeSolver v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverdns01-v1alpha1" class="nav-item">ACMEChallengeSolverDNS01 v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverhttp01-v1alpha1" class="nav-item">ACMEChallengeSolverHTTP01 v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverhttp01ingress-v1alpha1" class="nav-item">ACMEChallengeSolverHTTP01Ingress v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuer-v1alpha1" class="nav-item">ACMEIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01config-v1alpha1" class="nav-item">ACMEIssuerDNS01Config v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01provider-v1alpha1" class="nav-item">ACMEIssuerDNS01Provider v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01provideracmedns-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderAcmeDNS v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerakamai-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderAkamai v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerazuredns-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderAzureDNS v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerclouddns-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderCloudDNS v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providercloudflare-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderCloudflare v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerdigitalocean-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderDigitalOcean v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerrfc2136-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderRFC2136 v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerroute53-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderRoute53 v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerwebhook-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderWebhook v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerhttp01config-v1alpha1" class="nav-item">ACMEIssuerHTTP01Config v1alpha1</a></li><li class="nav-level-2"><a href="#caissuer-v1alpha1" class="nav-item">CAIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#certificatecondition-v1alpha1" class="nav-item">CertificateCondition v1alpha1</a></li><li class="nav-level-2"><a href="#certificatednsnameselector-v1alpha1" class="nav-item">CertificateDNSNameSelector v1alpha1</a></li><li class="nav-level-2"><a href="#dns01solverconfig-v1alpha1" class="nav-item">DNS01SolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#domainsolverconfig-v1alpha1" class="nav-item">DomainSolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#duration-v1" class="nav-item">Duration v1</a></li><li class="nav-level-2"><a href="#fields-v1" class="nav-item">Fields v1</a></li><li class="nav-level-2"><a href="#http01solverconfig-v1alpha1" class="nav-item">HTTP01SolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#initializer-v1" class="nav-item">Initializer v1</a></li><li class="nav-level-2"><a href="#initializers-v1" class="nav-item">Initializers v1</a></li><li class="nav-level-2"><a href="#issuercondition-v1alpha1" class="nav-item">IssuerCondition v1alpha1</a></li><li class="nav-level-2"><a href="#listmeta-v1" class="nav-item">ListMeta v1</a></li><li class="nav-level-2"><a href="#localobjectreference-v1alpha1" class="nav-item">LocalObjectReference v1alpha1</a></li><li class="nav-level-2"><a href="#managedfieldsentry-v1" class="nav-item">ManagedFieldsEntry v1</a></li><li class="nav-level-2"><a href="#objectmeta-v1" class="nav-item">ObjectMeta v1</a></li><li class="nav-level-2"><a href="#objectreference-v1alpha1" class="nav-item">ObjectReference v1alpha1</a></li><li class="nav-level-2"><a href="#ownerreference-v1" class="nav-item">OwnerReference v1</a></li><li class="nav-level-2"><a href="#secretkeyselector-v1alpha1" class="nav-item">SecretKeySelector v1alpha1</a></li><li class="nav-level-2"><a href="#selfsignedissuer-v1alpha1" class="nav-item">SelfSignedIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#solverconfig-v1alpha1" class="nav-item">SolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#status-v1" class="nav-item">Status v1</a></li><li class="nav-level-2"><a href="#statuscause-v1" class="nav-item">StatusCause v1</a></li><li class="nav-level-2"><a href="#statusdetails-v1" class="nav-item">StatusDetails v1</a></li><li class="nav-level-2"><a href="#time-v1" class="nav-item">Time v1</a></li><li class="nav-level-2"><a href="#vaultapprole-v1alpha1" class="nav-item">VaultAppRole v1alpha1</a></li><li class="nav-level-2"><a href="#vaultauth-v1alpha1" class="nav-item">VaultAuth v1alpha1</a></li><li class="nav-level-2"><a href="#vaultissuer-v1alpha1" class="nav-item">VaultIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#venaficloud-v1alpha1" class="nav-item">VenafiCloud v1alpha1</a></li><li class="nav-level-2"><a href="#venafiissuer-v1alpha1" class="nav-item">VenafiIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#venafitpp-v1alpha1" class="nav-item">VenafiTPP v1alpha1</a></li></ul></ul><br/><div class="copyright"><a href="https://jetstack.io">Copyright 2018 Jetstack Ltd.</a></div></div>
+<div id="sidebar-wrapper" class="side-nav side-bar-nav"><ul><li class="nav-level-1 strong-nav"><a href="#-strong-cert-manager-strong-" class="nav-item"><strong>cert-manager</strong></a></li></ul><ul><li class="nav-level-1"><a href="#certificate-v1alpha1" class="nav-item">Certificate v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#clusterissuer-v1alpha1" class="nav-item">ClusterIssuer v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#issuer-v1alpha1" class="nav-item">Issuer v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#order-v1alpha1" class="nav-item">Order v1alpha1</a></li></ul><ul><li class="nav-level-1"><a href="#challenge-v1alpha1" class="nav-item">Challenge v1alpha1</a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-old-api-versions-strong-" class="nav-item"><strong>Old API Versions</strong></a></li></ul><ul><li class="nav-level-1 strong-nav"><a href="#-strong-field-definitions-strong-" class="nav-item"><strong>Field Definitions</strong></a></li><ul id="-strong-field-definitions-strong--nav" style="display: none;"><li class="nav-level-2"><a href="#acmecertificateconfig-v1alpha1" class="nav-item">ACMECertificateConfig v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolver-v1alpha1" class="nav-item">ACMEChallengeSolver v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverdns01-v1alpha1" class="nav-item">ACMEChallengeSolverDNS01 v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverhttp01-v1alpha1" class="nav-item">ACMEChallengeSolverHTTP01 v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverhttp01ingress-v1alpha1" class="nav-item">ACMEChallengeSolverHTTP01Ingress v1alpha1</a></li><li class="nav-level-2"><a href="#acmechallengesolverhttp01ingresspodtemplate-v1alpha1" class="nav-item">ACMEChallengeSolverHTTP01IngressPodTemplate v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuer-v1alpha1" class="nav-item">ACMEIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01config-v1alpha1" class="nav-item">ACMEIssuerDNS01Config v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01provider-v1alpha1" class="nav-item">ACMEIssuerDNS01Provider v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01provideracmedns-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderAcmeDNS v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerakamai-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderAkamai v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerazuredns-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderAzureDNS v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerclouddns-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderCloudDNS v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providercloudflare-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderCloudflare v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerdigitalocean-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderDigitalOcean v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerrfc2136-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderRFC2136 v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerroute53-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderRoute53 v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerdns01providerwebhook-v1alpha1" class="nav-item">ACMEIssuerDNS01ProviderWebhook v1alpha1</a></li><li class="nav-level-2"><a href="#acmeissuerhttp01config-v1alpha1" class="nav-item">ACMEIssuerHTTP01Config v1alpha1</a></li><li class="nav-level-2"><a href="#caissuer-v1alpha1" class="nav-item">CAIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#certificatecondition-v1alpha1" class="nav-item">CertificateCondition v1alpha1</a></li><li class="nav-level-2"><a href="#certificatednsnameselector-v1alpha1" class="nav-item">CertificateDNSNameSelector v1alpha1</a></li><li class="nav-level-2"><a href="#dns01solverconfig-v1alpha1" class="nav-item">DNS01SolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#domainsolverconfig-v1alpha1" class="nav-item">DomainSolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#duration-v1" class="nav-item">Duration v1</a></li><li class="nav-level-2"><a href="#fields-v1" class="nav-item">Fields v1</a></li><li class="nav-level-2"><a href="#http01solverconfig-v1alpha1" class="nav-item">HTTP01SolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#initializer-v1" class="nav-item">Initializer v1</a></li><li class="nav-level-2"><a href="#initializers-v1" class="nav-item">Initializers v1</a></li><li class="nav-level-2"><a href="#issuercondition-v1alpha1" class="nav-item">IssuerCondition v1alpha1</a></li><li class="nav-level-2"><a href="#listmeta-v1" class="nav-item">ListMeta v1</a></li><li class="nav-level-2"><a href="#localobjectreference-v1alpha1" class="nav-item">LocalObjectReference v1alpha1</a></li><li class="nav-level-2"><a href="#managedfieldsentry-v1" class="nav-item">ManagedFieldsEntry v1</a></li><li class="nav-level-2"><a href="#objectmeta-v1" class="nav-item">ObjectMeta v1</a></li><li class="nav-level-2"><a href="#objectreference-v1alpha1" class="nav-item">ObjectReference v1alpha1</a></li><li class="nav-level-2"><a href="#ownerreference-v1" class="nav-item">OwnerReference v1</a></li><li class="nav-level-2"><a href="#secretkeyselector-v1alpha1" class="nav-item">SecretKeySelector v1alpha1</a></li><li class="nav-level-2"><a href="#selfsignedissuer-v1alpha1" class="nav-item">SelfSignedIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#solverconfig-v1alpha1" class="nav-item">SolverConfig v1alpha1</a></li><li class="nav-level-2"><a href="#status-v1" class="nav-item">Status v1</a></li><li class="nav-level-2"><a href="#statuscause-v1" class="nav-item">StatusCause v1</a></li><li class="nav-level-2"><a href="#statusdetails-v1" class="nav-item">StatusDetails v1</a></li><li class="nav-level-2"><a href="#time-v1" class="nav-item">Time v1</a></li><li class="nav-level-2"><a href="#vaultapprole-v1alpha1" class="nav-item">VaultAppRole v1alpha1</a></li><li class="nav-level-2"><a href="#vaultauth-v1alpha1" class="nav-item">VaultAuth v1alpha1</a></li><li class="nav-level-2"><a href="#vaultissuer-v1alpha1" class="nav-item">VaultIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#venaficloud-v1alpha1" class="nav-item">VenafiCloud v1alpha1</a></li><li class="nav-level-2"><a href="#venafiissuer-v1alpha1" class="nav-item">VenafiIssuer v1alpha1</a></li><li class="nav-level-2"><a href="#venafitpp-v1alpha1" class="nav-item">VenafiTPP v1alpha1</a></li></ul></ul><br/><div class="copyright"><a href="https://jetstack.io">Copyright 2018 Jetstack Ltd.</a></div></div>
 <div id="wrapper">
 <div id="code-tabs-wrapper" class="code-tabs"><ul class="code-tab-list"></ul></div>
 <div id="page-content-wrapper" class="body-content container-fluid"><h1 id="-strong-cert-manager-strong-"><strong>cert-manager</strong></h1>
@@ -790,10 +790,48 @@ Appears In:
 <td>The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources.</td>
 </tr>
 <tr>
+<td><code>podTemplate</code><br /> *<a href="#acmechallengesolverhttp01ingresspodtemplate-v1alpha1">ACMEChallengeSolverHTTP01IngressPodTemplate</a>*</td>
+<td>Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges. Only labels and annotations may be set and will be merged ontop of the defaults. PodTemplate labels and annotation fields will override fields with matching keys.</td>
+</tr>
+<tr>
 <td><code>serviceType</code><br /> <em>string</em></td>
 <td>Optional service type for Kubernetes solver service</td>
 </tr>
 </tbody></table>
+<h2 id="acmechallengesolverhttp01ingresspodtemplate-v1alpha1">ACMEChallengeSolverHTTP01IngressPodTemplate v1alpha1</h2>
+<table>
+<thead>
+<tr>
+<th>Group</th>
+<th>Version</th>
+<th>Kind</th>
+</tr>
+</thead>
+<tbody><tr>
+<td><code>certmanager</code></td>
+<td><code>v1alpha1</code></td>
+<td><code>ACMEChallengeSolverHTTP01IngressPodTemplate</code></td>
+</tr>
+</tbody></table>
+<aside class="notice">
+Appears In:
+
+<ul> 
+<li><a href="#acmechallengesolverhttp01ingress-v1alpha1">ACMEChallengeSolverHTTP01Ingress v1alpha1</a></li>
+</ul></aside>
+
+<table>
+<thead>
+<tr>
+<th>Field</th>
+<th>Description</th>
+</tr>
+</thead>
+<tbody><tr>
+<td><code>metadata</code><br /> *<a href="#objectmeta-v1">ObjectMeta</a>*</td>
+<td></td>
+</tr>
+</tbody></table>
 <h2 id="acmeissuer-v1alpha1">ACMEIssuer v1alpha1</h2>
 <table>
 <thead>
@@ -1977,6 +2015,7 @@ Appears In:
 Appears In:
 
 <ul> 
+<li><a href="#acmechallengesolverhttp01ingresspodtemplate-v1alpha1">ACMEChallengeSolverHTTP01IngressPodTemplate v1alpha1</a></li>
 <li><a href="#certificate-v1alpha1">Certificate v1alpha1</a></li>
 <li><a href="#challenge-v1alpha1">Challenge v1alpha1</a></li>
 <li><a href="#clusterissuer-v1alpha1">ClusterIssuer v1alpha1</a></li>
diff --git a/docs/generated/reference/output/reference/api-docs/navData.js b/docs/generated/reference/output/reference/api-docs/navData.js
index 598ab849d..ed0f1d8f8 100755
--- a/docs/generated/reference/output/reference/api-docs/navData.js
+++ b/docs/generated/reference/output/reference/api-docs/navData.js
@@ -1 +1 @@
-(function(){navData = {"toc":[{"section":"-strong-field-definitions-strong-","subsections":[{"section":"venafitpp-v1alpha1"},{"section":"venafiissuer-v1alpha1"},{"section":"venaficloud-v1alpha1"},{"section":"vaultissuer-v1alpha1"},{"section":"vaultauth-v1alpha1"},{"section":"vaultapprole-v1alpha1"},{"section":"time-v1"},{"section":"statusdetails-v1"},{"section":"statuscause-v1"},{"section":"status-v1"},{"section":"solverconfig-v1alpha1"},{"section":"selfsignedissuer-v1alpha1"},{"section":"secretkeyselector-v1alpha1"},{"section":"ownerreference-v1"},{"section":"objectreference-v1alpha1"},{"section":"objectmeta-v1"},{"section":"managedfieldsentry-v1"},{"section":"localobjectreference-v1alpha1"},{"section":"listmeta-v1"},{"section":"issuercondition-v1alpha1"},{"section":"initializers-v1"},{"section":"initializer-v1"},{"section":"http01solverconfig-v1alpha1"},{"section":"fields-v1"},{"section":"duration-v1"},{"section":"domainsolverconfig-v1alpha1"},{"section":"dns01solverconfig-v1alpha1"},{"section":"certificatednsnameselector-v1alpha1"},{"section":"certificatecondition-v1alpha1"},{"section":"caissuer-v1alpha1"},{"section":"acmeissuerhttp01config-v1alpha1"},{"section":"acmeissuerdns01providerwebhook-v1alpha1"},{"section":"acmeissuerdns01providerroute53-v1alpha1"},{"section":"acmeissuerdns01providerrfc2136-v1alpha1"},{"section":"acmeissuerdns01providerdigitalocean-v1alpha1"},{"section":"acmeissuerdns01providercloudflare-v1alpha1"},{"section":"acmeissuerdns01providerclouddns-v1alpha1"},{"section":"acmeissuerdns01providerazuredns-v1alpha1"},{"section":"acmeissuerdns01providerakamai-v1alpha1"},{"section":"acmeissuerdns01provideracmedns-v1alpha1"},{"section":"acmeissuerdns01provider-v1alpha1"},{"section":"acmeissuerdns01config-v1alpha1"},{"section":"acmeissuer-v1alpha1"},{"section":"acmechallengesolverhttp01ingress-v1alpha1"},{"section":"acmechallengesolverhttp01-v1alpha1"},{"section":"acmechallengesolverdns01-v1alpha1"},{"section":"acmechallengesolver-v1alpha1"},{"section":"acmecertificateconfig-v1alpha1"}]},{"section":"-strong-old-api-versions-strong-","subsections":[]},{"section":"challenge-v1alpha1","subsections":[]},{"section":"order-v1alpha1","subsections":[]},{"section":"issuer-v1alpha1","subsections":[]},{"section":"clusterissuer-v1alpha1","subsections":[]},{"section":"certificate-v1alpha1","subsections":[]},{"section":"-strong-cert-manager-strong-","subsections":[]}],"flatToc":["venafitpp-v1alpha1","venafiissuer-v1alpha1","venaficloud-v1alpha1","vaultissuer-v1alpha1","vaultauth-v1alpha1","vaultapprole-v1alpha1","time-v1","statusdetails-v1","statuscause-v1","status-v1","solverconfig-v1alpha1","selfsignedissuer-v1alpha1","secretkeyselector-v1alpha1","ownerreference-v1","objectreference-v1alpha1","objectmeta-v1","managedfieldsentry-v1","localobjectreference-v1alpha1","listmeta-v1","issuercondition-v1alpha1","initializers-v1","initializer-v1","http01solverconfig-v1alpha1","fields-v1","duration-v1","domainsolverconfig-v1alpha1","dns01solverconfig-v1alpha1","certificatednsnameselector-v1alpha1","certificatecondition-v1alpha1","caissuer-v1alpha1","acmeissuerhttp01config-v1alpha1","acmeissuerdns01providerwebhook-v1alpha1","acmeissuerdns01providerroute53-v1alpha1","acmeissuerdns01providerrfc2136-v1alpha1","acmeissuerdns01providerdigitalocean-v1alpha1","acmeissuerdns01providercloudflare-v1alpha1","acmeissuerdns01providerclouddns-v1alpha1","acmeissuerdns01providerazuredns-v1alpha1","acmeissuerdns01providerakamai-v1alpha1","acmeissuerdns01provideracmedns-v1alpha1","acmeissuerdns01provider-v1alpha1","acmeissuerdns01config-v1alpha1","acmeissuer-v1alpha1","acmechallengesolverhttp01ingress-v1alpha1","acmechallengesolverhttp01-v1alpha1","acmechallengesolverdns01-v1alpha1","acmechallengesolver-v1alpha1","acmecertificateconfig-v1alpha1","-strong-field-definitions-strong-","-strong-old-api-versions-strong-","challenge-v1alpha1","order-v1alpha1","issuer-v1alpha1","clusterissuer-v1alpha1","certificate-v1alpha1","-strong-cert-manager-strong-"]};})();
\ No newline at end of file
+(function(){navData = {"toc":[{"section":"-strong-field-definitions-strong-","subsections":[{"section":"venafitpp-v1alpha1"},{"section":"venafiissuer-v1alpha1"},{"section":"venaficloud-v1alpha1"},{"section":"vaultissuer-v1alpha1"},{"section":"vaultauth-v1alpha1"},{"section":"vaultapprole-v1alpha1"},{"section":"time-v1"},{"section":"statusdetails-v1"},{"section":"statuscause-v1"},{"section":"status-v1"},{"section":"solverconfig-v1alpha1"},{"section":"selfsignedissuer-v1alpha1"},{"section":"secretkeyselector-v1alpha1"},{"section":"ownerreference-v1"},{"section":"objectreference-v1alpha1"},{"section":"objectmeta-v1"},{"section":"managedfieldsentry-v1"},{"section":"localobjectreference-v1alpha1"},{"section":"listmeta-v1"},{"section":"issuercondition-v1alpha1"},{"section":"initializers-v1"},{"section":"initializer-v1"},{"section":"http01solverconfig-v1alpha1"},{"section":"fields-v1"},{"section":"duration-v1"},{"section":"domainsolverconfig-v1alpha1"},{"section":"dns01solverconfig-v1alpha1"},{"section":"certificatednsnameselector-v1alpha1"},{"section":"certificatecondition-v1alpha1"},{"section":"caissuer-v1alpha1"},{"section":"acmeissuerhttp01config-v1alpha1"},{"section":"acmeissuerdns01providerwebhook-v1alpha1"},{"section":"acmeissuerdns01providerroute53-v1alpha1"},{"section":"acmeissuerdns01providerrfc2136-v1alpha1"},{"section":"acmeissuerdns01providerdigitalocean-v1alpha1"},{"section":"acmeissuerdns01providercloudflare-v1alpha1"},{"section":"acmeissuerdns01providerclouddns-v1alpha1"},{"section":"acmeissuerdns01providerazuredns-v1alpha1"},{"section":"acmeissuerdns01providerakamai-v1alpha1"},{"section":"acmeissuerdns01provideracmedns-v1alpha1"},{"section":"acmeissuerdns01provider-v1alpha1"},{"section":"acmeissuerdns01config-v1alpha1"},{"section":"acmeissuer-v1alpha1"},{"section":"acmechallengesolverhttp01ingresspodtemplate-v1alpha1"},{"section":"acmechallengesolverhttp01ingress-v1alpha1"},{"section":"acmechallengesolverhttp01-v1alpha1"},{"section":"acmechallengesolverdns01-v1alpha1"},{"section":"acmechallengesolver-v1alpha1"},{"section":"acmecertificateconfig-v1alpha1"}]},{"section":"-strong-old-api-versions-strong-","subsections":[]},{"section":"challenge-v1alpha1","subsections":[]},{"section":"order-v1alpha1","subsections":[]},{"section":"issuer-v1alpha1","subsections":[]},{"section":"clusterissuer-v1alpha1","subsections":[]},{"section":"certificate-v1alpha1","subsections":[]},{"section":"-strong-cert-manager-strong-","subsections":[]}],"flatToc":["venafitpp-v1alpha1","venafiissuer-v1alpha1","venaficloud-v1alpha1","vaultissuer-v1alpha1","vaultauth-v1alpha1","vaultapprole-v1alpha1","time-v1","statusdetails-v1","statuscause-v1","status-v1","solverconfig-v1alpha1","selfsignedissuer-v1alpha1","secretkeyselector-v1alpha1","ownerreference-v1","objectreference-v1alpha1","objectmeta-v1","managedfieldsentry-v1","localobjectreference-v1alpha1","listmeta-v1","issuercondition-v1alpha1","initializers-v1","initializer-v1","http01solverconfig-v1alpha1","fields-v1","duration-v1","domainsolverconfig-v1alpha1","dns01solverconfig-v1alpha1","certificatednsnameselector-v1alpha1","certificatecondition-v1alpha1","caissuer-v1alpha1","acmeissuerhttp01config-v1alpha1","acmeissuerdns01providerwebhook-v1alpha1","acmeissuerdns01providerroute53-v1alpha1","acmeissuerdns01providerrfc2136-v1alpha1","acmeissuerdns01providerdigitalocean-v1alpha1","acmeissuerdns01providercloudflare-v1alpha1","acmeissuerdns01providerclouddns-v1alpha1","acmeissuerdns01providerazuredns-v1alpha1","acmeissuerdns01providerakamai-v1alpha1","acmeissuerdns01provideracmedns-v1alpha1","acmeissuerdns01provider-v1alpha1","acmeissuerdns01config-v1alpha1","acmeissuer-v1alpha1","acmechallengesolverhttp01ingresspodtemplate-v1alpha1","acmechallengesolverhttp01ingress-v1alpha1","acmechallengesolverhttp01-v1alpha1","acmechallengesolverdns01-v1alpha1","acmechallengesolver-v1alpha1","acmecertificateconfig-v1alpha1","-strong-field-definitions-strong-","-strong-old-api-versions-strong-","challenge-v1alpha1","order-v1alpha1","issuer-v1alpha1","clusterissuer-v1alpha1","certificate-v1alpha1","-strong-cert-manager-strong-"]};})();
\ No newline at end of file
diff --git a/docs/getting-started/install/kubernetes.rst b/docs/getting-started/install/kubernetes.rst
index 88bcde461..5695d0969 100644
--- a/docs/getting-started/install/kubernetes.rst
+++ b/docs/getting-started/install/kubernetes.rst
@@ -57,7 +57,7 @@ are included in a single YAML manifest file:
 .. code-block:: shell
 
    # Install the CustomResourceDefinitions and cert-manager itself
-   kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v0.8.0-beta.0/cert-manager.yaml
+   kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v0.8.0/cert-manager.yaml
 
 .. note::
    If you are running kubectl v1.12 or below, you will need to add the
@@ -133,7 +133,7 @@ In order to install the Helm chart, you must run:
    helm install \
      --name cert-manager \
      --namespace cert-manager \
-     --version v0.8.0-beta.0 \
+     --version v0.8.0 \
      jetstack/cert-manager
 
 The default cert-manager configuration is good for the majority of users, but a
diff --git a/docs/getting-started/install/openshift.rst b/docs/getting-started/install/openshift.rst
index f49760525..5ff36154d 100644
--- a/docs/getting-started/install/openshift.rst
+++ b/docs/getting-started/install/openshift.rst
@@ -69,7 +69,7 @@ are included in a single YAML manifest file:
 .. code-block:: shell
 
    # Install the CustomResourceDefinitions and cert-manager itself
-   oc apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.8.0-beta.0/cert-manager-openshift.yaml
+   oc apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v0.8.0/cert-manager-openshift.yaml
 
 .. note::
    The ``--validate=false`` flag is added to the ``oc apply`` command above
diff --git a/docs/tasks/issuers/setup-acme/dns01/google.rst b/docs/tasks/issuers/setup-acme/dns01/google.rst
index 6f78f12ad..eeae95136 100644
--- a/docs/tasks/issuers/setup-acme/dns01/google.rst
+++ b/docs/tasks/issuers/setup-acme/dns01/google.rst
@@ -83,7 +83,7 @@ Once an Issuer (or ClusterIssuer) has been created successfully a Certificate ca
      secretName: example-com-tls
      issuerRef:
        # The issuer created previously
-       name: letsencrypt-staging
+       name: example-issuer
      commonName: example.com
      dnsNames:
      - example.com
diff --git a/docs/tasks/issuers/setup-acme/dns01/index.rst b/docs/tasks/issuers/setup-acme/dns01/index.rst
index 1a2755052..a4c91049a 100644
--- a/docs/tasks/issuers/setup-acme/dns01/index.rst
+++ b/docs/tasks/issuers/setup-acme/dns01/index.rst
@@ -64,6 +64,41 @@ Example usage::
 
 .. _supported-dns01-providers:
 
+Delegated Domains for DNS01
+===========================
+
+By default, cert-manager will not follow CNAME records pointing to subdomains.
+
+If granting cert-manager access to the root DNS zone is not desired, then the
+_acme-challenge.example.com subdomain can instead be delegated to some other,
+less privileged domain.
+Once a CNAME record has been configured to point at the desired domain, and the
+DNS configuration/credentials for the zone that *should be updated* have been
+provided, all that is left to be done is adding an additional field into the
+relevant `dns01` solver:
+
+.. code-block:: yaml
+   :linenos:
+   :emphasize-lines: 11
+
+   apiVersion: certmanager.k8s.io/v1alpha1
+   kind: Issuer
+   metadata:
+     ...
+   spec:
+     acme:
+       ...
+       solvers:
+       - dns01:
+           # Valid values are None and Follow
+           cnameStrategy: Follow
+           clouddns:
+             ...
+
+cert-manager will then follow CNAME records recursively in order to determine
+which DNS zone to update during DNS01 challenges.
+
+
 *************************
 Supported DNS01 providers
 *************************
diff --git a/docs/tasks/issuers/setup-acme/http01/index.rst b/docs/tasks/issuers/setup-acme/http01/index.rst
index 69f621ad4..7cd9188d8 100644
--- a/docs/tasks/issuers/setup-acme/http01/index.rst
+++ b/docs/tasks/issuers/setup-acme/http01/index.rst
@@ -67,3 +67,36 @@ response specify the following http01 config:
 
 By default type NodePort will be used when you don't set http01 or when you set
 serviceType to an empty string. Normally there's no need to change this.
+
+podTemplate
+-----------
+
+You may wish to change or add to the labels and annotations of solver pods.
+These can be configured under the `metadata` field under `podTemplate`. No other
+metadata fields can be edited. Below shows how an issuer that is configured to
+add some labels and annotations to solver pods.
+
+.. code-block:: yaml
+
+       apiVersion: certmanager.k8s.io/v1alpha1
+       kind: Issuer
+       metadata:
+         name: ...
+       spec:
+         acme:
+           server: ...
+           privateKeySecretRef:
+             name: ...
+           solvers:
+           - http01:
+               ingress:
+                 podTemplate:
+                   metadata:
+                     labels:
+                       foo: "bar"
+                       env: "prod"
+                     annotations:
+                       my: "annotation"
+
+The added labels and annotations will merge on top of the cert-manager defaults,
+overriding entries with the same key.
diff --git a/docs/tasks/issuers/setup-acme/index.rst b/docs/tasks/issuers/setup-acme/index.rst
index c0b4cdc28..b32f7d636 100644
--- a/docs/tasks/issuers/setup-acme/index.rst
+++ b/docs/tasks/issuers/setup-acme/index.rst
@@ -112,10 +112,10 @@ along with a DNS01 solver that can be used for wildcard certificates:
        - http01:
            ingress:
              class: nginx
-       - dns01:
-           selector:
-             matchLabels:
-               use-cloudflare-solver: "true"
+       - selector:
+           matchLabels:
+             use-cloudflare-solver: "true"
+         dns01:
            cloudflare:
              email: user@example.com
              apiKeySecretRef:
@@ -151,10 +151,10 @@ For example:
        - http01:
            ingress:
              class: nginx
-       - dns01:
-           selector:
-             dnsNames:
-             - '*.example.com'
+       - selector:
+           dnsNames:
+           - '*.example.com'
+         dns01:
            cloudflare:
              email: user@example.com
              apiKeySecretRef:
diff --git a/docs/tasks/issuing-certificates/index.rst b/docs/tasks/issuing-certificates/index.rst
index cf0a92e77..4dddcd861 100644
--- a/docs/tasks/issuing-certificates/index.rst
+++ b/docs/tasks/issuing-certificates/index.rst
@@ -68,6 +68,16 @@ The Certificate will be issued using the issuer named ``ca-issuer`` in the
    :doc:`webhook </getting-started/webhook>` component can prevent cert-manager
    from functioning correctly (`#1269`_).
 
+.. note::
+   Take care when setting the ``renewBefore`` field to be very close to the
+   ``duration`` as this can lead to a renewal loop, where the Certificate is
+   always in the renewal period. Some Issuers set the ``notBefore`` field on
+   their issued X.509 certificate before the issue time to fix clock-skew
+   issues, leading to the working duration of a certificate to be less than
+   the full duration of the certificate. For example, Let's Encrypt sets it
+   to be one hour before issue time, so the actual *working duration* of the
+   certificate is 89 days, 23 hours (the *full duration* remains 90 days). 
+
 A full list of the fields supported on the Certificate resource can be found in
 the `API reference documentation`_.
 
diff --git a/docs/tutorials/acme/migrating-from-kube-lego.rst b/docs/tutorials/acme/migrating-from-kube-lego.rst
index 28a138135..44d785675 100644
--- a/docs/tutorials/acme/migrating-from-kube-lego.rst
+++ b/docs/tutorials/acme/migrating-from-kube-lego.rst
@@ -161,7 +161,10 @@ Create a file named ``cluster-issuer.yaml``:
        privateKeySecretRef:
          name: letsencrypt-private-key
        # Enable the HTTP-01 challenge provider
-       http01: {}
+       solvers:
+       - http01:
+           ingress:
+             class: nginx
 
 We then submit this file to our Kubernetes cluster:
 
@@ -172,35 +175,14 @@ We then submit this file to our Kubernetes cluster:
 You should be able to verify the ACME account has been verified successfully:
 
 .. code-block:: shell
-   :emphasize-lines: 26-31
 
    $ kubectl describe clusterissuer letsencrypt-staging
-   Name:         letsencrypt-staging
-   Namespace:
-   Labels:       <none>
-   Annotations:  <none>
-   API Version:  certmanager.k8s.io/v1alpha1
-   Kind:         ClusterIssuer
-   Metadata:
-     Cluster Name:
-     Creation Timestamp:  2017-11-30T22:33:40Z
-     Generation:          0
-     Resource Version:    4450170
-     Self Link:           /apis/certmanager.k8s.io/v1alpha1/letsencrypt-staging
-     UID:                 83d04e6b-d61e-11e7-ac26-42010a840044
-   Spec:
-     Acme:
-       Email:  user@example.com
-       Http 01:
-       Private Key Secret Ref:
-         Key:
-         Name:  letsencrypt-private-key
-       Server:  https://acme-staging-v02.api.letsencrypt.org/directory
+   ...
    Status:
      Acme:
-       Uri:  https://acme-staging-v02.api.letsencrypt.org/acme/acct/11217539
+       Uri:  https://acme-staging-v02.api.letsencrypt.org/acme/acct/7571319
      Conditions:
-       Last Transition Time:  2018-04-12T17:32:30Z
+       Last Transition Time:  2019-01-30T14:52:03Z
        Message:               The ACME account was registered with the ACME server
        Reason:                ACMEAccountRegistered
        Status:                True
diff --git a/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml b/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml
index 34a41de3d..be872179f 100644
--- a/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml
+++ b/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml
@@ -5,7 +5,6 @@ metadata:
   annotations:
     kubernetes.io/ingress.class: "nginx"    
     certmanager.k8s.io/issuer: "letsencrypt-prod"
-    certmanager.k8s.io/acme-challenge-type: http01
 
 spec:
   tls:
diff --git a/docs/tutorials/acme/quick-start/example/ingress-tls.yaml b/docs/tutorials/acme/quick-start/example/ingress-tls.yaml
index 87a4e7659..02693f102 100644
--- a/docs/tutorials/acme/quick-start/example/ingress-tls.yaml
+++ b/docs/tutorials/acme/quick-start/example/ingress-tls.yaml
@@ -5,7 +5,6 @@ metadata:
   annotations:
     kubernetes.io/ingress.class: "nginx"    
     certmanager.k8s.io/issuer: "letsencrypt-staging"
-    certmanager.k8s.io/acme-challenge-type: http01
 
 spec:
   tls:
diff --git a/docs/tutorials/acme/quick-start/example/ingress.yaml b/docs/tutorials/acme/quick-start/example/ingress.yaml
index 7dcd112bf..c35e524da 100644
--- a/docs/tutorials/acme/quick-start/example/ingress.yaml
+++ b/docs/tutorials/acme/quick-start/example/ingress.yaml
@@ -5,7 +5,6 @@ metadata:
   annotations:
     kubernetes.io/ingress.class: "nginx"    
     #certmanager.k8s.io/issuer: "letsencrypt-staging"
-    #certmanager.k8s.io/acme-challenge-type: http01
 
 spec:
   tls:
diff --git a/docs/tutorials/acme/quick-start/example/production-issuer.yaml b/docs/tutorials/acme/quick-start/example/production-issuer.yaml
index 679ee0681..8ac1b8481 100644
--- a/docs/tutorials/acme/quick-start/example/production-issuer.yaml
+++ b/docs/tutorials/acme/quick-start/example/production-issuer.yaml
@@ -12,4 +12,7 @@
        privateKeySecretRef:
          name: letsencrypt-prod
        # Enable the HTTP-01 challenge provider
-       http01: {}
+       solvers:
+       - http01:
+           ingress:
+             class: nginx
diff --git a/docs/tutorials/acme/quick-start/example/staging-issuer.yaml b/docs/tutorials/acme/quick-start/example/staging-issuer.yaml
index 01b028b04..ca378e5d4 100644
--- a/docs/tutorials/acme/quick-start/example/staging-issuer.yaml
+++ b/docs/tutorials/acme/quick-start/example/staging-issuer.yaml
@@ -12,4 +12,7 @@
        privateKeySecretRef:
          name: letsencrypt-staging
        # Enable the HTTP-01 challenge provider
-       http01: {}
+       solvers:
+       - http01:
+           ingress:
+             class:  nginx
diff --git a/docs/tutorials/acme/quick-start/index.rst b/docs/tutorials/acme/quick-start/index.rst
index d3bb50e96..c6f976db3 100644
--- a/docs/tutorials/acme/quick-start/index.rst
+++ b/docs/tutorials/acme/quick-start/index.rst
@@ -354,18 +354,25 @@ install cert-manager. This example installed cert-manager into the
     # chart in the next step for `release-0.8` of cert-manager:
     $ kubectl apply -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/deploy/manifests/00-crds.yaml
 
-    ## IMPORTANT: if the cert-manager namespace **already exists**, you MUST ensure
-    ## it has an additional label on it in order for the deployment to succeed
-    $ kubectl label namespace cert-manager certmanager.k8s.io/disable-validation="true"
+    # Create the namespace for cert-manager
+    $ kubectl create namespace cert-manager
+
+    # Label the cert-manager namespace to disable resource validation
+    $ kubectl label namespace cert-manager certmanager.k8s.io/disable-validation=true
 
     ## Add the Jetstack Helm repository
     $ helm repo add jetstack https://charts.jetstack.io
+
     ## Updating the repo just incase it already existed
     $ helm repo update
 
     ## Install the cert-manager helm chart
-    $ helm install --name cert-manager --namespace cert-manager jetstack/cert-manager
-   
+    $ helm install \
+      --name cert-manager \
+      --namespace cert-manager \
+      --version v0.8.0 \
+      jetstack/cert-manager
+
     NAME:   cert-manager
     LAST DEPLOYED: Wed Jan  9 13:36:13 2019
     NAMESPACE: cert-manager
@@ -468,6 +475,18 @@ operation. These two resources are:
     certificates. An Issuer is specific to a single namespace in Kubernetes,
     and a ClusterIssuer is meant to be a cluster-wide definition for the same
     purpose.
+    
+    Note that if you're using this document as a guide to configure cert-manager
+    for your own Issuer, you must create the Issuers in the same namespace
+    as your Ingress resouces by adding '-n my-namespace' to your 'kubectl create'
+    commands. Your other option is to replace your Issuers with ClusterIssuers.
+    ClusterIssuer resources apply across all Ingress resources in your cluster
+    and don't have this namespace-matching requirement.
+    
+    More information on the differences between Issuers and ClusterIssuers and
+    when you might choose to use each can be found at:
+    
+    https://docs.cert-manager.io/en/latest/tasks/issuers/index.html#difference-between-issuers-and-clusterissuers
 
 :doc:`Certificate </reference/certificates>`
 
@@ -516,7 +535,7 @@ will need to update this example and add in your own email address.
 .. literalinclude:: example/production-issuer.yaml
    :language: yaml
    :emphasize-lines: 10
-   
+
 .. _`production-issuer.yaml`: https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/production-issuer.yaml
 
 .. code-block:: shell
@@ -550,11 +569,14 @@ Check on the status of the issuer after you create it:
     Spec:
       Acme:
         Email:  your.email@your-domain.com
-        Http 01:
         Private Key Secret Ref:
           Key:
           Name:  letsencrypt-staging
         Server:  https://acme-staging-v02.api.letsencrypt.org/directory
+        Solvers:
+          Http 01:
+            Ingress:
+              Class:  nginx
     Status:
       Acme:
         Uri:  https://acme-staging-v02.api.letsencrypt.org/acme/acct/7374163
@@ -647,13 +669,6 @@ certificate object. You can view this information using the
       Self Link:               /apis/certmanager.k8s.io/v1alpha1/namespaces/default/certificates/quickstart-example-tls
       UID:                     68d43400-ea92-11e8-82f8-42010a8a00b5
     Spec:
-      Acme:
-        Config:
-          Domains:
-            example.your-domain.com
-          Http 01:
-            Ingress:
-            Ingress Class:  nginx
       Dns Names:
         example.your-domain.com
       Issuer Ref:
@@ -714,7 +729,7 @@ can update the annotations in the ingress to specify the production issuer:
 
 .. literalinclude:: example/ingress-tls-final.yaml
    :language: yaml
-   
+
 .. _`ingress-tls-final.yaml`: https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/docs/tutorials/acme/quick-start/example/ingress-tls-final.yaml
 
 .. code-block:: shell
@@ -763,13 +778,6 @@ certificate.
       Self Link:               /apis/certmanager.k8s.io/v1alpha1/namespaces/default/certificates/quickstart-example-tls
       UID:                     bdd93b32-ea97-11e8-82f8-42010a8a00b5
     Spec:
-      Acme:
-        Config:
-          Domains:
-            example.your-domain.com
-          Http 01:
-            Ingress:
-            Ingress Class:  nginx
       Dns Names:
         example.your-domain.com
       Issuer Ref:
@@ -785,7 +793,7 @@ certificate.
         Type:                  Ready
     Events:
       Type    Reason        Age   From          Message
-      ----    ------        ----  ----          -------
+   kubectl describe certificate quickstart-example-tls   ----    ------        ----  ----          -------
       Normal  Generated     18s   cert-manager  Generated new private key
       Normal  OrderCreated  18s   cert-manager  Created Order resource "quickstart-example-tls-889745041"
 
diff --git a/go.mod b/go.mod
index 576e759ae..728eb3b9d 100644
--- a/go.mod
+++ b/go.mod
@@ -10,7 +10,7 @@ require (
 	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
 	github.com/SAP/go-hdb v0.14.1 // indirect
 	github.com/SermoDigital/jose v0.9.1 // indirect
-	github.com/Venafi/vcert v0.0.0-20181029235941-5068538d4d65
+	github.com/Venafi/vcert v0.0.0-20190530133915-e207710a0ab9
 	github.com/appscode/jsonpatch v0.0.0-20190108182946-7c0e3b262f30 // indirect
 	github.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da // indirect
 	github.com/armon/go-radix v1.0.0 // indirect
@@ -87,7 +87,6 @@ require (
 	github.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829
 	github.com/ryanuber/go-glob v1.0.0 // indirect
 	github.com/sethgrid/pester v0.0.0-20190127155807-68a33a018ad0 // indirect
-	github.com/smartystreets/goconvey v0.0.0-20190330032615-68dc04aab96a // indirect
 	github.com/spf13/cobra v0.0.0-20170905172051-b78744579491
 	github.com/spf13/pflag v1.0.1
 	github.com/stretchr/testify v1.3.0
diff --git a/go.sum b/go.sum
index b9a54ba12..27900a0a4 100644
--- a/go.sum
+++ b/go.sum
@@ -32,8 +32,8 @@ github.com/SermoDigital/jose v0.9.1 h1:atYaHPD3lPICcbK1owly3aPm0iaJGSGPi0WD4vLzn
 github.com/SermoDigital/jose v0.9.1/go.mod h1:ARgCUhI1MHQH+ONky/PAtmVHQrP5JlGY0F3poXOp/fA=
 github.com/Shopify/sarama v1.19.0/go.mod h1:FVkBWblsNy7DGZRfXLU0O9RCGt5g3g3yEuWXgklEdEo=
 github.com/Shopify/toxiproxy v2.1.4+incompatible/go.mod h1:OXgGpZ6Cli1/URJOF1DMxUHB2q5Ap20/P/eIdh4G0pI=
-github.com/Venafi/vcert v0.0.0-20181029235941-5068538d4d65 h1:An1XpraQx4IkI2i0kcXFS+VjTSK/lRb1ZioZRmTdDMA=
-github.com/Venafi/vcert v0.0.0-20181029235941-5068538d4d65/go.mod h1:3dpfrCI+31cDZosD+1UX8GFziVFORaegByXtzT1dwNo=
+github.com/Venafi/vcert v0.0.0-20190530133915-e207710a0ab9 h1:dt3QeZOpoi4ee72KwblGKmX2v6WbVS37yjCeZq6SV9w=
+github.com/Venafi/vcert v0.0.0-20190530133915-e207710a0ab9/go.mod h1:3sXw16DKVded/kLVDma2veqEUQC7O37h98ims7cIvN4=
 github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
 github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
 github.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=
@@ -226,6 +226,7 @@ github.com/hashicorp/vault v0.9.6 h1:AalVi4vunOMSXX7eD8j8WKxkWr2AmG6yvz9o3ITSaMc
 github.com/hashicorp/vault v0.9.6/go.mod h1:KfSyffbKxoVyspOdlaGVjIuwLobi07qD1bAbosPMpP0=
 github.com/hashicorp/yamux v0.0.0-20180604194846-3520598351bb h1:b5rjCoWHc7eqmAS4/qyk21ZsHyb6Mxv/jykxvNTkU4M=
 github.com/hashicorp/yamux v0.0.0-20180604194846-3520598351bb/go.mod h1:+NfK9FKeTrX5uv1uIXGdwYDTeHna2qgaIlx54MXqjAM=
+github.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2c/go.mod h1:lADxMC39cJJqL93Duh1xhAs4I2Zs8mKS89XWXFGp9cs=
 github.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=
 github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
 github.com/imdario/mergo v0.3.5 h1:JboBksRwiiAJWvIYJVo46AfV+IAIKZpfrSzVKj42R4Q=
@@ -392,6 +393,7 @@ golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnf
 golang.org/x/crypto v0.0.0-20181025213731-e84da0312774/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
 golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
 golang.org/x/crypto v0.0.0-20190325154230-a5d413f7728c/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
+golang.org/x/crypto v0.0.0-20190424203555-c05e17bb3b2d/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
 golang.org/x/crypto v0.0.0-20190426145343-a29dc8fdc734 h1:p/H982KKEjUnLJkM3tt/LemDnOc1GiZL5FCVlORJ5zo=
 golang.org/x/crypto v0.0.0-20190426145343-a29dc8fdc734/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
@@ -436,6 +438,7 @@ golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5h
 golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20190425045458-9f0b1ff7b46a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190502175342-a43fa875dd82 h1:vsphBvatvfbhlb4PO1BYSr9dzugGxJ/SQHoNufZJq1w=
 golang.org/x/sys v0.0.0-20190502175342-a43fa875dd82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
@@ -491,6 +494,7 @@ gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMy
 gopkg.in/inf.v0 v0.9.0/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=
 gopkg.in/inf.v0 v0.9.1 h1:73M5CoZyi3ZLMOyDlQh031Cx6N9NDJ2Vvfl76EDAgDc=
 gopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=
+gopkg.in/ini.v1 v1.38.2/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
 gopkg.in/ini.v1 v1.42.0 h1:7N3gPTt50s8GuLortA00n8AqRTk75qOP98+mTPpgzRk=
 gopkg.in/ini.v1 v1.42.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
 gopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce h1:xcEWjVhvbDy+nHP67nPDDpbYrY+ILlfndk4bRioVHaU=
@@ -543,3 +547,4 @@ sigs.k8s.io/testing_frameworks v0.1.1 h1:cP2l8fkA3O9vekpy5Ks8mmA0NW/F7yBdXf8brkW
 sigs.k8s.io/testing_frameworks v0.1.1/go.mod h1:VVBKrHmJ6Ekkfz284YKhQePcdycOzNH9qL6ht1zEr/U=
 sigs.k8s.io/yaml v1.1.0 h1:4A07+ZFc2wgJwo8YNlQpr1rVlgUDlxXHhPJciaPY5gs=
 sigs.k8s.io/yaml v1.1.0/go.mod h1:UJmg0vDUVViEyp3mgSv9WPwZCDxu4rQW1olrI1uml+o=
+software.sslmate.com/src/go-pkcs12 v0.0.0-20180114231543-2291e8f0f237/go.mod h1:/xvNRWUqm0+/ZMiF4EX00vrSCMsE4/NHb+Pt3freEeQ=
diff --git a/hack/def.bzl b/hack/def.bzl
index 2d6899496..c0bfb3b3d 100644
--- a/hack/def.bzl
+++ b/hack/def.bzl
@@ -52,7 +52,7 @@ def multiarch_image(
     for os in goos:
       go_image(
           name = "%s.app_%s-%s" % (name, os, arch),
-          base = "@alpine_%s-%s//image" % (os, arch),
+          base = "@static_base//image",
           embed = [":go_default_library"],
           goarch = arch,
           goos = os,
diff --git a/pkg/apis/certmanager/v1alpha1/types_issuer.go b/pkg/apis/certmanager/v1alpha1/types_issuer.go
index d84cc5d2d..8348a3750 100644
--- a/pkg/apis/certmanager/v1alpha1/types_issuer.go
+++ b/pkg/apis/certmanager/v1alpha1/types_issuer.go
@@ -280,6 +280,17 @@ type ACMEChallengeSolverHTTP01Ingress struct {
 	// ingress resources.
 	// +optional
 	Name string `json:"name,omitempty"`
+
+	// Optional pod template used to configure the ACME challenge solver pods
+	// used for HTTP01 challenges. Only labels and annotations may be set and
+	// will be merged ontop of the defaults. PodTemplate labels and annotation
+	// fields will override fields with matching keys.
+	// +optional
+	PodTemplate *ACMEChallengeSolverHTTP01IngressPodTemplate `json:"podTemplate,omitempty"`
+}
+
+type ACMEChallengeSolverHTTP01IngressPodTemplate struct {
+	metav1.ObjectMeta `json:"metadata,omitempty"`
 }
 
 type ACMEChallengeSolverDNS01 struct {
diff --git a/pkg/apis/certmanager/v1alpha1/zz_generated.deepcopy.go b/pkg/apis/certmanager/v1alpha1/zz_generated.deepcopy.go
index f1ffdd53a..402123e46 100644
--- a/pkg/apis/certmanager/v1alpha1/zz_generated.deepcopy.go
+++ b/pkg/apis/certmanager/v1alpha1/zz_generated.deepcopy.go
@@ -170,6 +170,11 @@ func (in *ACMEChallengeSolverHTTP01Ingress) DeepCopyInto(out *ACMEChallengeSolve
 		*out = new(string)
 		**out = **in
 	}
+	if in.PodTemplate != nil {
+		in, out := &in.PodTemplate, &out.PodTemplate
+		*out = new(ACMEChallengeSolverHTTP01IngressPodTemplate)
+		(*in).DeepCopyInto(*out)
+	}
 	return
 }
 
@@ -183,6 +188,23 @@ func (in *ACMEChallengeSolverHTTP01Ingress) DeepCopy() *ACMEChallengeSolverHTTP0
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ACMEChallengeSolverHTTP01IngressPodTemplate) DeepCopyInto(out *ACMEChallengeSolverHTTP01IngressPodTemplate) {
+	*out = *in
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ACMEChallengeSolverHTTP01IngressPodTemplate.
+func (in *ACMEChallengeSolverHTTP01IngressPodTemplate) DeepCopy() *ACMEChallengeSolverHTTP01IngressPodTemplate {
+	if in == nil {
+		return nil
+	}
+	out := new(ACMEChallengeSolverHTTP01IngressPodTemplate)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *ACMEIssuer) DeepCopyInto(out *ACMEIssuer) {
 	*out = *in
diff --git a/pkg/apis/certmanager/validation/BUILD.bazel b/pkg/apis/certmanager/validation/BUILD.bazel
index 44d937346..dca908caf 100644
--- a/pkg/apis/certmanager/validation/BUILD.bazel
+++ b/pkg/apis/certmanager/validation/BUILD.bazel
@@ -15,6 +15,7 @@ go_library(
         "//pkg/apis/certmanager/v1alpha1:go_default_library",
         "//pkg/issuer/acme/dns/rfc2136:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/util/validation/field:go_default_library",
     ],
 )
diff --git a/pkg/apis/certmanager/validation/issuer.go b/pkg/apis/certmanager/validation/issuer.go
index 82a8fb12d..d58131b74 100644
--- a/pkg/apis/certmanager/validation/issuer.go
+++ b/pkg/apis/certmanager/validation/issuer.go
@@ -19,11 +19,13 @@ package validation
 import (
 	"crypto/x509"
 	"fmt"
+	"reflect"
 	"strings"
 
 	"github.com/jetstack/cert-manager/pkg/issuer/acme/dns/rfc2136"
 
 	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
@@ -106,6 +108,54 @@ func ValidateACMEIssuerConfig(iss *v1alpha1.ACMEIssuer, fldPath *field.Path) fie
 	if iss.DNS01 != nil {
 		el = append(el, ValidateACMEIssuerDNS01Config(iss.DNS01, fldPath.Child("dns01"))...)
 	}
+	for _, sol := range iss.Solvers {
+		el = append(el, ValidateACMEIssuerChallengeSolverConfig(&sol, fldPath.Child("solver"))...)
+	}
+
+	return el
+}
+
+func ValidateACMEIssuerChallengeSolverConfig(sol *v1alpha1.ACMEChallengeSolver, fldPath *field.Path) field.ErrorList {
+	el := field.ErrorList{}
+
+	if sol.HTTP01 != nil {
+		el = append(el, ValidateACMEIssuerChallengeSolverHTTP01Config(sol.HTTP01, fldPath.Child("http01"))...)
+	}
+
+	return el
+}
+
+func ValidateACMEIssuerChallengeSolverHTTP01Config(http01 *v1alpha1.ACMEChallengeSolverHTTP01, fldPath *field.Path) field.ErrorList {
+	el := field.ErrorList{}
+
+	if http01.Ingress != nil {
+		el = append(el, ValidateACMEIssuerChallengeSolverHTTP01IngressConfig(http01.Ingress, fldPath.Child("ingress"))...)
+	}
+
+	return el
+}
+
+func ValidateACMEIssuerChallengeSolverHTTP01IngressConfig(ingress *v1alpha1.ACMEChallengeSolverHTTP01Ingress, fldPath *field.Path) field.ErrorList {
+	el := field.ErrorList{}
+
+	if ingress.PodTemplate != nil {
+		el = append(el, ValidateACMEIssuerChallengeSolverHTTP01IngressPodTemplateConfig(ingress.PodTemplate, fldPath.Child("podTemplate"))...)
+	}
+
+	return el
+}
+
+func ValidateACMEIssuerChallengeSolverHTTP01IngressPodTemplateConfig(podTempl *v1alpha1.ACMEChallengeSolverHTTP01IngressPodTemplate, fldPath *field.Path) field.ErrorList {
+	el := field.ErrorList{}
+
+	cpyPodTempl := podTempl.DeepCopy()
+	cpyPodTempl.Labels = nil
+	cpyPodTempl.Annotations = nil
+
+	if !reflect.DeepEqual(cpyPodTempl.ObjectMeta, metav1.ObjectMeta{}) {
+		el = append(el, field.Invalid(fldPath.Child("metadata"), "", "only labels and annotations may be set on podTemplate"))
+	}
+
 	return el
 }
 
diff --git a/pkg/apis/certmanager/validation/issuer_test.go b/pkg/apis/certmanager/validation/issuer_test.go
index a83840900..28163798e 100644
--- a/pkg/apis/certmanager/validation/issuer_test.go
+++ b/pkg/apis/certmanager/validation/issuer_test.go
@@ -21,6 +21,7 @@ import (
 	"testing"
 
 	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
@@ -199,6 +200,62 @@ func TestValidateACMEIssuerConfig(t *testing.T) {
 				field.Invalid(fldPath.Child("http01", "serviceType"), corev1.ServiceType("InvalidServiceType"), "optional field serviceType must be one of [\"ClusterIP\" \"NodePort\"]"),
 			},
 		},
+		"acme issue with valid pod template attributes": {
+			spec: &v1alpha1.ACMEIssuer{
+				Email:      "valid-email",
+				Server:     "valid-server",
+				PrivateKey: validSecretKeyRef,
+				Solvers: []v1alpha1.ACMEChallengeSolver{
+					{
+						HTTP01: &v1alpha1.ACMEChallengeSolverHTTP01{
+							Ingress: &v1alpha1.ACMEChallengeSolverHTTP01Ingress{
+								PodTemplate: &v1alpha1.ACMEChallengeSolverHTTP01IngressPodTemplate{
+									ObjectMeta: metav1.ObjectMeta{
+										Labels: map[string]string{
+											"valid_to_contain": "labels",
+										},
+										Annotations: map[string]string{
+											"valid_to_contain": "annotations",
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				HTTP01: &v1alpha1.ACMEIssuerHTTP01Config{
+					ServiceType: corev1.ServiceType("NodePort"),
+				},
+			},
+		},
+		"acme issue with invalid pod template ObjectMeta attributes": {
+			spec: &v1alpha1.ACMEIssuer{
+				Email:      "valid-email",
+				Server:     "valid-server",
+				PrivateKey: validSecretKeyRef,
+				Solvers: []v1alpha1.ACMEChallengeSolver{
+					{
+						HTTP01: &v1alpha1.ACMEChallengeSolverHTTP01{
+							Ingress: &v1alpha1.ACMEChallengeSolverHTTP01Ingress{
+								PodTemplate: &v1alpha1.ACMEChallengeSolverHTTP01IngressPodTemplate{
+									ObjectMeta: metav1.ObjectMeta{
+										Annotations: map[string]string{
+											"valid_to_contain": "annotations",
+										},
+										GenerateName: "unable-to-change-generateName",
+										Name:         "unable-to-change-name",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			errs: []*field.Error{
+				field.Invalid(fldPath.Child("solver", "http01", "ingress", "podTemplate", "metadata"),
+					"", "only labels and annotations may be set on podTemplate"),
+			},
+		},
 	}
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
diff --git a/pkg/controller/acmechallenges/BUILD.bazel b/pkg/controller/acmechallenges/BUILD.bazel
index 3010278a3..ed09b6ff4 100644
--- a/pkg/controller/acmechallenges/BUILD.bazel
+++ b/pkg/controller/acmechallenges/BUILD.bazel
@@ -22,6 +22,7 @@ go_library(
         "//pkg/issuer/acme/dns/util:go_default_library",
         "//pkg/issuer/acme/http:go_default_library",
         "//pkg/logs:go_default_library",
+        "//pkg/metrics:go_default_library",
         "//third_party/crypto/acme:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
diff --git a/pkg/controller/acmechallenges/sync.go b/pkg/controller/acmechallenges/sync.go
index 47c0c1dc5..c36bf8a90 100644
--- a/pkg/controller/acmechallenges/sync.go
+++ b/pkg/controller/acmechallenges/sync.go
@@ -33,6 +33,7 @@ import (
 	"github.com/jetstack/cert-manager/pkg/feature"
 	dnsutil "github.com/jetstack/cert-manager/pkg/issuer/acme/dns/util"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
+	"github.com/jetstack/cert-manager/pkg/metrics"
 	acmeapi "github.com/jetstack/cert-manager/third_party/crypto/acme"
 )
 
@@ -56,6 +57,8 @@ type solver interface {
 // Sync will process this ACME Challenge.
 // It is the core control function for ACME challenges.
 func (c *Controller) Sync(ctx context.Context, ch *cmapi.Challenge) (err error) {
+	metrics.Default.IncrementSyncCallCount(ControllerName)
+
 	log := logf.FromContext(ctx).WithValues("dnsName", ch.Spec.DNSName, "type", ch.Spec.Type)
 	ctx = logf.NewContext(ctx, log)
 	oldChal := ch
diff --git a/pkg/controller/acmeorders/BUILD.bazel b/pkg/controller/acmeorders/BUILD.bazel
index 0e29aebb4..7b00a4b91 100644
--- a/pkg/controller/acmeorders/BUILD.bazel
+++ b/pkg/controller/acmeorders/BUILD.bazel
@@ -17,6 +17,7 @@ go_library(
         "//pkg/controller:go_default_library",
         "//pkg/issuer:go_default_library",
         "//pkg/logs:go_default_library",
+        "//pkg/metrics:go_default_library",
         "//third_party/crypto/acme:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
diff --git a/pkg/controller/acmeorders/sync.go b/pkg/controller/acmeorders/sync.go
index 086834566..93f14ac1f 100644
--- a/pkg/controller/acmeorders/sync.go
+++ b/pkg/controller/acmeorders/sync.go
@@ -33,6 +33,7 @@ import (
 	"github.com/jetstack/cert-manager/pkg/acme"
 	acmecl "github.com/jetstack/cert-manager/pkg/acme/client"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
+	"github.com/jetstack/cert-manager/pkg/metrics"
 	acmeapi "github.com/jetstack/cert-manager/third_party/crypto/acme"
 	"k8s.io/klog"
 )
@@ -48,6 +49,8 @@ var (
 // - create a Challenge resource in order to fulfill required validations
 // - waiting for Challenge resources to enter the 'ready' state
 func (c *Controller) Sync(ctx context.Context, o *cmapi.Order) (err error) {
+	metrics.Default.IncrementSyncCallCount(ControllerName)
+
 	oldOrder := o
 	o = o.DeepCopy()
 
@@ -476,8 +479,9 @@ func determineSolverConfigToUse(candidates []cmapi.ACMEChallengeSolver, authz *a
 	var matchAll *cmapi.ACMEChallengeSolver
 	var matchAllToSolve *acmeapi.Challenge
 
-	for _, d := range candidates {
-		acmech := challengeForSolver(&d)
+	for idx := range candidates {
+		d := &candidates[idx]
+		acmech := challengeForSolver(d)
 		if acmech == nil {
 			continue
 		}
@@ -486,15 +490,16 @@ func determineSolverConfigToUse(candidates []cmapi.ACMEChallengeSolver, authz *a
 		if d.Selector == nil {
 			if matchAll == nil {
 				matchAllDomainsNumLabels = 0
-				matchAll = &d
+				matchAll = d
 				matchAllToSolve = acmech
 			}
 			continue
 		}
 		if len(d.Selector.DNSNames) == 0 {
 			if len(d.Selector.MatchLabels) > matchAllDomainsNumLabels || matchAll == nil {
-				matchAll = &d
+				matchAll = d
 				matchAllToSolve = acmech
+				matchAllDomainsNumLabels = len(d.Selector.MatchLabels)
 			}
 		}
 		for _, dom := range d.Selector.DNSNames {
@@ -502,8 +507,9 @@ func determineSolverConfigToUse(candidates []cmapi.ACMEChallengeSolver, authz *a
 				continue
 			}
 			if len(d.Selector.MatchLabels) > numLabelsSpecificMatch || specificMatch == nil {
-				specificMatch = &d
+				specificMatch = d
 				specificMatchToSolve = acmech
+				numLabelsSpecificMatch = len(d.Selector.MatchLabels)
 				break
 			}
 		}
diff --git a/pkg/controller/certificates/sync.go b/pkg/controller/certificates/sync.go
index a597e6e6d..ef12cd248 100644
--- a/pkg/controller/certificates/sync.go
+++ b/pkg/controller/certificates/sync.go
@@ -69,6 +69,8 @@ var (
 )
 
 func (c *Controller) Sync(ctx context.Context, crt *v1alpha1.Certificate) (err error) {
+	c.metrics.IncrementSyncCallCount(ControllerName)
+
 	log := logf.FromContext(ctx)
 	dbg := log.V(logf.DebugLevel)
 
diff --git a/pkg/controller/clusterissuers/BUILD.bazel b/pkg/controller/clusterissuers/BUILD.bazel
index 0f3817622..18f88b612 100644
--- a/pkg/controller/clusterissuers/BUILD.bazel
+++ b/pkg/controller/clusterissuers/BUILD.bazel
@@ -17,6 +17,7 @@ go_library(
         "//pkg/controller:go_default_library",
         "//pkg/issuer:go_default_library",
         "//pkg/logs:go_default_library",
+        "//pkg/metrics:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/labels:go_default_library",
diff --git a/pkg/controller/clusterissuers/sync.go b/pkg/controller/clusterissuers/sync.go
index ba0e014d8..99cc4a979 100644
--- a/pkg/controller/clusterissuers/sync.go
+++ b/pkg/controller/clusterissuers/sync.go
@@ -21,13 +21,14 @@ import (
 	"fmt"
 	"reflect"
 
-	"k8s.io/api/core/v1"
+	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/util/errors"
 
 	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/validation"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
+	"github.com/jetstack/cert-manager/pkg/metrics"
 )
 
 const (
@@ -38,6 +39,8 @@ const (
 )
 
 func (c *Controller) Sync(ctx context.Context, iss *v1alpha1.ClusterIssuer) (err error) {
+	metrics.Default.IncrementSyncCallCount(ControllerName)
+
 	log := logf.FromContext(ctx)
 
 	issuerCopy := iss.DeepCopy()
diff --git a/pkg/controller/helper_test.go b/pkg/controller/helper_test.go
index afe15248c..455113560 100644
--- a/pkg/controller/helper_test.go
+++ b/pkg/controller/helper_test.go
@@ -89,6 +89,15 @@ func TestCalculateDurationUntilRenew(t *testing.T) {
 			renewBefore:    &metav1.Duration{time.Hour * 24 * 40},
 			expectedExpiry: time.Hour * 24 * 35 * 2 / 3,
 		},
+		{
+			// the notBefore of an LE certificate is one hour before issuance
+			desc:           "expiry of let's encrypt certificate",
+			notBefore:      now().Add(-time.Hour),
+			notAfter:       now().Add(-time.Hour).Add(time.Hour * 24 * 90),
+			duration:       nil,
+			renewBefore:    &metav1.Duration{time.Hour*2159 + time.Minute*50},
+			expectedExpiry: -time.Minute * 50,
+		},
 	}
 	for k, v := range tests {
 		cert := &v1alpha1.Certificate{
diff --git a/pkg/controller/ingress-shim/BUILD.bazel b/pkg/controller/ingress-shim/BUILD.bazel
index ea7ab35cf..8efbdea94 100644
--- a/pkg/controller/ingress-shim/BUILD.bazel
+++ b/pkg/controller/ingress-shim/BUILD.bazel
@@ -15,6 +15,7 @@ go_library(
         "//pkg/client/listers/certmanager/v1alpha1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/issuer:go_default_library",
+        "//pkg/metrics:go_default_library",
         "//pkg/util:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/api/extensions/v1beta1:go_default_library",
@@ -42,6 +43,7 @@ go_test(
         "//vendor/k8s.io/api/extensions/v1beta1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/apis/meta/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/runtime:go_default_library",
+        "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
         "//vendor/k8s.io/client-go/testing:go_default_library",
     ],
 )
diff --git a/pkg/controller/ingress-shim/sync.go b/pkg/controller/ingress-shim/sync.go
index f1ec4f008..488c99efa 100644
--- a/pkg/controller/ingress-shim/sync.go
+++ b/pkg/controller/ingress-shim/sync.go
@@ -30,6 +30,7 @@ import (
 	"k8s.io/klog"
 
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
+	"github.com/jetstack/cert-manager/pkg/metrics"
 	"github.com/jetstack/cert-manager/pkg/util"
 )
 
@@ -60,6 +61,8 @@ const (
 var ingressGVK = extv1beta1.SchemeGroupVersion.WithKind("Ingress")
 
 func (c *Controller) Sync(ctx context.Context, ing *extv1beta1.Ingress) error {
+	metrics.Default.IncrementSyncCallCount(ControllerName)
+
 	if !shouldSync(ing, c.defaults.autoCertificateAnnotations) {
 		klog.Infof("Not syncing ingress %s/%s as it does not contain necessary annotations", ing.Namespace, ing.Name)
 		return nil
@@ -180,6 +183,16 @@ func (c *Controller) buildCertificates(ing *extv1beta1.Ingress, issuer v1alpha1.
 		if existingCrt != nil {
 			klog.Infof("Certificate %q for ingress %q already exists", tls.SecretName, ing.Name)
 
+			if metav1.GetControllerOf(existingCrt) == nil {
+				klog.Infof("Certificate %q has no owners and cannot be updated for ingress %q", tls.SecretName, ing.Name)
+				continue
+			}
+
+			if !metav1.IsControlledBy(existingCrt, ing) {
+				klog.Infof("Certificate %q is not (solely) owned by ingress %q and cannot be updated", tls.SecretName, ing.Name)
+				continue
+			}
+
 			if !certNeedsUpdate(existingCrt, crt) {
 				klog.Infof("Certificate %q for ingress %q is up to date", tls.SecretName, ing.Name)
 				continue
diff --git a/pkg/controller/ingress-shim/sync_test.go b/pkg/controller/ingress-shim/sync_test.go
index 1296682d1..e40ee9e20 100644
--- a/pkg/controller/ingress-shim/sync_test.go
+++ b/pkg/controller/ingress-shim/sync_test.go
@@ -24,6 +24,7 @@ import (
 	extv1beta1 "k8s.io/api/extensions/v1beta1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
+	types "k8s.io/apimachinery/pkg/types"
 	coretesting "k8s.io/client-go/testing"
 
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
@@ -126,6 +127,7 @@ func TestSync(t *testing.T) {
 						acmeIssuerChallengeTypeAnnotation: "http01",
 						editInPlaceAnnotation:             "true",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -145,7 +147,7 @@ func TestSync(t *testing.T) {
 						Labels: map[string]string{
 							"my-test-label": "should be copied",
 						},
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -181,6 +183,7 @@ func TestSync(t *testing.T) {
 						clusterIssuerNameAnnotation:       "issuer-name",
 						acmeIssuerChallengeTypeAnnotation: "http01",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -197,7 +200,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -232,6 +235,7 @@ func TestSync(t *testing.T) {
 						acmeIssuerChallengeTypeAnnotation: "http01",
 						ingressClassAnnotation:            "nginx-ing",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -248,7 +252,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -286,6 +290,7 @@ func TestSync(t *testing.T) {
 						acmeIssuerHTTP01IngressClassAnnotation: "cert-ing",
 						ingressClassAnnotation:                 "nginx-ing",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -302,7 +307,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -340,6 +345,7 @@ func TestSync(t *testing.T) {
 						ingressClassAnnotation:            "nginx-ing",
 						editInPlaceAnnotation:             "false",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -356,7 +362,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -393,6 +399,7 @@ func TestSync(t *testing.T) {
 						clusterIssuerNameAnnotation:       "issuer-name",
 						acmeIssuerChallengeTypeAnnotation: "dns01",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -417,6 +424,7 @@ func TestSync(t *testing.T) {
 						clusterIssuerNameAnnotation:       "issuer-name",
 						acmeIssuerChallengeTypeAnnotation: "invalid-challenge-type",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -442,6 +450,7 @@ func TestSync(t *testing.T) {
 						acmeIssuerChallengeTypeAnnotation:     "dns01",
 						acmeIssuerDNS01ProviderNameAnnotation: "fake-dns",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -458,7 +467,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -493,6 +502,7 @@ func TestSync(t *testing.T) {
 					Annotations: map[string]string{
 						clusterIssuerNameAnnotation: "issuer-name",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -509,7 +519,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -535,6 +545,7 @@ func TestSync(t *testing.T) {
 					Annotations: map[string]string{
 						testAcmeTLSAnnotation: "true",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -550,7 +561,7 @@ func TestSync(t *testing.T) {
 					ObjectMeta: metav1.ObjectMeta{
 						Name:            "example-com-tls",
 						Namespace:       gen.DefaultTestNamespace,
-						OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(buildIngress("ingress-name", gen.DefaultTestNamespace, nil), ingressGVK)},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com", "www.example.com"},
@@ -575,6 +586,7 @@ func TestSync(t *testing.T) {
 					Annotations: map[string]string{
 						issuerNameAnnotation: "issuer-name",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -596,6 +608,7 @@ func TestSync(t *testing.T) {
 					Annotations: map[string]string{
 						issuerNameAnnotation: "issuer-name",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -617,6 +630,7 @@ func TestSync(t *testing.T) {
 					Annotations: map[string]string{
 						issuerNameAnnotation: "invalid-issuer-name",
 					},
+					UID: types.UID("ingress-name"),
 				},
 			},
 		},
@@ -632,6 +646,7 @@ func TestSync(t *testing.T) {
 						issuerNameAnnotation:              "issuer-name",
 						acmeIssuerChallengeTypeAnnotation: "http01",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -645,8 +660,9 @@ func TestSync(t *testing.T) {
 			CertificateLister: []runtime.Object{
 				&v1alpha1.Certificate{
 					ObjectMeta: metav1.ObjectMeta{
-						Name:      "existing-crt",
-						Namespace: gen.DefaultTestNamespace,
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -683,6 +699,7 @@ func TestSync(t *testing.T) {
 						issuerNameAnnotation:              "issuer-name",
 						acmeIssuerChallengeTypeAnnotation: "http01",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -693,12 +710,19 @@ func TestSync(t *testing.T) {
 					},
 				},
 			},
-			CertificateLister: []runtime.Object{buildCertificate("existing-crt", gen.DefaultTestNamespace)},
+			CertificateLister: []runtime.Object{
+				buildCertificate("existing-crt",
+					gen.DefaultTestNamespace,
+					buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
+				),
+			},
+
 			ExpectedUpdate: []*v1alpha1.Certificate{
 				{
 					ObjectMeta: metav1.ObjectMeta{
-						Name:      "existing-crt",
-						Namespace: gen.DefaultTestNamespace,
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -736,6 +760,7 @@ func TestSync(t *testing.T) {
 						acmeIssuerChallengeTypeAnnotation: "http01",
 						ingressClassAnnotation:            "toot-ing",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -749,8 +774,9 @@ func TestSync(t *testing.T) {
 			CertificateLister: []runtime.Object{
 				&v1alpha1.Certificate{
 					ObjectMeta: metav1.ObjectMeta{
-						Name:      "existing-crt",
-						Namespace: gen.DefaultTestNamespace,
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -777,8 +803,9 @@ func TestSync(t *testing.T) {
 			ExpectedUpdate: []*v1alpha1.Certificate{
 				{
 					ObjectMeta: metav1.ObjectMeta{
-						Name:      "existing-crt",
-						Namespace: gen.DefaultTestNamespace,
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -817,6 +844,7 @@ func TestSync(t *testing.T) {
 						acmeIssuerChallengeTypeAnnotation: "http01",
 						ingressClassAnnotation:            "toot-ing",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -830,8 +858,9 @@ func TestSync(t *testing.T) {
 			CertificateLister: []runtime.Object{
 				&v1alpha1.Certificate{
 					ObjectMeta: metav1.ObjectMeta{
-						Name:      "existing-crt",
-						Namespace: gen.DefaultTestNamespace,
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -846,8 +875,9 @@ func TestSync(t *testing.T) {
 			ExpectedUpdate: []*v1alpha1.Certificate{
 				{
 					ObjectMeta: metav1.ObjectMeta{
-						Name:      "existing-crt",
-						Namespace: gen.DefaultTestNamespace,
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -887,6 +917,7 @@ func TestSync(t *testing.T) {
 					Annotations: map[string]string{
 						issuerNameAnnotation: "issuer-name",
 					},
+					UID: types.UID("ingress-name"),
 				},
 				Spec: extv1beta1.IngressSpec{
 					TLS: []extv1beta1.IngressTLS{
@@ -905,6 +936,7 @@ func TestSync(t *testing.T) {
 						Labels: map[string]string{
 							"a-different-value": "should be removed",
 						},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -924,6 +956,7 @@ func TestSync(t *testing.T) {
 						Labels: map[string]string{
 							"my-test-label": "should be copied",
 						},
+						OwnerReferences: buildOwnerReferences("ingress-name", gen.DefaultTestNamespace),
 					},
 					Spec: v1alpha1.CertificateSpec{
 						DNSNames:   []string{"example.com"},
@@ -936,6 +969,114 @@ func TestSync(t *testing.T) {
 				},
 			},
 		},
+		{
+			Name:         "should not update certificate if it does not belong to any ingress",
+			Issuer:       acmeIssuer,
+			IssuerLister: []runtime.Object{acmeIssuer},
+			Ingress: &extv1beta1.Ingress{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "ingress-name",
+					Namespace: gen.DefaultTestNamespace,
+					Annotations: map[string]string{
+						issuerNameAnnotation:              "issuer-name",
+						acmeIssuerChallengeTypeAnnotation: "http01",
+						ingressClassAnnotation:            "toot-ing",
+					},
+					UID: types.UID("ingress-name"),
+				},
+				Spec: extv1beta1.IngressSpec{
+					TLS: []extv1beta1.IngressTLS{
+						{
+							Hosts:      []string{"example.com"},
+							SecretName: "existing-crt",
+						},
+					},
+				},
+			},
+			CertificateLister: []runtime.Object{
+				&v1alpha1.Certificate{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: []metav1.OwnerReference{},
+					},
+					Spec: v1alpha1.CertificateSpec{
+						DNSNames:   []string{"example.com"},
+						SecretName: "existing-crt",
+						IssuerRef: v1alpha1.ObjectReference{
+							Name: "issuer-name",
+							Kind: "Issuer",
+						},
+						ACME: &v1alpha1.ACMECertificateConfig{
+							Config: []v1alpha1.DomainSolverConfig{
+								{
+									Domains: []string{"example.com"},
+									SolverConfig: v1alpha1.SolverConfig{
+										HTTP01: &v1alpha1.HTTP01SolverConfig{
+											Ingress: "",
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			Name:         "should not update certificate if it does not belong to the ingress",
+			Issuer:       acmeIssuer,
+			IssuerLister: []runtime.Object{acmeIssuer},
+			Ingress: &extv1beta1.Ingress{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "ingress-name",
+					Namespace: gen.DefaultTestNamespace,
+					Annotations: map[string]string{
+						issuerNameAnnotation:              "issuer-name",
+						acmeIssuerChallengeTypeAnnotation: "http01",
+						ingressClassAnnotation:            "toot-ing",
+					},
+					UID: types.UID("ingress-name"),
+				},
+				Spec: extv1beta1.IngressSpec{
+					TLS: []extv1beta1.IngressTLS{
+						{
+							Hosts:      []string{"example.com"},
+							SecretName: "existing-crt",
+						},
+					},
+				},
+			},
+			CertificateLister: []runtime.Object{
+				&v1alpha1.Certificate{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:            "existing-crt",
+						Namespace:       gen.DefaultTestNamespace,
+						OwnerReferences: buildOwnerReferences("not-ingress-name", gen.DefaultTestNamespace),
+					},
+					Spec: v1alpha1.CertificateSpec{
+						DNSNames:   []string{"example.com"},
+						SecretName: "existing-crt",
+						IssuerRef: v1alpha1.ObjectReference{
+							Name: "issuer-name",
+							Kind: "Issuer",
+						},
+						ACME: &v1alpha1.ACMECertificateConfig{
+							Config: []v1alpha1.DomainSolverConfig{
+								{
+									Domains: []string{"example.com"},
+									SolverConfig: v1alpha1.SolverConfig{
+										HTTP01: &v1alpha1.HTTP01SolverConfig{
+											Ingress: "",
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
 	}
 	testFn := func(test testT) func(t *testing.T) {
 		return func(t *testing.T) {
@@ -1067,11 +1208,12 @@ func TestIssuerForIngress(t *testing.T) {
 	}
 }
 
-func buildCertificate(name, namespace string) *v1alpha1.Certificate {
+func buildCertificate(name, namespace string, ownerReferences []metav1.OwnerReference) *v1alpha1.Certificate {
 	return &v1alpha1.Certificate{
 		ObjectMeta: metav1.ObjectMeta{
-			Name:      name,
-			Namespace: namespace,
+			Name:            name,
+			Namespace:       namespace,
+			OwnerReferences: ownerReferences,
 		},
 	}
 }
@@ -1096,6 +1238,13 @@ func buildIngress(name, namespace string, annotations map[string]string) *extv1b
 			Name:        name,
 			Namespace:   namespace,
 			Annotations: annotations,
+			UID:         types.UID(name),
 		},
 	}
 }
+
+func buildOwnerReferences(name, namespace string) []metav1.OwnerReference {
+	return []metav1.OwnerReference{
+		*metav1.NewControllerRef(buildIngress(name, namespace, nil), ingressGVK),
+	}
+}
diff --git a/pkg/controller/issuers/BUILD.bazel b/pkg/controller/issuers/BUILD.bazel
index 7bf87e7dd..db130d8e3 100644
--- a/pkg/controller/issuers/BUILD.bazel
+++ b/pkg/controller/issuers/BUILD.bazel
@@ -17,6 +17,7 @@ go_library(
         "//pkg/controller:go_default_library",
         "//pkg/issuer:go_default_library",
         "//pkg/logs:go_default_library",
+        "//pkg/metrics:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/errors:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/labels:go_default_library",
diff --git a/pkg/controller/issuers/sync.go b/pkg/controller/issuers/sync.go
index 266cc5461..8d19d760f 100644
--- a/pkg/controller/issuers/sync.go
+++ b/pkg/controller/issuers/sync.go
@@ -21,13 +21,14 @@ import (
 	"fmt"
 	"reflect"
 
-	"k8s.io/api/core/v1"
+	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/util/errors"
 
 	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/validation"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
+	"github.com/jetstack/cert-manager/pkg/metrics"
 )
 
 const (
@@ -38,6 +39,8 @@ const (
 )
 
 func (c *Controller) Sync(ctx context.Context, iss *v1alpha1.Issuer) (err error) {
+	metrics.Default.IncrementSyncCallCount(ControllerName)
+
 	log := logf.FromContext(ctx)
 
 	issuerCopy := iss.DeepCopy()
diff --git a/pkg/issuer/acme/dns/dns.go b/pkg/issuer/acme/dns/dns.go
index 97a4fa096..ef11ef74a 100644
--- a/pkg/issuer/acme/dns/dns.go
+++ b/pkg/issuer/acme/dns/dns.go
@@ -62,7 +62,7 @@ type dnsProviderConstructors struct {
 	cloudDNS     func(project string, serviceAccount []byte, dns01Nameservers []string, ambient bool) (*clouddns.DNSProvider, error)
 	cloudFlare   func(email, apikey string, dns01Nameservers []string) (*cloudflare.DNSProvider, error)
 	route53      func(accessKey, secretKey, hostedZoneID, region string, ambient bool, dns01Nameservers []string) (*route53.DNSProvider, error)
-	azureDNS     func(clientID, clientSecret, subscriptionID, tenentID, resourceGroupName, hostedZoneName string, dns01Nameservers []string) (*azuredns.DNSProvider, error)
+	azureDNS     func(clientID, clientSecret, subscriptionID, tenantID, resourceGroupName, hostedZoneName string, dns01Nameservers []string) (*azuredns.DNSProvider, error)
 	acmeDNS      func(host string, accountJson []byte, dns01Nameservers []string) (*acmedns.DNSProvider, error)
 	digitalOcean func(token string, dns01Nameservers []string) (*digitalocean.DNSProvider, error)
 }
diff --git a/pkg/issuer/acme/http/http.go b/pkg/issuer/acme/http/http.go
index dc3462aa6..a00add0aa 100644
--- a/pkg/issuer/acme/http/http.go
+++ b/pkg/issuer/acme/http/http.go
@@ -84,8 +84,9 @@ func http01LogCtx(ctx context.Context) context.Context {
 
 func httpDomainCfgForChallenge(issuer v1alpha1.GenericIssuer, ch *v1alpha1.Challenge) (*v1alpha1.ACMEChallengeSolverHTTP01Ingress, error) {
 	if ch.Spec.Solver != nil {
-		if ch.Spec.Solver.HTTP01 == nil {
-			return nil, fmt.Errorf("challenge's 'solver' field is specified but not HTTP01 ingress config provided")
+		if ch.Spec.Solver.HTTP01 == nil || ch.Spec.Solver.HTTP01.Ingress == nil {
+			return nil, fmt.Errorf("challenge's 'solver' field is specified but no HTTP01 ingress config provided. " +
+				"Ensure solvers[].http01.ingress is specified on your issuer resource")
 		}
 		return ch.Spec.Solver.HTTP01.Ingress, nil
 	}
diff --git a/pkg/issuer/acme/http/pod.go b/pkg/issuer/acme/http/pod.go
index 6563662f4..11bb0f6ab 100644
--- a/pkg/issuer/acme/http/pod.go
+++ b/pkg/issuer/acme/http/pod.go
@@ -68,6 +68,7 @@ func (s *Solver) ensurePod(ctx context.Context, ch *v1alpha1.Challenge) (*corev1
 	}
 
 	log.Info("creating HTTP01 challenge solver pod")
+
 	return s.createPod(ch)
 }
 
@@ -131,13 +132,29 @@ func (s *Solver) cleanupPods(ctx context.Context, ch *v1alpha1.Challenge) error
 // createPod will create a challenge solving pod for the given certificate,
 // domain, token and key.
 func (s *Solver) createPod(ch *v1alpha1.Challenge) (*corev1.Pod, error) {
-	return s.Client.CoreV1().Pods(ch.Namespace).Create(s.buildPod(ch))
+	return s.Client.CoreV1().Pods(ch.Namespace).Create(
+		s.buildPod(ch))
 }
 
 // buildPod will build a challenge solving pod for the given certificate,
 // domain, token and key. It will not create it in the API server
 func (s *Solver) buildPod(ch *v1alpha1.Challenge) *corev1.Pod {
+	pod := s.buildDefaultPod(ch)
+
+	// Override defaults if they have changed in the pod template.
+	if ch.Spec.Solver != nil &&
+		ch.Spec.Solver.HTTP01 != nil &&
+		ch.Spec.Solver.HTTP01.Ingress != nil {
+		pod = s.mergePodObjectMetaWithPodTemplate(pod,
+			ch.Spec.Solver.HTTP01.Ingress.PodTemplate)
+	}
+
+	return pod
+}
+
+func (s *Solver) buildDefaultPod(ch *v1alpha1.Challenge) *corev1.Pod {
 	podLabels := podLabels(ch)
+
 	return &corev1.Pod{
 		ObjectMeta: metav1.ObjectMeta{
 			GenerateName: "cm-acme-http-solver-",
@@ -184,3 +201,28 @@ func (s *Solver) buildPod(ch *v1alpha1.Challenge) *corev1.Pod {
 		},
 	}
 }
+
+// Merge object meta from the pod template. Fall back to default values.
+func (s *Solver) mergePodObjectMetaWithPodTemplate(pod *corev1.Pod, podTempl *v1alpha1.ACMEChallengeSolverHTTP01IngressPodTemplate) *corev1.Pod {
+	if podTempl == nil {
+		return pod
+	}
+
+	if pod.Labels == nil {
+		pod.Labels = make(map[string]string)
+	}
+
+	for k, v := range podTempl.Labels {
+		pod.Labels[k] = v
+	}
+
+	if pod.Annotations == nil {
+		pod.Annotations = make(map[string]string)
+	}
+
+	for k, v := range podTempl.Annotations {
+		pod.Annotations[k] = v
+	}
+
+	return pod
+}
diff --git a/pkg/issuer/acme/http/pod_test.go b/pkg/issuer/acme/http/pod_test.go
index e2ec7fde0..8aecc060c 100644
--- a/pkg/issuer/acme/http/pod_test.go
+++ b/pkg/issuer/acme/http/pod_test.go
@@ -22,6 +22,7 @@ import (
 	"testing"
 
 	"k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/labels"
 	"k8s.io/apimachinery/pkg/runtime"
 	coretesting "k8s.io/client-go/testing"
@@ -252,3 +253,128 @@ func TestGetPodsForCertificate(t *testing.T) {
 		})
 	}
 }
+
+func TestMergePodObjectMetaWithPodTemplate(t *testing.T) {
+	const createdPodKey = "createdPod"
+	tests := map[string]solverFixture{
+		"should use labels and annotations from template": {
+			Challenge: &v1alpha1.Challenge{
+				Spec: v1alpha1.ChallengeSpec{
+					DNSName: "example.com",
+					Config: &v1alpha1.SolverConfig{
+						HTTP01: &v1alpha1.HTTP01SolverConfig{},
+					},
+					Solver: &v1alpha1.ACMEChallengeSolver{
+						HTTP01: &v1alpha1.ACMEChallengeSolverHTTP01{
+							Ingress: &v1alpha1.ACMEChallengeSolverHTTP01Ingress{
+								PodTemplate: &v1alpha1.ACMEChallengeSolverHTTP01IngressPodTemplate{
+									ObjectMeta: metav1.ObjectMeta{
+										Labels: map[string]string{
+											"this is a":                           "label",
+											"certmanager.k8s.io/acme-http-domain": "44655555555",
+										},
+										Annotations: map[string]string{
+											"sidecar.istio.io/inject": "true",
+											"foo":                     "bar",
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			PreFn: func(t *testing.T, s *solverFixture) {
+				resultingPod := s.Solver.buildDefaultPod(s.Challenge)
+				resultingPod.Labels = map[string]string{
+					"this is a":                             "label",
+					"certmanager.k8s.io/acme-http-domain":   "44655555555",
+					"certmanager.k8s.io/acme-http-token":    "1",
+					"certmanager.k8s.io/acme-http01-solver": "true",
+				}
+				resultingPod.Annotations = map[string]string{
+					"sidecar.istio.io/inject": "true",
+					"foo":                     "bar",
+				}
+				s.testResources[createdPodKey] = resultingPod
+
+				s.Builder.Sync()
+			},
+			CheckFn: func(t *testing.T, s *solverFixture, args ...interface{}) {
+				resultingPod := s.testResources[createdPodKey].(*v1.Pod)
+
+				resp, ok := args[0].(*v1.Pod)
+				if !ok {
+					t.Errorf("expected pod to be returned, but got %v", args[0])
+					t.Fail()
+					return
+				}
+
+				// ignore pointer differences here
+				resultingPod.OwnerReferences = resp.OwnerReferences
+
+				if resp.String() != resultingPod.String() {
+					t.Errorf("unexpected pod generated from merge\nexp=%s\ngot=%s",
+						resultingPod, resp)
+					t.Fail()
+				}
+			},
+		},
+		"should use default if nothing has changed in template": {
+			Challenge: &v1alpha1.Challenge{
+				Spec: v1alpha1.ChallengeSpec{
+					DNSName: "example.com",
+					Config: &v1alpha1.SolverConfig{
+						HTTP01: &v1alpha1.HTTP01SolverConfig{},
+					},
+				},
+			},
+			PreFn: func(t *testing.T, s *solverFixture) {
+				resultingPod := s.Solver.buildDefaultPod(s.Challenge)
+				s.testResources[createdPodKey] = resultingPod
+
+				s.Builder.Sync()
+			},
+			CheckFn: func(t *testing.T, s *solverFixture, args ...interface{}) {
+				resultingPod := s.testResources[createdPodKey].(*v1.Pod)
+
+				resp, ok := args[0].(*v1.Pod)
+				if !ok {
+					t.Errorf("expected pod to be returned, but got %v", args[0])
+					t.Fail()
+					return
+				}
+
+				// Owner references need to be checked individually
+				if len(resultingPod.OwnerReferences) != len(resp.OwnerReferences) {
+					t.Errorf("mismatch owner references length, exp=%d got=%d",
+						len(resultingPod.OwnerReferences), len(resp.OwnerReferences))
+				} else {
+					for i := range resp.OwnerReferences {
+						if resp.OwnerReferences[i].String() !=
+							resultingPod.OwnerReferences[i].String() {
+							t.Errorf("unexpected pod owner references generated from merge\nexp=%s\ngot=%s",
+								resp.OwnerReferences[i].String(), resultingPod.OwnerReferences[i].String())
+						}
+					}
+				}
+
+				resp.OwnerReferences = resultingPod.OwnerReferences
+
+				if resp.String() != resultingPod.String() {
+					t.Errorf("unexpected pod generated from merge\nexp=%s\ngot=%s",
+						resultingPod, resp)
+					t.Fail()
+				}
+			},
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			test.Setup(t)
+			resp := test.Solver.buildPod(test.Challenge)
+			test.Finish(t, resp, nil)
+		})
+	}
+}
diff --git a/pkg/issuer/acme/issue.go b/pkg/issuer/acme/issue.go
index 90a9a6574..ccd30ede1 100644
--- a/pkg/issuer/acme/issue.go
+++ b/pkg/issuer/acme/issue.go
@@ -294,12 +294,12 @@ func (a *Acme) getCertificatePrivateKey(ctx context.Context, crt *v1alpha1.Certi
 	log.V(4).Info("Generating new private key")
 
 	// generate a new private key.
-	rsaKey, err := pki.GenerateRSAPrivateKey(2048)
+	privateKey, err := pki.GeneratePrivateKeyForCertificate(crt)
 	if err != nil {
 		return nil, false, err
 	}
 
-	return rsaKey, true, nil
+	return privateKey, true, nil
 }
 
 func (a *Acme) createNewOrder(ctx context.Context, crt *v1alpha1.Certificate, template *v1alpha1.Order, key crypto.Signer) error {
diff --git a/pkg/issuer/venafi/BUILD.bazel b/pkg/issuer/venafi/BUILD.bazel
index 85dcdaaca..094dc4905 100644
--- a/pkg/issuer/venafi/BUILD.bazel
+++ b/pkg/issuer/venafi/BUILD.bazel
@@ -14,6 +14,7 @@ go_library(
         "//pkg/apis/certmanager/v1alpha1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/issuer:go_default_library",
+        "//pkg/logs:go_default_library",
         "//pkg/util/pki:go_default_library",
         "//vendor/github.com/Venafi/vcert:go_default_library",
         "//vendor/github.com/Venafi/vcert/pkg/certificate:go_default_library",
diff --git a/pkg/issuer/venafi/connector_test.go b/pkg/issuer/venafi/connector_test.go
index e7cf00b44..7771cb8e8 100644
--- a/pkg/issuer/venafi/connector_test.go
+++ b/pkg/issuer/venafi/connector_test.go
@@ -26,9 +26,9 @@ type fakeConnector struct {
 	*fake.Connector
 
 	PingFunc                  func() error
-	ReadZoneConfigurationFunc func(string) (*endpoint.ZoneConfiguration, error)
+	ReadZoneConfigurationFunc func() (*endpoint.ZoneConfiguration, error)
 	RetrieveCertificateFunc   func(*certificate.Request) (*certificate.PEMCollection, error)
-	RequestCertificateFunc    func(*certificate.Request, string) (string, error)
+	RequestCertificateFunc    func(*certificate.Request) (string, error)
 	RenewCertificateFunc      func(*certificate.RenewalRequest) (string, error)
 }
 
@@ -46,11 +46,11 @@ func (f *fakeConnector) Ping() (err error) {
 	return f.Connector.Ping()
 }
 
-func (f *fakeConnector) ReadZoneConfiguration(zone string) (config *endpoint.ZoneConfiguration, err error) {
+func (f *fakeConnector) ReadZoneConfiguration() (config *endpoint.ZoneConfiguration, err error) {
 	if f.ReadZoneConfigurationFunc != nil {
-		return f.ReadZoneConfigurationFunc(zone)
+		return f.ReadZoneConfigurationFunc()
 	}
-	return f.Connector.ReadZoneConfiguration(zone)
+	return f.Connector.ReadZoneConfiguration()
 }
 
 func (f *fakeConnector) RetrieveCertificate(req *certificate.Request) (certificates *certificate.PEMCollection, err error) {
@@ -60,11 +60,11 @@ func (f *fakeConnector) RetrieveCertificate(req *certificate.Request) (certifica
 	return f.Connector.RetrieveCertificate(req)
 }
 
-func (f *fakeConnector) RequestCertificate(req *certificate.Request, zone string) (requestID string, err error) {
+func (f *fakeConnector) RequestCertificate(req *certificate.Request) (requestID string, err error) {
 	if f.RequestCertificateFunc != nil {
-		return f.RequestCertificateFunc(req, zone)
+		return f.RequestCertificateFunc(req)
 	}
-	return f.Connector.RequestCertificate(req, zone)
+	return f.Connector.RequestCertificate(req)
 }
 
 func (f *fakeConnector) RenewCertificate(req *certificate.RenewalRequest) (requestID string, err error) {
diff --git a/pkg/issuer/venafi/issue.go b/pkg/issuer/venafi/issue.go
index a05fb04ec..61aa39928 100644
--- a/pkg/issuer/venafi/issue.go
+++ b/pkg/issuer/venafi/issue.go
@@ -19,7 +19,6 @@ package venafi
 import (
 	"context"
 	"crypto/x509"
-	"encoding/pem"
 	"fmt"
 	"strings"
 	"time"
@@ -31,6 +30,7 @@ import (
 
 	"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1alpha1"
 	"github.com/jetstack/cert-manager/pkg/issuer"
+	logf "github.com/jetstack/cert-manager/pkg/logs"
 	"github.com/jetstack/cert-manager/pkg/util/pki"
 )
 
@@ -50,22 +50,32 @@ const (
 // - Submit the request
 // - Wait for the request to be fulfilled and the certificate to be available
 func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.IssueResponse, error) {
+	log := logf.FromContext(ctx, "venafi")
+	log = logf.WithResource(log, crt)
+	log = log.WithValues(logf.RelatedResourceNameKey, crt.Spec.SecretName, logf.RelatedResourceKindKey, "Secret")
+	dbg := log.V(logf.DebugLevel)
+
+	dbg.Info("issue method called")
 	v.Recorder.Event(crt, corev1.EventTypeNormal, "Issuing", "Requesting new certificate...")
 
 	// Always generate a new private key, as some Venafi configurations mandate
 	// unique private keys per issuance.
+	dbg.Info("generating new private key for certificate")
 	signeeKey, err := pki.GeneratePrivateKeyForCertificate(crt)
 	if err != nil {
-		klog.Errorf("Error generating private key %q for certificate: %v", crt.Spec.SecretName, err)
+		log.Error(err, "failed to generate private key for certificate")
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "PrivateKeyError", "Error generating certificate private key: %v", err)
 		// don't trigger a retry. An error from this function implies some
 		// invalid input parameters, and retrying without updating the
 		// resource will not help.
 		return nil, nil
 	}
+
+	dbg.Info("generated new private key")
 	v.Recorder.Event(crt, corev1.EventTypeNormal, "GenerateKey", "Generated new private key")
 
 	// extract the public component of the key
+	dbg.Info("extracting public key from private key")
 	signeePublicKey, err := pki.PublicKeyForPrivateKey(signeeKey)
 	if err != nil {
 		klog.Errorf("Error getting public key from private key: %v", err)
@@ -74,6 +84,7 @@ func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.
 
 	// We build a x509.Certificate as the vcert library has support for converting
 	// this into its own internal Certificate Request type.
+	dbg.Info("constructing certificate request template to submit to venafi")
 	tmpl, err := pki.GenerateTemplate(crt)
 	if err != nil {
 		return nil, err
@@ -94,8 +105,8 @@ func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.
 	// Retrieve a copy of the Venafi zone.
 	// This contains default values and policy control info that we can apply
 	// and check against locally.
-	zoneName := v.issuer.GetSpec().Venafi.Zone
-	zoneCfg, err := v.client.ReadZoneConfiguration(zoneName)
+	dbg.Info("reading venafi zone configuration")
+	zoneCfg, err := v.client.ReadZoneConfiguration()
 	if err != nil {
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "ReadZone", "Failed to read Venafi zone configuration: %v", err)
 		return nil, err
@@ -105,9 +116,13 @@ func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.
 
 	// Create a vcert Request structure
 	vreq := newVRequest(tmpl)
+	vreq.PrivateKey = signeeKey
 
 	// Apply default values from the Venafi zone
+	dbg.Info("applying default venafi zone values to request")
 	zoneCfg.UpdateCertificateRequest(vreq)
+
+	dbg.Info("validating venafi certificate request")
 	err = zoneCfg.ValidateCertificateRequest(vreq)
 	if err != nil {
 		// TODO: set a certificate status condition instead of firing an event
@@ -115,22 +130,17 @@ func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "Validate", "Failed to validate certificate against Venafi zone: %v", err)
 		return nil, err
 	}
+	dbg.Info("validated venafi certificate request")
 	v.Recorder.Eventf(crt, corev1.EventTypeNormal, "Validate", "Validated certificate request against Venafi zone policy")
 
 	// Generate the actual x509 CSR and set it on the vreq
-	err = certificate.GenerateRequest(vreq, signeeKey)
+	dbg.Info("generating CSR to submit to venafi")
+	err = vreq.GenerateCSR()
 	if err != nil {
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "GenerateCSR", "Failed to generate a CSR for the certificate: %v", err)
 		return nil, err
 	}
 
-	// certificate.GenerateRequest above sets the CSR field as der encoded bytes
-	// however, the library actually requires this field to be PEM encoded.
-	// We decode the DER bytes and run them through the PEM encoder and re-set the
-	// field before actually calling RequestCertificate.
-	// TODO: make this weird behaviour go away
-	vreq.CSR = pem.EncodeToMemory(certificate.GetCertificateRequestPEMBlock(vreq.CSR))
-
 	// We mark the request as having a user provided CSR, as we have manually
 	// generated it in the lines above.
 	// Setting this will prevent a new private key being generated by vcert.
@@ -140,12 +150,14 @@ func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.
 
 	v.Recorder.Eventf(crt, corev1.EventTypeNormal, "Requesting", "Requesting certificate from Venafi server...")
 	// Actually send a request to the Venafi server for a certificate.
-	requestID, err := v.client.RequestCertificate(vreq, zoneName)
+	dbg.Info("submitting generated CSR to venafi")
+	requestID, err := v.client.RequestCertificate(vreq)
 	if err != nil {
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "Request", "Failed to request a certificate from Venafi: %v", err)
 		return nil, err
 	}
 
+	dbg.Info("successfully submitted request. attempting to pickup certificate from venafi server...")
 	// Set the PickupID so vcert does not have to look it up by the fingerprint
 	vreq.PickupID = requestID
 
@@ -158,25 +170,31 @@ func (v *Venafi) Issue(ctx context.Context, crt *v1alpha1.Certificate) (*issuer.
 
 	// Check some known error types
 	if err, ok := err.(endpoint.ErrCertificatePending); ok {
+		log.Error(err, "venafi certificate still in a pending state, the request will be retried")
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "Retrieve", "Failed to retrieve a certificate from Venafi, still pending: %v", err)
 		return nil, fmt.Errorf("Venafi certificate still pending: %v", err)
 	}
 	if err, ok := err.(endpoint.ErrRetrieveCertificateTimeout); ok {
+		log.Error(err, "timed out waiting for venafi certificate, the request will be retried")
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "Retrieve", "Failed to retrieve a certificate from Venafi, timed out: %v", err)
 		return nil, fmt.Errorf("Timed out waiting for certificate: %v", err)
 	}
 	if err != nil {
+		log.Error(err, "failed to obtain venafi certificate")
 		v.Recorder.Eventf(crt, corev1.EventTypeWarning, "Retrieve", "Failed to retrieve a certificate from Venafi: %v", err)
 		return nil, err
 	}
+	log.Info("successfully fetched signed certificate from venafi")
 	v.Recorder.Eventf(crt, corev1.EventTypeNormal, "Retrieve", "Retrieved certificate from Venafi server")
 
 	// Encode the private key ready to be saved
+	dbg.Info("encoding generated private key")
 	pk, err := pki.EncodePrivateKey(signeeKey)
 	if err != nil {
 		return nil, err
 	}
 
+	dbg.Info("constructing certificate chain PEM and returning data")
 	// Construct the certificate chain and return the new keypair
 	cs := append([]string{pemCollection.Certificate}, pemCollection.Chain...)
 	chain := strings.Join(cs, "\n")
diff --git a/pkg/issuer/venafi/issue_test.go b/pkg/issuer/venafi/issue_test.go
index af29fbd3a..6ea313260 100644
--- a/pkg/issuer/venafi/issue_test.go
+++ b/pkg/issuer/venafi/issue_test.go
@@ -35,6 +35,11 @@ func checkCertificateIssued(t *testing.T, s *fixture, args ...interface{}) {
 	returnedCert := args[0].(*cmapi.Certificate)
 	resp := args[1].(*issuer.IssueResponse)
 
+	if resp == nil {
+		t.Errorf("expected IssueResponse to be non-nil")
+		t.FailNow()
+		return
+	}
 	if err, ok := args[2].(error); ok && err != nil {
 		t.Errorf("expected no error to be returned, but got: %v", err)
 		return
@@ -87,10 +92,9 @@ func TestIssue(t *testing.T) {
 				gen.SetCertificateDNSNames("example.com"),
 			),
 			Client: fakeConnector{
-				ReadZoneConfigurationFunc: func(zone string) (*endpoint.ZoneConfiguration, error) {
+				ReadZoneConfigurationFunc: func() (*endpoint.ZoneConfiguration, error) {
 					return &endpoint.ZoneConfiguration{
-						Organization:       "testing-org",
-						OrganizationLocked: true,
+						Organization: "testing-org",
 					}, nil
 				},
 			}.Default(),
@@ -112,10 +116,9 @@ func TestIssue(t *testing.T) {
 				gen.SetCertificateDNSNames("example.com"),
 			),
 			Client: fakeConnector{
-				ReadZoneConfigurationFunc: func(zone string) (*endpoint.ZoneConfiguration, error) {
+				ReadZoneConfigurationFunc: func() (*endpoint.ZoneConfiguration, error) {
 					return &endpoint.ZoneConfiguration{
-						Organization:       "testing-org",
-						OrganizationLocked: false,
+						Organization: "testing-org",
 					}, nil
 				},
 			}.Default(),
diff --git a/pkg/issuer/venafi/venafi.go b/pkg/issuer/venafi/venafi.go
index c8a444efc..5a7f516e0 100644
--- a/pkg/issuer/venafi/venafi.go
+++ b/pkg/issuer/venafi/venafi.go
@@ -56,8 +56,8 @@ type Venafi struct {
 // out its functionality during tests easier.
 type connector interface {
 	Ping() (err error)
-	ReadZoneConfiguration(zone string) (config *endpoint.ZoneConfiguration, err error)
-	RequestCertificate(req *certificate.Request, zone string) (requestID string, err error)
+	ReadZoneConfiguration() (config *endpoint.ZoneConfiguration, err error)
+	RequestCertificate(req *certificate.Request) (requestID string, err error)
 	RetrieveCertificate(req *certificate.Request) (certificates *certificate.PEMCollection, err error)
 	RenewCertificate(req *certificate.RenewalRequest) (requestID string, err error)
 }
diff --git a/pkg/metrics/metrics.go b/pkg/metrics/metrics.go
index d585efb4c..ee5d9e3c8 100644
--- a/pkg/metrics/metrics.go
+++ b/pkg/metrics/metrics.go
@@ -84,6 +84,15 @@ var ACMEClientRequestDurationSeconds = prometheus.NewSummaryVec(
 	[]string{"scheme", "host", "path", "method", "status"},
 )
 
+var ControllerSyncCallCount = prometheus.NewCounterVec(
+	prometheus.CounterOpts{
+		Namespace: namespace,
+		Name:      "controller_sync_call_count",
+		Help:      "The number of sync() calls made by a controller.",
+	},
+	[]string{"controller"},
+)
+
 type Metrics struct {
 	ctx context.Context
 	http.Server
@@ -93,6 +102,7 @@ type Metrics struct {
 	CertificateExpiryTimeSeconds     *prometheus.GaugeVec
 	ACMEClientRequestDurationSeconds *prometheus.SummaryVec
 	ACMEClientRequestCount           *prometheus.CounterVec
+	ControllerSyncCallCount          *prometheus.CounterVec
 }
 
 func New(ctx context.Context) *Metrics {
@@ -112,6 +122,7 @@ func New(ctx context.Context) *Metrics {
 		CertificateExpiryTimeSeconds:     CertificateExpiryTimeSeconds,
 		ACMEClientRequestDurationSeconds: ACMEClientRequestDurationSeconds,
 		ACMEClientRequestCount:           ACMEClientRequestCount,
+		ControllerSyncCallCount:          ControllerSyncCallCount,
 	}
 
 	router.Handle("/metrics", promhttp.HandlerFor(s.registry, promhttp.HandlerOpts{}))
@@ -141,6 +152,7 @@ func (m *Metrics) Start(stopCh <-chan struct{}) {
 	m.registry.MustRegister(m.CertificateExpiryTimeSeconds)
 	m.registry.MustRegister(m.ACMEClientRequestDurationSeconds)
 	m.registry.MustRegister(m.ACMEClientRequestCount)
+	m.registry.MustRegister(m.ControllerSyncCallCount)
 
 	go func() {
 		log := log.WithValues("address", m.Addr)
@@ -183,3 +195,9 @@ func updateX509Expiry(name, namespace string, cert *x509.Certificate) {
 		"name":      name,
 		"namespace": namespace}).Set(float64(expiryTime.Unix()))
 }
+
+func (m *Metrics) IncrementSyncCallCount(controllerName string) {
+	log := logf.FromContext(m.ctx)
+	log.V(logf.DebugLevel).Info("incrementing controller sync call count", "controllerName", controllerName)
+	ControllerSyncCallCount.WithLabelValues(controllerName).Inc()
+}
diff --git a/test/e2e/charts/pebble/BUILD.bazel b/test/e2e/charts/pebble/BUILD.bazel
index 659a93149..14de7a56b 100644
--- a/test/e2e/charts/pebble/BUILD.bazel
+++ b/test/e2e/charts/pebble/BUILD.bazel
@@ -2,7 +2,7 @@ load("@io_bazel_rules_docker//go:image.bzl", "go_image")
 
 go_image(
     name = "image",
-    base = "@alpine_linux-amd64//image",
+    base = "@static_base//image",
     embed = ["@org_letsencrypt_pebble//cmd/pebble:go_default_library"],
     goarch = "amd64",
     goos = "linux",
diff --git a/test/e2e/charts/pebble/templates/deployment.yaml b/test/e2e/charts/pebble/templates/deployment.yaml
index 01b51ed24..6297440a8 100644
--- a/test/e2e/charts/pebble/templates/deployment.yaml
+++ b/test/e2e/charts/pebble/templates/deployment.yaml
@@ -21,6 +21,7 @@ spec:
           imagePullPolicy: {{ .Values.image.pullPolicy }}
           args:
           - -config=/config/config.json
+          - -strict={{ .Values.strict }}
           volumeMounts:
           - name: config
             mountPath: /config
diff --git a/test/e2e/charts/pebble/values.yaml b/test/e2e/charts/pebble/values.yaml
index 088beac49..9c7e591da 100644
--- a/test/e2e/charts/pebble/values.yaml
+++ b/test/e2e/charts/pebble/values.yaml
@@ -11,4 +11,6 @@ resources:
     memory: 10Mi
   limits:
     cpu: 100m
-    memory: 100Mi
\ No newline at end of file
+    memory: 100Mi
+
+strict: "false"
diff --git a/test/e2e/framework/addon/pebble/pebble.go b/test/e2e/framework/addon/pebble/pebble.go
index 7f384844a..27a59463a 100644
--- a/test/e2e/framework/addon/pebble/pebble.go
+++ b/test/e2e/framework/addon/pebble/pebble.go
@@ -69,6 +69,12 @@ func (p *Pebble) Setup(cfg *config.Config) error {
 		ReleaseName: "chart-pebble-" + p.Name,
 		Namespace:   p.Namespace,
 		ChartName:   cfg.RepoRoot + "/test/e2e/charts/pebble",
+		Vars: []chart.StringTuple{
+			{
+				Key:   "strict",
+				Value: fmt.Sprintf("%t", cfg.Addons.Pebble.Strict),
+			},
+		},
 		// doesn't matter when installing from disk
 		ChartVersion: "0",
 	}
diff --git a/test/e2e/framework/addon/samplewebhook/sample/BUILD.bazel b/test/e2e/framework/addon/samplewebhook/sample/BUILD.bazel
index b25e4df5e..28ff4a78c 100644
--- a/test/e2e/framework/addon/samplewebhook/sample/BUILD.bazel
+++ b/test/e2e/framework/addon/samplewebhook/sample/BUILD.bazel
@@ -3,7 +3,7 @@ load("@io_bazel_rules_docker//go:image.bzl", "go_image")
 
 go_image(
     name = "image",
-    base = "@alpine_linux-amd64//image",
+    base = "@static_base//image",
     embed = [":go_default_library"],
     goarch = "amd64",
     goos = "linux",
diff --git a/test/e2e/framework/cleanup.go b/test/e2e/framework/cleanup.go
index 2d6d0f50a..b3063ba43 100644
--- a/test/e2e/framework/cleanup.go
+++ b/test/e2e/framework/cleanup.go
@@ -1,5 +1,7 @@
+// +skip_license_check
+
 /*
-Copyright 2019 The Jetstack cert-manager contributors.
+Copyright 2016 The Kubernetes Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
diff --git a/test/e2e/framework/config/pebble.go b/test/e2e/framework/config/pebble.go
index 4a50f6251..c7b237441 100644
--- a/test/e2e/framework/config/pebble.go
+++ b/test/e2e/framework/config/pebble.go
@@ -28,9 +28,13 @@ type Pebble struct {
 
 	// // ImageTag for Pebble
 	// ImageTag string
+
+	// Strict enables Pebble's 'strict mode'
+	Strict bool
 }
 
 func (p *Pebble) AddFlags(fs *flag.FlagSet) {
+	fs.BoolVar(&p.Strict, "pebble-strict", true, "If true, tests using Pebble will have strict mode enabled")
 	// fs.StringVar(&p.ImageRepo, "pebble-image-repo", "", "The container image repository for pebble to use in e2e tests")
 	// fs.StringVar(&p.ImageTag, "pebble-image-tag", "", "The container image tag for pebble to use in e2e tests")
 }
diff --git a/test/e2e/suite/issuers/acme/certificate/BUILD.bazel b/test/e2e/suite/issuers/acme/certificate/BUILD.bazel
index e97ce1757..6b28ab590 100644
--- a/test/e2e/suite/issuers/acme/certificate/BUILD.bazel
+++ b/test/e2e/suite/issuers/acme/certificate/BUILD.bazel
@@ -24,6 +24,7 @@ go_library(
         "//test/e2e/framework/matcher:go_default_library",
         "//test/e2e/suite/issuers/acme/dnsproviders:go_default_library",
         "//test/e2e/util:go_default_library",
+        "//test/unit/gen:go_default_library",
         "//test/util/generate:go_default_library",
         "//vendor/github.com/onsi/ginkgo:go_default_library",
         "//vendor/github.com/onsi/gomega:go_default_library",
diff --git a/test/e2e/suite/issuers/acme/certificate/http01_new.go b/test/e2e/suite/issuers/acme/certificate/http01_new.go
index 6d63d6d50..4b030ad5b 100644
--- a/test/e2e/suite/issuers/acme/certificate/http01_new.go
+++ b/test/e2e/suite/issuers/acme/certificate/http01_new.go
@@ -38,6 +38,7 @@ import (
 	"github.com/jetstack/cert-manager/test/e2e/framework/log"
 	. "github.com/jetstack/cert-manager/test/e2e/framework/matcher"
 	"github.com/jetstack/cert-manager/test/e2e/util"
+	"github.com/jetstack/cert-manager/test/unit/gen"
 	"github.com/jetstack/cert-manager/test/util/generate"
 )
 
@@ -158,6 +159,26 @@ var _ = framework.CertManagerDescribe("ACME Certificate (HTTP01)", func() {
 		Expect(err).NotTo(HaveOccurred())
 	})
 
+	It("should obtain a signed ecdsa certificate with a single CN from the ACME server", func() {
+		certClient := f.CertManagerClientSet.CertmanagerV1alpha1().Certificates(f.Namespace.Name)
+
+		By("Creating a Certificate")
+		cert := gen.Certificate(certificateName,
+			gen.SetCertificateSecretName(certificateSecretName),
+			gen.SetCertificateIssuer(v1alpha1.ObjectReference{
+				Name: issuerName,
+			}),
+			gen.SetCertificateDNSNames(acmeIngressDomain),
+			gen.SetCertificateKeyAlgorithm(v1alpha1.ECDSAKeyAlgorithm),
+		)
+		cert.Namespace = f.Namespace.Name
+		_, err := certClient.Create(cert)
+		Expect(err).NotTo(HaveOccurred())
+		By("Verifying the Certificate is valid and of type ECDSA")
+		err = h.WaitCertificateIssuedValid(f.Namespace.Name, certificateName, time.Minute*5)
+		Expect(err).NotTo(HaveOccurred())
+	})
+
 	It("should obtain a signed certificate for a long domain using http01 validation", func() {
 		certClient := f.CertManagerClientSet.CertmanagerV1alpha1().Certificates(f.Namespace.Name)
 
diff --git a/third_party/crypto/acme/acme.go b/third_party/crypto/acme/acme.go
index 86f1009c0..34d51cf1d 100644
--- a/third_party/crypto/acme/acme.go
+++ b/third_party/crypto/acme/acme.go
@@ -255,7 +255,11 @@ func (c *Client) FinalizeOrder(ctx context.Context, finalizeURL string, csr []by
 // If a caller needs to poll an order until its status is final,
 // see the WaitOrder method.
 func (c *Client) GetOrder(ctx context.Context, url string) (*Order, error) {
-	res, err := c.get(ctx, url)
+	if _, err := c.Discover(ctx); err != nil {
+		return nil, err
+	}
+
+	res, err := c.postWithJWSAccount(ctx, url, nil)
 	if err != nil {
 		return nil, err
 	}
@@ -373,7 +377,11 @@ func (c *Client) UpdateAccount(ctx context.Context, a *Account) (*Account, error
 // If a caller needs to poll an authorization until its status is final,
 // see the WaitAuthorization method.
 func (c *Client) GetAuthorization(ctx context.Context, url string) (*Authorization, error) {
-	res, err := c.get(ctx, url)
+	if _, err := c.Discover(ctx); err != nil {
+		return nil, err
+	}
+
+	res, err := c.postWithJWSAccount(ctx, url, nil)
 	if err != nil {
 		return nil, err
 	}
@@ -397,6 +405,10 @@ func (c *Client) GetAuthorization(ctx context.Context, url string) (*Authorizati
 //
 // It does not revoke existing certificates.
 func (c *Client) DeactivateAuthorization(ctx context.Context, url string) error {
+	if _, err := c.Discover(ctx); err != nil {
+		return err
+	}
+
 	res, err := c.postWithJWSAccount(ctx, url, json.RawMessage(`{"status":"deactivated"}`))
 	if err != nil {
 		return err
@@ -417,9 +429,13 @@ func (c *Client) DeactivateAuthorization(ctx context.Context, url string) error
 // If the Status is StatusInvalid, StatusDeactivated, or StatusRevoked the
 // returned error will be of type AuthorizationError.
 func (c *Client) WaitAuthorization(ctx context.Context, url string) (*Authorization, error) {
+	if _, err := c.Discover(ctx); err != nil {
+		return nil, err
+	}
+
 	sleep := sleeper(ctx)
 	for {
-		res, err := c.get(ctx, url)
+		res, err := c.postWithJWSAccount(ctx, url, nil)
 		if err != nil {
 			return nil, err
 		}
@@ -463,7 +479,11 @@ func (c *Client) WaitAuthorization(ctx context.Context, url string) (*Authorizat
 //
 // A client typically polls a challenge status using this method.
 func (c *Client) GetChallenge(ctx context.Context, url string) (*Challenge, error) {
-	res, err := c.get(ctx, url)
+	if _, err := c.Discover(ctx); err != nil {
+		return nil, err
+	}
+
+	res, err := c.postWithJWSAccount(ctx, url, nil)
 	if err != nil {
 		return nil, err
 	}
@@ -488,15 +508,7 @@ func (c *Client) AcceptChallenge(ctx context.Context, chal *Challenge) (*Challen
 		return nil, err
 	}
 
-	auth, err := keyAuth(c.Key.Public(), chal.Token)
-	if err != nil {
-		return nil, err
-	}
-
-	req := struct {
-		Auth string `json:"keyAuthorization"`
-	}{auth}
-	res, err := c.postWithJWSAccount(ctx, chal.URL, req)
+	res, err := c.postWithJWSAccount(ctx, chal.URL, json.RawMessage(`{}`))
 	if err != nil {
 		return nil, err
 	}
@@ -819,7 +831,11 @@ func nonceFromHeader(h http.Header) string {
 }
 
 func (c *Client) GetCertificate(ctx context.Context, url string) ([][]byte, error) {
-	res, err := c.get(ctx, url)
+	if _, err := c.Discover(ctx); err != nil {
+		return nil, err
+	}
+
+	res, err := c.postWithJWSAccount(ctx, url, nil)
 	if err != nil {
 		return nil, err
 	}
diff --git a/third_party/crypto/acme/acme_test.go b/third_party/crypto/acme/acme_test.go
index 59f369cf2..0877b1d11 100644
--- a/third_party/crypto/acme/acme_test.go
+++ b/third_party/crypto/acme/acme_test.go
@@ -327,7 +327,11 @@ func TestCreateOrder(t *testing.T) {
 
 func TestGetAuthorization(t *testing.T) {
 	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		if r.Method != "GET" {
+		if r.Method == "HEAD" {
+			w.Header().Set("Replay-Nonce", "test-nonce")
+			return
+		}
+		if r.Method != "POST" {
 			t.Errorf("r.Method = %q; want GET", r.Method)
 		}
 
@@ -353,7 +357,7 @@ func TestGetAuthorization(t *testing.T) {
 	}))
 	defer ts.Close()
 
-	cl := Client{Key: testKeyEC, dir: &Directory{NewNonceURL: ts.URL}}
+	cl := &Client{Key: testKeyEC, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 	auth, err := cl.GetAuthorization(context.Background(), ts.URL)
 	if err != nil {
 		t.Fatal(err)
@@ -399,6 +403,10 @@ func TestGetAuthorization(t *testing.T) {
 func TestWaitAuthorization(t *testing.T) {
 	var count int
 	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		if r.Method == "HEAD" {
+			w.Header().Set("Replay-Nonce", "test-nonce")
+			return
+		}
 		count++
 		w.Header().Set("Retry-After", "0")
 		if count > 1 {
@@ -416,7 +424,7 @@ func TestWaitAuthorization(t *testing.T) {
 	done := make(chan res)
 	defer close(done)
 	go func() {
-		var client Client
+		client := &Client{Key: testKey, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 		a, err := client.WaitAuthorization(context.Background(), ts.URL)
 		done <- res{a, err}
 	}()
@@ -436,6 +444,10 @@ func TestWaitAuthorization(t *testing.T) {
 
 func TestWaitAuthorizationInvalid(t *testing.T) {
 	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		if r.Method == "HEAD" {
+			w.Header().Set("Replay-Nonce", "nonce")
+			return
+		}
 		fmt.Fprintf(w, `{"status":"invalid"}`)
 	}))
 	defer ts.Close()
@@ -443,7 +455,7 @@ func TestWaitAuthorizationInvalid(t *testing.T) {
 	res := make(chan error)
 	defer close(res)
 	go func() {
-		var client Client
+		client := &Client{Key: testKey, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 		_, err := client.WaitAuthorization(context.Background(), ts.URL)
 		res <- err
 	}()
@@ -456,7 +468,7 @@ func TestWaitAuthorizationInvalid(t *testing.T) {
 			t.Error("err is nil")
 		}
 		if _, ok := err.(AuthorizationError); !ok {
-			t.Errorf("err is %T; want *AuthorizationError", err)
+			t.Errorf("err is %T; want *AuthorizationError: %v", err, err)
 		}
 	}
 }
@@ -470,7 +482,7 @@ func TestWaitAuthorizationClientError(t *testing.T) {
 
 	ch := make(chan error, 1)
 	go func() {
-		var client Client
+		client := &Client{Key: testKey, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 		_, err := client.WaitAuthorization(context.Background(), ts.URL)
 		ch <- err
 	}()
@@ -499,7 +511,7 @@ func TestWaitAuthorizationCancel(t *testing.T) {
 	res := make(chan error)
 	defer close(res)
 	go func() {
-		var client Client
+		client := &Client{Key: testKey, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 		ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
 		defer cancel()
 		_, err := client.WaitAuthorization(ctx, ts.URL)
@@ -551,7 +563,11 @@ func TestDeactivateAuthorization(t *testing.T) {
 
 func TestGetChallenge(t *testing.T) {
 	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		if r.Method != "GET" {
+		if r.Method == "HEAD" {
+			w.Header().Set("Replay-Nonce", "test-nonce")
+			return
+		}
+		if r.Method != "POST" {
 			t.Errorf("r.Method = %q; want GET", r.Method)
 		}
 
@@ -579,7 +595,7 @@ func TestGetChallenge(t *testing.T) {
 	}))
 	defer ts.Close()
 
-	cl := Client{Key: testKeyEC}
+	cl := &Client{Key: testKeyEC, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 	chall, err := cl.GetChallenge(context.Background(), ts.URL)
 	if err != nil {
 		t.Fatal(err)
@@ -636,16 +652,7 @@ func TestAcceptChallenge(t *testing.T) {
 			t.Errorf("r.Method = %q; want POST", r.Method)
 		}
 
-		var j struct {
-			Auth string `json:"keyAuthorization"`
-		}
-		decodeJWSRequest(t, &j, r)
-
 		keyAuth := "token1." + testKeyECThumbprint
-		if j.Auth != keyAuth {
-			t.Errorf(`keyAuthorization = %q; want %q`, j.Auth, keyAuth)
-		}
-
 		// Respond to request
 		w.WriteHeader(http.StatusOK)
 		fmt.Fprintf(w, `{
@@ -691,7 +698,7 @@ func TestFinalizeOrder(t *testing.T) {
 			w.Header().Set("Replay-Nonce", "test-nonce")
 			return
 		}
-		if r.URL.Path == "/cert" && r.Method == "GET" {
+		if r.URL.Path == "/cert" && r.Method == "POST" {
 			pem.Encode(w, &pem.Block{Type: "CERTIFICATE", Bytes: sampleCert})
 			return
 		}
@@ -786,7 +793,7 @@ func TestWaitOrderInvalid(t *testing.T) {
 	}))
 	defer ts.Close()
 
-	var client Client
+	client := &Client{Key: testKey, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 	_, err := client.WaitOrder(context.Background(), ts.URL+"/pending")
 	if e, ok := err.(OrderPendingError); ok {
 		if e.Order == nil {
@@ -814,6 +821,10 @@ func TestWaitOrderInvalid(t *testing.T) {
 
 func TestGetOrder(t *testing.T) {
 	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		if r.Method == "HEAD" {
+			w.Header().Set("Replay-Nonce", "test-nonce")
+			return
+		}
 		fmt.Fprintf(w, `{
 			"identifiers": [{"type":"dns","value":"example.com"}],
 			"status":"valid",
@@ -824,7 +835,7 @@ func TestGetOrder(t *testing.T) {
 	}))
 	defer ts.Close()
 
-	var client Client
+	client := &Client{Key: testKey, dir: &Directory{NewNonceURL: ts.URL, NewAccountURL: ts.URL + "/account"}}
 	o, err := client.GetOrder(context.Background(), ts.URL)
 	if err != nil {
 		t.Fatal(err)
diff --git a/third_party/crypto/acme/jws.go b/third_party/crypto/acme/jws.go
index 8ca8dbc91..1b514cccb 100644
--- a/third_party/crypto/acme/jws.go
+++ b/third_party/crypto/acme/jws.go
@@ -36,11 +36,14 @@ func jwsEncodeJSON(claimset interface{}, key crypto.Signer, accountURL, url, non
 		phead = fmt.Sprintf(`{"alg":%q,"kid":%q,"nonce":%q,"url":%q}`, alg, accountURL, nonce, url)
 	}
 	phead = base64.RawURLEncoding.EncodeToString([]byte(phead))
-	cs, err := json.Marshal(claimset)
-	if err != nil {
-		return nil, err
+	payload := ""
+	if claimset != nil {
+		cs, err := json.Marshal(claimset)
+		if err != nil {
+			return nil, err
+		}
+		payload = base64.RawURLEncoding.EncodeToString(cs)
 	}
-	payload := base64.RawURLEncoding.EncodeToString(cs)
 	hash := sha.New()
 	hash.Write([]byte(phead + "." + payload))
 	sig, err := jwsSign(key, sha, hash.Sum(nil))
diff --git a/vendor/github.com/Venafi/vcert/client.go b/vendor/github.com/Venafi/vcert/client.go
index 552d5d4a8..80ddff6a0 100644
--- a/vendor/github.com/Venafi/vcert/client.go
+++ b/vendor/github.com/Venafi/vcert/client.go
@@ -25,32 +25,40 @@ import (
 	"github.com/Venafi/vcert/pkg/venafi/tpp"
 )
 
+// NewClient returns a connector for either Trust Protection Platform (TPP) or Venafi Cloud based on provided configuration.
+// Config should have Credentials compatible with the selected ConnectorType.
+// Returned connector is a concurrency-safe interface to TPP or Venafi Cloud that can be reused without restriction.
+// Connector can also be of type "fake" for local tests, which doesn`t connect to any backend and all certificates enroll locally.
 func NewClient(cfg *Config) (endpoint.Connector, error) {
 	var err error
 
 	var connectionTrustBundle *x509.CertPool
 	if cfg.ConnectionTrust != "" {
+		fmt.Println("You specified a trust bundle.")
 		connectionTrustBundle = x509.NewCertPool()
 		if !connectionTrustBundle.AppendCertsFromPEM([]byte(cfg.ConnectionTrust)) {
-			return nil, fmt.Errorf("failed to parse PEM trust bundle")
+			return nil, fmt.Errorf("Failed to parse PEM trust bundle")
 		}
 	}
 
 	var connector endpoint.Connector
 	switch cfg.ConnectorType {
 	case endpoint.ConnectorTypeCloud:
-		connector = cloud.NewConnector(cfg.LogVerbose, connectionTrustBundle)
+		connector, err = cloud.NewConnector(cfg.BaseUrl, cfg.Zone, cfg.LogVerbose, connectionTrustBundle)
+		if err != nil {
+			return nil, err
+		}
 	case endpoint.ConnectorTypeTPP:
-		connector = tpp.NewConnector(cfg.LogVerbose, connectionTrustBundle)
+		connector, err = tpp.NewConnector(cfg.BaseUrl, cfg.Zone, cfg.LogVerbose, connectionTrustBundle)
+		if err != nil {
+			return nil, err
+		}
 	case endpoint.ConnectorTypeFake:
 		connector = fake.NewConnector(cfg.LogVerbose, connectionTrustBundle)
 	default:
 		return nil, fmt.Errorf("ConnectorType is not defined")
 	}
 
-	if cfg.BaseUrl != "" {
-		connector.SetBaseURL(cfg.BaseUrl)
-	}
 	connector.SetZone(cfg.Zone)
 
 	err = connector.Authenticate(cfg.Credentials)
diff --git a/vendor/github.com/Venafi/vcert/config.go b/vendor/github.com/Venafi/vcert/config.go
index e4f74ceb9..270f4dd89 100644
--- a/vendor/github.com/Venafi/vcert/config.go
+++ b/vendor/github.com/Venafi/vcert/config.go
@@ -26,51 +26,57 @@ import (
 	"path/filepath"
 )
 
+// Config is a basic structure for high level initiating connector to Trust Platform (TPP)/Venafi Cloud
 type Config struct {
-	ConnectorType   endpoint.ConnectorType
-	BaseUrl         string
-	Zone            string
-	Credentials     *endpoint.Authentication
+	// ConnectorType specify what do you want to use. May be "Cloud", "TPP" or "Fake" for development.
+	ConnectorType endpoint.ConnectorType
+	// BaseUrl should be specified for Venafi Platform. Optional for Cloud implementations that do not use https://venafi.cloud/.
+	BaseUrl string
+	// Zone is name of a policy zone in Venafi Platform or Cloud. For TPP, if necessary, escape backslash symbols.   For example,  "test\\zone" or `test\zone`.
+	Zone string
+	// Credentials should contain either User and Password for TPP connections or an APIKey for Cloud.
+	Credentials *endpoint.Authentication
+	// ConnectionTrust  may contain a trusted CA or certificate of server if you use self-signed certificate.
 	ConnectionTrust string // *x509.CertPool
 	LogVerbose      bool
-	ConfigFile      string
-	ConfigSection   string
 }
 
-func (cfg *Config) LoadFromFile() error {
-	if cfg.ConfigSection == "" {
-		cfg.ConfigSection = ini.DEFAULT_SECTION
+// LoadFromFile is deprecated. In the future will be rewrited.
+func LoadConfigFromFile(path, section string) (cfg Config, err error) {
+
+	if section == "" {
+		section = ini.DEFAULT_SECTION
 	}
-	log.Printf("Loading configuration from %s section %s", cfg.ConfigFile, cfg.ConfigSection)
+	log.Printf("Loading configuration from %s section %s", path, section)
 
-	fname, err := expand(cfg.ConfigFile)
+	fname, err := expand(path)
 	if err != nil {
-		return fmt.Errorf("failed to load config: %s", err)
+		return cfg, fmt.Errorf("failed to load config: %s", err)
 	}
 
 	iniFile, err := ini.Load(fname)
 	if err != nil {
-		return fmt.Errorf("failed to load config: %s", err)
+		return cfg, fmt.Errorf("failed to load config: %s", err)
 	}
 
 	err = validateFile(iniFile)
 	if err != nil {
-		return fmt.Errorf("failed to load config: %s", err)
+		return cfg, fmt.Errorf("failed to load config: %s", err)
 	}
 
 	ok := func() bool {
-		for _, section := range iniFile.Sections() {
-			if section.Name() == cfg.ConfigSection {
+		for _, s := range iniFile.Sections() {
+			if s.Name() == section {
 				return true
 			}
 		}
 		return false
 	}()
 	if !ok {
-		return fmt.Errorf("section %s has not been found in %s", cfg.ConfigSection, cfg.ConfigFile)
+		return cfg, fmt.Errorf("section %s has not been found in %s", section, path)
 	}
 
-	var m Dict = iniFile.Section(cfg.ConfigSection).KeysHash()
+	var m dict = iniFile.Section(section).KeysHash()
 
 	var connectorType endpoint.ConnectorType
 	var baseUrl string
@@ -98,17 +104,17 @@ func (cfg *Config) LoadFromFile() error {
 	} else if m.has("test_mode") && m["test_mode"] == "true" {
 		connectorType = endpoint.ConnectorTypeFake
 	} else {
-		return fmt.Errorf("failed to load config: connector type cannot be defined")
+		return cfg, fmt.Errorf("failed to load config: connector type cannot be defined")
 	}
 
 	if m.has("trust_bundle") {
 		fname, err := expand(m["trust_bundle"])
 		if err != nil {
-			return fmt.Errorf("failed to load trust-bundle: %s", err)
+			return cfg, fmt.Errorf("failed to load trust-bundle: %s", err)
 		}
 		data, err := ioutil.ReadFile(fname)
 		if err != nil {
-			return fmt.Errorf("failed to load trust-bundle: %s", err)
+			return cfg, fmt.Errorf("failed to load trust-bundle: %s", err)
 		}
 		cfg.ConnectionTrust = string(data)
 	}
@@ -117,7 +123,7 @@ func (cfg *Config) LoadFromFile() error {
 	cfg.Credentials = auth
 	cfg.BaseUrl = baseUrl
 
-	return nil
+	return
 }
 
 func expand(path string) (string, error) {
@@ -131,18 +137,18 @@ func expand(path string) (string, error) {
 	return filepath.Join(usr.HomeDir, path[1:]), nil
 }
 
-type Dict map[string]string
+type dict map[string]string
 
-func (d Dict) has(key string) bool {
+func (d dict) has(key string) bool {
 	if _, ok := d[key]; ok {
 		return true
 	}
 	return false
 }
 
-type Set map[string]bool
+type set map[string]bool
 
-func (d Set) has(key string) bool {
+func (d set) has(key string) bool {
 	if _, ok := d[key]; ok {
 		return true
 	}
@@ -150,14 +156,14 @@ func (d Set) has(key string) bool {
 }
 
 func validateSection(s *ini.Section) error {
-	var TPPValidKeys Set = map[string]bool{
+	var TPPValidKeys set = map[string]bool{
 		"tpp_url":      true,
 		"tpp_user":     true,
 		"tpp_password": true,
 		"tpp_zone":     true,
 		"trust_bundle": true,
 	}
-	var CloudValidKeys Set = map[string]bool{
+	var CloudValidKeys set = map[string]bool{
 		"trust_bundle": true,
 		"cloud_url":    true,
 		"cloud_apikey": true,
@@ -165,11 +171,11 @@ func validateSection(s *ini.Section) error {
 	}
 
 	log.Printf("Validating configuration section %s", s.Name())
-	var m Dict = s.KeysHash()
+	var m dict = s.KeysHash()
 
 	if m.has("tpp_url") {
 		// looks like TPP config section
-		for k, _ := range m {
+		for k := range m {
 			if !TPPValidKeys.has(k) {
 				return fmt.Errorf("illegal key '%s' in TPP section %s", k, s.Name())
 			}
@@ -182,7 +188,7 @@ func validateSection(s *ini.Section) error {
 		}
 	} else if m.has("cloud_apikey") {
 		// looks like Cloud config section
-		for k, _ := range m {
+		for k := range m {
 			if !CloudValidKeys.has(k) {
 				return fmt.Errorf("illegal key '%s' in Cloud section %s", k, s.Name())
 			}
diff --git a/vendor/github.com/Venafi/vcert/pkg/certificate/certificate.go b/vendor/github.com/Venafi/vcert/pkg/certificate/certificate.go
index 025b96c96..8aaa3791a 100644
--- a/vendor/github.com/Venafi/vcert/pkg/certificate/certificate.go
+++ b/vendor/github.com/Venafi/vcert/pkg/certificate/certificate.go
@@ -17,6 +17,7 @@
 package certificate
 
 import (
+	"crypto"
 	"crypto/ecdsa"
 	"crypto/elliptic"
 	"crypto/rand"
@@ -30,7 +31,7 @@ import (
 	"time"
 )
 
-//EllipticCurve represents the types of supported elliptic curves
+// EllipticCurve represents the types of supported elliptic curves
 type EllipticCurve int
 
 func (ec *EllipticCurve) String() string {
@@ -48,7 +49,7 @@ func (ec *EllipticCurve) String() string {
 	}
 }
 
-//Set the elliptic cuve value via a string
+// Set EllipticCurve value via a string
 func (ec *EllipticCurve) Set(value string) error {
 	switch strings.ToLower(value) {
 	case "p521":
@@ -60,24 +61,34 @@ func (ec *EllipticCurve) Set(value string) error {
 	case "p224":
 		*ec = EllipticCurveP224
 	default:
-		*ec = EllipticCurveP521
+		*ec = EllipticCurveDefault
 	}
 
 	return nil
 }
 
 const (
-	//EllipticCurveP521 represents the P521 curve
+	// EllipticCurveP521 represents the P521 curve
 	EllipticCurveP521 EllipticCurve = iota
-	//EllipticCurveP224 represents the P224 curve
+	// EllipticCurveP224 represents the P224 curve
 	EllipticCurveP224
-	//EllipticCurveP256 represents the P256 curve
+	// EllipticCurveP256 represents the P256 curve
 	EllipticCurveP256
-	//EllipticCurveP384 represents the P384 curve
+	// EllipticCurveP384 represents the P384 curve
 	EllipticCurveP384
+	EllipticCurveDefault = EllipticCurveP521
+
+	defaultRSAlength int = 2048
 )
 
-//KeyType represents the types of supported keys
+func AllSupportedCurves() []EllipticCurve {
+	return []EllipticCurve{EllipticCurveP521, EllipticCurveP224, EllipticCurveP256, EllipticCurveP384}
+}
+func AllSupportedKeySizes() []int {
+	return []int{512, 1024, 2048, 4096, 8192}
+}
+
+// KeyType represents the types of supported keys
 type KeyType int
 
 func (kt *KeyType) String() string {
@@ -91,59 +102,75 @@ func (kt *KeyType) String() string {
 	}
 }
 
-//Set the key type via a string
+func (kt *KeyType) X509Type() x509.PublicKeyAlgorithm {
+	switch *kt {
+	case KeyTypeRSA:
+		return x509.RSA
+	case KeyTypeECDSA:
+		return x509.ECDSA
+	}
+	return x509.UnknownPublicKeyAlgorithm
+}
+
+// Set the key type via a string
 func (kt *KeyType) Set(value string) error {
 	switch strings.ToLower(value) {
 	case "rsa":
 		*kt = KeyTypeRSA
-	case "ecdsa":
-		*kt = KeyTypeECDSA
-	default:
+		return nil
+	case "ecdsa", "ec", "ecc":
 		*kt = KeyTypeECDSA
+		return nil
 	}
-
-	return nil
+	return fmt.Errorf("unknow key type: %s", value) //todo: check all calls
 }
 
 const (
-	//KeyTypeRSA represents a key type of RSA
+	// KeyTypeRSA represents a key type of RSA
 	KeyTypeRSA KeyType = iota
-	//KeyTypeECDSA represents a key type of ECDSA
+	// KeyTypeECDSA represents a key type of ECDSA
 	KeyTypeECDSA
 )
 
 type CSrOriginOption int
 
 const (
+	// LocalGeneratedCSR - this vcert library generates CSR internally based on Request data
 	LocalGeneratedCSR CSrOriginOption = iota // local generation is default.
+	// ServiceGeneratedCSR - server generate CSR internally based on zone configuration and data from Request
 	ServiceGeneratedCSR
+	// UserProvidedCSR - client provides CSR from external resource and vcert library just check and send this CSR to server
 	UserProvidedCSR
 )
 
-//Request contains data needed to generate a certificate request
+// Request contains data needed to generate a certificate request
+// CSR is a PEM-encoded Certificate Signing Request
 type Request struct {
+	CADN               string
 	Subject            pkix.Name
 	DNSNames           []string
 	EmailAddresses     []string
 	IPAddresses        []net.IP
 	Attributes         []pkix.AttributeTypeAndValueSET
 	SignatureAlgorithm x509.SignatureAlgorithm
-	PublicKeyAlgorithm x509.PublicKeyAlgorithm
 	FriendlyName       string
 	KeyType            KeyType
 	KeyLength          int
 	KeyCurve           EllipticCurve
-	CSR                []byte
-	PrivateKey         interface{}
-	CsrOrigin          CSrOriginOption
-	PickupID           string
-	ChainOption        ChainOption
-	KeyPassword        string
-	FetchPrivateKey    bool
-	Thumbprint         string /* this one is here because *Request is used in RetrieveCertificate(),
-	   it should be refactored so that RetrieveCertificate() uses
-	   some abstract search object, instead of *Request{PickupID} */
-	Timeout time.Duration
+	//CSR                []byte // should be a PEM-encoded CSR
+	csr        []byte // should be a PEM-encoded CSR
+	PrivateKey crypto.Signer
+	CsrOrigin  CSrOriginOption
+	PickupID   string
+	//Cloud Certificate ID
+	CertID          string
+	ChainOption     ChainOption
+	KeyPassword     string
+	FetchPrivateKey bool
+	/*	Thumbprint is here because *Request is used in RetrieveCertificate().
+		Code should be refactored so that RetrieveCertificate() uses some abstract search object, instead of *Request{PickupID} */
+	Thumbprint string
+	Timeout    time.Duration
 }
 
 type RevocationRequest struct {
@@ -172,13 +199,52 @@ type ImportRequest struct {
 
 type ImportResponse struct {
 	CertificateDN      string `json:",omitempty"`
+	CertId             string `json:",omitempty"`
 	CertificateVaultId int    `json:",omitempty"`
 	Guid               string `json:",omitempty"`
 	PrivateKeyVaultId  int    `json:",omitempty"`
 }
 
-//GenerateRequest generates a certificate request
-func GenerateRequest(request *Request, privateKey interface{}) error {
+// SetCSR sets CSR from PEM or DER format
+func (request *Request) SetCSR(csr []byte) error {
+	pemBlock, _ := pem.Decode(csr)
+	if pemBlock != nil {
+		if pemBlock.Type == "CERTIFICATE REQUEST" {
+			request.csr = csr
+			return nil
+		}
+	}
+
+	//Determine CSR type and use appropriate function
+	parsedCSR, err := x509.ParseCertificateRequest(csr)
+	if err != nil {
+		return err
+	}
+	if parsedCSR != nil {
+		request.csr = pem.EncodeToMemory(GetCertificateRequestPEMBlock(csr))
+		return nil
+	}
+	return fmt.Errorf("Can't determine CSR type for %s", csr)
+}
+
+// GetCSR returns CSR in PEM format
+func (request Request) GetCSR() []byte {
+	return request.csr
+}
+
+// GenerateRequest generates a certificate request
+// Please use method Request.GenerateCSR()
+// TODO: Remove usage from all libraries, deprecated
+func GenerateRequest(request *Request, privateKey crypto.Signer) error {
+	pk := request.PrivateKey
+	request.PrivateKey = privateKey
+	err := request.GenerateCSR()
+	request.PrivateKey = pk
+	return err
+}
+
+// GenerateCSR creates CSR for sending to server based on data from Request fields. It rewrites CSR field if it`s already filled.
+func (request *Request) GenerateCSR() error {
 	certificateRequest := x509.CertificateRequest{}
 	certificateRequest.Subject = request.Subject
 	certificateRequest.DNSNames = request.DNSNames
@@ -186,32 +252,118 @@ func GenerateRequest(request *Request, privateKey interface{}) error {
 	certificateRequest.IPAddresses = request.IPAddresses
 	certificateRequest.Attributes = request.Attributes
 
-	csr, err := x509.CreateCertificateRequest(rand.Reader, &certificateRequest, privateKey)
+	csr, err := x509.CreateCertificateRequest(rand.Reader, &certificateRequest, request.PrivateKey)
 	if err != nil {
 		csr = nil
 	}
-	request.CSR = csr
-
+	err = request.SetCSR(csr)
+	//request.CSR = pem.EncodeToMemory(GetCertificateRequestPEMBlock(csr))
 	return err
 }
 
-func publicKey(priv interface{}) interface{} {
-	switch k := priv.(type) {
-	case *rsa.PrivateKey:
-		return &k.PublicKey
-	case *ecdsa.PrivateKey:
-		return &k.PublicKey
-	default:
+// GeneratePrivateKey creates private key (if it doesn`t already exist) based on request.KeyType, request.KeyLength and request.KeyCurve fileds
+func (request *Request) GeneratePrivateKey() error {
+	if request.PrivateKey != nil {
 		return nil
 	}
+	var err error
+	switch request.KeyType {
+	case KeyTypeECDSA:
+		request.PrivateKey, err = GenerateECDSAPrivateKey(request.KeyCurve)
+	case KeyTypeRSA:
+		if request.KeyLength == 0 {
+			request.KeyLength = defaultRSAlength
+		}
+		request.PrivateKey, err = GenerateRSAPrivateKey(request.KeyLength)
+	default:
+		return fmt.Errorf("Unable to generate certificate request, key type %s is not supported", request.KeyType.String())
+	}
+	return err
+}
+
+// CheckCertificate validate that certificate returned by server matches data in request object. It can be used for control server.
+func (request *Request) CheckCertificate(certPEM string) error {
+	pemBlock, _ := pem.Decode([]byte(certPEM))
+	if pemBlock == nil {
+		return fmt.Errorf("invalid pem format certificate %s", certPEM)
+	}
+	if pemBlock.Type != "CERTIFICATE" {
+		return fmt.Errorf("invalid pem type %s (expect CERTIFICATE)", pemBlock.Type)
+	}
+	cert, err := x509.ParseCertificate(pemBlock.Bytes)
+	if err != nil {
+		return err
+	}
+	if request.PrivateKey != nil {
+		if request.KeyType.X509Type() != cert.PublicKeyAlgorithm {
+			return fmt.Errorf("unmatched key type: %s, %s", request.KeyType.X509Type(), cert.PublicKeyAlgorithm)
+		}
+		switch cert.PublicKeyAlgorithm {
+		case x509.RSA:
+			certPubKey := cert.PublicKey.(*rsa.PublicKey)
+			reqPubkey, ok := request.PrivateKey.Public().(*rsa.PublicKey)
+			if !ok {
+				return fmt.Errorf("request KeyType not matched with real PrivateKey type")
+			}
+
+			if certPubKey.N.Cmp(reqPubkey.N) != 0 {
+				return fmt.Errorf("unmatched key modules")
+			}
+		case x509.ECDSA:
+			certPubkey := cert.PublicKey.(*ecdsa.PublicKey)
+			reqPubkey, ok := request.PrivateKey.Public().(*ecdsa.PublicKey)
+			if !ok {
+				return fmt.Errorf("request KeyType not matched with real PrivateKey type")
+			}
+			if certPubkey.X.Cmp(reqPubkey.X) != 0 {
+				return fmt.Errorf("unmatched X for eliptic keys")
+			}
+		default:
+			return fmt.Errorf("unknown key algorythm %d", cert.PublicKeyAlgorithm)
+		}
+	} else if len(request.csr) != 0 {
+		pemBlock, _ := pem.Decode(request.csr)
+		if pemBlock == nil {
+			return fmt.Errorf("bad csr: %s", string(request.csr))
+		}
+		csr, err := x509.ParseCertificateRequest(pemBlock.Bytes)
+		if err != nil {
+			return err
+		}
+		if cert.PublicKeyAlgorithm != csr.PublicKeyAlgorithm {
+			return fmt.Errorf("unmatched key type: %s, %s", cert.PublicKeyAlgorithm, csr.PublicKeyAlgorithm)
+		}
+		switch csr.PublicKeyAlgorithm {
+		case x509.RSA:
+			certPubKey := cert.PublicKey.(*rsa.PublicKey)
+			reqPubKey := csr.PublicKey.(*rsa.PublicKey)
+			if certPubKey.N.Cmp(reqPubKey.N) != 0 {
+				return fmt.Errorf("unmatched key modules")
+			}
+		case x509.ECDSA:
+			certPubKey := cert.PublicKey.(*ecdsa.PublicKey)
+			reqPubKey := csr.PublicKey.(*ecdsa.PublicKey)
+			if certPubKey.X.Cmp(reqPubKey.X) != 0 {
+				return fmt.Errorf("unmatched X for eliptic keys")
+			}
+		}
+	}
+	return nil
+}
+
+func publicKey(priv crypto.Signer) crypto.PublicKey {
+	if priv != nil {
+		return priv.Public()
+	}
+	return nil
 }
 
-func PublicKey(priv interface{}) interface{} {
+func PublicKey(priv crypto.Signer) crypto.PublicKey {
 	return publicKey(priv)
 }
 
-//GetPrivateKeyPEMBock gets the private key as a PEM data block
-func GetPrivateKeyPEMBock(key interface{}) (*pem.Block, error) {
+// GetPrivateKeyPEMBock gets the private key as a PEM data block
+func GetPrivateKeyPEMBock(key crypto.Signer) (*pem.Block, error) { // TODO: Change to crypto.Signer type
 	switch k := key.(type) {
 	case *rsa.PrivateKey:
 		return &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(k)}, nil
@@ -226,8 +378,8 @@ func GetPrivateKeyPEMBock(key interface{}) (*pem.Block, error) {
 	}
 }
 
-//GetEncryptedPrivateKeyPEMBock gets the private key as an encrypted PEM data block
-func GetEncryptedPrivateKeyPEMBock(key interface{}, password []byte) (*pem.Block, error) {
+// GetEncryptedPrivateKeyPEMBock gets the private key as an encrypted PEM data block
+func GetEncryptedPrivateKeyPEMBock(key crypto.Signer, password []byte) (*pem.Block, error) { // TODO: Change to crypto.Signer type
 	switch k := key.(type) {
 	case *rsa.PrivateKey:
 		return x509.EncryptPEMBlock(rand.Reader, "RSA PRIVATE KEY", x509.MarshalPKCS1PrivateKey(k), password, x509.PEMCipherAES256)
@@ -242,17 +394,17 @@ func GetEncryptedPrivateKeyPEMBock(key interface{}, password []byte) (*pem.Block
 	}
 }
 
-//GetCertificatePEMBlock gets the certificate as a PEM data block
+// GetCertificatePEMBlock gets the certificate as a PEM data block
 func GetCertificatePEMBlock(cert []byte) *pem.Block {
 	return &pem.Block{Type: "CERTIFICATE", Bytes: cert}
 }
 
-//GetCertificateRequestPEMBlock gets the certificate request as a PEM data block
+// GetCertificateRequestPEMBlock gets the certificate request as a PEM data block
 func GetCertificateRequestPEMBlock(request []byte) *pem.Block {
 	return &pem.Block{Type: "CERTIFICATE REQUEST", Bytes: request}
 }
 
-//GenerateECDSAPrivateKey generates a new ecdsa private key using the curve specified
+// GenerateECDSAPrivateKey generates a new ecdsa private key using the curve specified
 func GenerateECDSAPrivateKey(curve EllipticCurve) (*ecdsa.PrivateKey, error) {
 	var priv *ecdsa.PrivateKey
 	var c elliptic.Curve
@@ -277,7 +429,7 @@ func GenerateECDSAPrivateKey(curve EllipticCurve) (*ecdsa.PrivateKey, error) {
 	return priv, nil
 }
 
-//GenerateRSAPrivateKey generates a new rsa private key using the size specified
+// GenerateRSAPrivateKey generates a new rsa private key using the size specified
 func GenerateRSAPrivateKey(size int) (*rsa.PrivateKey, error) {
 	priv, err := rsa.GenerateKey(rand.Reader, size)
 	if err != nil {
@@ -287,16 +439,16 @@ func GenerateRSAPrivateKey(size int) (*rsa.PrivateKey, error) {
 	return priv, nil
 }
 
+// NewRequest duplicates new Request object based on issued certificate
 func NewRequest(cert *x509.Certificate) *Request {
 	req := &Request{}
-	// 1st fill with *cert content
 
+	// First populate with *cert content
 	req.Subject = cert.Subject
 	req.DNSNames = cert.DNSNames
 	req.EmailAddresses = cert.EmailAddresses
 	req.IPAddresses = cert.IPAddresses
 	req.SignatureAlgorithm = cert.SignatureAlgorithm
-	req.PublicKeyAlgorithm = cert.PublicKeyAlgorithm
 	switch pub := cert.PublicKey.(type) {
 	case *rsa.PublicKey:
 		req.KeyType = KeyTypeRSA
@@ -304,8 +456,8 @@ func NewRequest(cert *x509.Certificate) *Request {
 	case *ecdsa.PublicKey:
 		req.KeyType = KeyTypeECDSA
 		req.KeyLength = pub.Curve.Params().BitSize
-		// TODO: req.KeyCurve = pub.Curve.Params().Name...
-	default: // case *dsa.PublicKey:
+		// TODO: req.KeyCurve = pub.Curve.Params().Name ...
+	default: // case *dsa.PublicKey
 		// vcert only works with RSA & ECDSA
 	}
 	return req
diff --git a/vendor/github.com/Venafi/vcert/pkg/certificate/certificateCollection.go b/vendor/github.com/Venafi/vcert/pkg/certificate/certificateCollection.go
index 9cdff5ace..2178dd38a 100644
--- a/vendor/github.com/Venafi/vcert/pkg/certificate/certificateCollection.go
+++ b/vendor/github.com/Venafi/vcert/pkg/certificate/certificateCollection.go
@@ -17,6 +17,7 @@
 package certificate
 
 import (
+	"crypto"
 	"crypto/x509"
 	"encoding/pem"
 	"fmt"
@@ -55,7 +56,7 @@ type PEMCollection struct {
 }
 
 //NewPEMCollection creates a PEMCollection based on the data being passed in
-func NewPEMCollection(certificate *x509.Certificate, privateKey interface{}, privateKeyPassword []byte) (*PEMCollection, error) {
+func NewPEMCollection(certificate *x509.Certificate, privateKey crypto.Signer, privateKeyPassword []byte) (*PEMCollection, error) { //todo: change to crypto.Signer type
 	collection := PEMCollection{}
 	if certificate != nil {
 		collection.Certificate = string(pem.EncodeToMemory(GetCertificatePEMBlock(certificate.Raw)))
@@ -63,7 +64,7 @@ func NewPEMCollection(certificate *x509.Certificate, privateKey interface{}, pri
 	if privateKey != nil {
 		var p *pem.Block
 		var err error
-		if privateKeyPassword != nil && len(privateKeyPassword) > 0 {
+		if len(privateKeyPassword) > 0 {
 			p, err = GetEncryptedPrivateKeyPEMBock(privateKey, privateKeyPassword)
 		} else {
 			p, err = GetPrivateKeyPEMBock(privateKey)
@@ -114,14 +115,20 @@ func PEMCollectionFromBytes(certBytes []byte, chainOrder ChainOption) (*PEMColle
 			collection, err = NewPEMCollection(chain[len(chain)-1], nil, nil)
 			if len(chain) > 1 && chainOrder != ChainOptionIgnore {
 				for _, caCert := range chain[:len(chain)-1] {
-					collection.AddChainElement(caCert)
+					err = collection.AddChainElement(caCert)
+					if err != nil {
+						return nil, err
+					}
 				}
 			}
 		default:
 			collection, err = NewPEMCollection(chain[0], nil, nil)
 			if len(chain) > 1 && chainOrder != ChainOptionIgnore {
 				for _, caCert := range chain[1:] {
-					collection.AddChainElement(caCert)
+					err = collection.AddChainElement(caCert)
+					if err != nil {
+						return nil, err
+					}
 				}
 			}
 		}
@@ -137,13 +144,13 @@ func PEMCollectionFromBytes(certBytes []byte, chainOrder ChainOption) (*PEMColle
 }
 
 //AddPrivateKey adds a Private Key to the PEMCollection. Note that the collection can only contain one private key
-func (col *PEMCollection) AddPrivateKey(privateKey interface{}, privateKeyPassword []byte) error {
+func (col *PEMCollection) AddPrivateKey(privateKey crypto.Signer, privateKeyPassword []byte) error { //todo: change to crypto.Signer type
 	if col.PrivateKey != "" {
 		return fmt.Errorf("The PEM Collection can only contain one private key")
 	}
 	var p *pem.Block
 	var err error
-	if privateKeyPassword != nil && len(privateKeyPassword) > 0 {
+	if len(privateKeyPassword) > 0 {
 		p, err = GetEncryptedPrivateKeyPEMBock(privateKey, privateKeyPassword)
 	} else {
 		p, err = GetPrivateKeyPEMBock(privateKey)
diff --git a/vendor/github.com/Venafi/vcert/pkg/endpoint/endpoint.go b/vendor/github.com/Venafi/vcert/pkg/endpoint/endpoint.go
index 763906e21..cf42449de 100644
--- a/vendor/github.com/Venafi/vcert/pkg/endpoint/endpoint.go
+++ b/vendor/github.com/Venafi/vcert/pkg/endpoint/endpoint.go
@@ -19,10 +19,11 @@ package endpoint
 import (
 	"crypto/x509"
 	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
+	"log"
 	"regexp"
 	"sort"
-	"strings"
+
+	"github.com/Venafi/vcert/pkg/certificate"
 )
 
 // ConnectorType represents the available connectors
@@ -55,22 +56,30 @@ func (t ConnectorType) String() string {
 
 // Connector provides a common interface for external communications with TPP or Venafi Cloud
 type Connector interface {
+	// GetType returns a connector type (cloud/TPP/fake). Can be useful because some features are not supported by a Cloud connection.
 	GetType() ConnectorType
-	SetBaseURL(url string) (err error)
+	// SetZone sets a zone (by name) for requests with this connector.
 	SetZone(z string)
 	Ping() (err error)
-	Register(email string) (err error)
+	// Authenticate is usually called by NewClient and it is not required that you manually call it.
 	Authenticate(auth *Authentication) (err error)
-	ReadZoneConfiguration(zone string) (config *ZoneConfiguration, err error)
+	// ReadPolicyConfiguration returns information about zone policies. It can be used for checking request compatibility with policies.
+	ReadPolicyConfiguration() (policy *Policy, err error)
+	// ReadZoneConfiguration returns the zone configuration. A zone configuration includes zone policy and additional zone information.
+	ReadZoneConfiguration() (config *ZoneConfiguration, err error)
+	// GenerateRequest update certificate.Request with data from zone configuration.
 	GenerateRequest(config *ZoneConfiguration, req *certificate.Request) (err error)
-	RequestCertificate(req *certificate.Request, zone string) (requestID string, err error)
+	// RequestCertificate makes a request to the server with data for enrolling the certificate.
+	RequestCertificate(req *certificate.Request) (requestID string, err error)
+	// RetrieveCertificate immediately returns an enrolled certificate. Otherwise, RetrieveCertificate waits and retries during req.Timeout.
 	RetrieveCertificate(req *certificate.Request) (certificates *certificate.PEMCollection, err error)
 	RevokeCertificate(req *certificate.RevocationRequest) error
 	RenewCertificate(req *certificate.RenewalRequest) (requestID string, err error)
+	// ImportCertificate adds an existing certificate to Venafi Platform even if the certificate was not issued by Venafi Cloud or Venafi Platform. For information purposes.
 	ImportCertificate(req *certificate.ImportRequest) (*certificate.ImportResponse, error)
 }
 
-// Authentication provides a data construct for authentication data
+// Authentication provides a struct for authentication data. Either specify User and Password for Trust Platform or specify an APIKey for Cloud.
 type Authentication struct {
 	User     string
 	Password string
@@ -99,28 +108,37 @@ func (err ErrCertificatePending) Error() string {
 	return fmt.Sprintf("Issuance is pending. You may try retrieving the certificate later using Pickup ID: %s\n\tStatus: %s", err.CertificateID, err.Status)
 }
 
-// ZoneConfiguration provides a common structure for certificate request data provided by the remote endpoint
-type ZoneConfiguration struct {
-	Organization       string
-	OrganizationLocked bool
-	OrganizationalUnit []string
-	Country            string
-	CountryLocked      bool
-	Province           string
-	ProvinceLocked     bool
-	Locality           string
-	LocalityLocked     bool
-
+// Policy is struct that contains restrictions for certificates. Most of the fields contains list of regular expression.
+// For satisfying policies, all values in the certificate field must match AT LEAST ONE regular expression in corresponding policy field.
+type Policy struct {
 	SubjectCNRegexes []string
 	SubjectORegexes  []string
 	SubjectOURegexes []string
 	SubjectSTRegexes []string
 	SubjectLRegexes  []string
 	SubjectCRegexes  []string
-	SANRegexes       []string
-
+	// AllowedKeyConfigurations lists all allowed key configurations. Certificate key configuration have to be listed in this list.
+	// For example: If key has type RSA and length 2048 bit for satisfying the policy, that list must contain AT LEAST ONE configuration with type RSA and value 2048 in KeySizes list of this configuration.
 	AllowedKeyConfigurations []AllowedKeyConfiguration
-	KeySizeLocked            bool
+	// DnsSanRegExs is a list of regular expressions that show allowable DNS names in SANs.
+	DnsSanRegExs []string
+	// IpSanRegExs is a list of regular expressions that show allowable DNS names in SANs.
+	IpSanRegExs    []string
+	EmailSanRegExs []string
+	UriSanRegExs   []string
+	UpnSanRegExs   []string
+	AllowWildcards bool
+	AllowKeyReuse  bool
+}
+
+// ZoneConfiguration provides a common structure for certificate request data provided by the remote endpoint
+type ZoneConfiguration struct {
+	Organization       string
+	OrganizationalUnit []string
+	Country            string
+	Province           string
+	Locality           string
+	Policy
 
 	HashAlgorithm x509.SignatureAlgorithm
 
@@ -142,33 +160,34 @@ func NewZoneConfiguration() *ZoneConfiguration {
 	return &zc
 }
 
-// ValidateCertificateRequest validates the request against the zone configuration
-func (z *ZoneConfiguration) ValidateCertificateRequest(request *certificate.Request) error {
-	if !isComponentValid(z.SubjectCNRegexes, []string{request.Subject.CommonName}) {
+// ValidateCertificateRequest validates the request against the Policy
+func (p *Policy) ValidateCertificateRequest(request *certificate.Request) error {
+	if !isComponentValid(p.SubjectCNRegexes, []string{request.Subject.CommonName}) {
 		return fmt.Errorf("The requested CN does not match any of the allowed CN regular expressions")
 	}
-	if !isComponentValid(z.SubjectORegexes, request.Subject.Organization) {
+	if !isComponentValid(p.SubjectORegexes, request.Subject.Organization) {
 		return fmt.Errorf("The requested Organization does not match any of the allowed Organization regular expressions")
 	}
-	if !isComponentValid(z.SubjectOURegexes, request.Subject.OrganizationalUnit) {
+	if !isComponentValid(p.SubjectOURegexes, request.Subject.OrganizationalUnit) {
 		return fmt.Errorf("The requested Organizational Unit does not match any of the allowed Organization Unit regular expressions")
 	}
-	if !isComponentValid(z.SubjectSTRegexes, request.Subject.Province) {
+	if !isComponentValid(p.SubjectSTRegexes, request.Subject.Province) {
 		return fmt.Errorf("The requested State/Province does not match any of the allowed State/Province regular expressions")
 	}
-	if !isComponentValid(z.SubjectLRegexes, request.Subject.Locality) {
+	if !isComponentValid(p.SubjectLRegexes, request.Subject.Locality) {
 		return fmt.Errorf("The requested Locality does not match any of the allowed Locality regular expressions")
 	}
-	if !isComponentValid(z.SubjectCRegexes, request.Subject.Country) {
+	if !isComponentValid(p.SubjectCRegexes, request.Subject.Country) {
 		return fmt.Errorf("The requested Country does not match any of the allowed Country regular expressions")
 	}
-	if !isComponentValid(z.SANRegexes, request.DNSNames) {
+	if !isComponentValid(p.DnsSanRegExs, request.DNSNames) {
 		return fmt.Errorf("The requested Subject Alternative Name does not match any of the allowed Country regular expressions")
 	}
+	//todo: add ip, email and over cheking
 
-	if z.AllowedKeyConfigurations != nil && len(z.AllowedKeyConfigurations) > 0 {
+	if p.AllowedKeyConfigurations != nil && len(p.AllowedKeyConfigurations) > 0 {
 		match := false
-		for _, keyConf := range z.AllowedKeyConfigurations {
+		for _, keyConf := range p.AllowedKeyConfigurations {
 			if keyConf.KeyType == request.KeyType {
 				if request.KeyLength > 0 {
 					for _, size := range keyConf.KeySizes {
@@ -194,88 +213,73 @@ func (z *ZoneConfiguration) ValidateCertificateRequest(request *certificate.Requ
 }
 
 func isComponentValid(regexes []string, component []string) bool {
-	if regexes != nil && len(regexes) > 0 && component != nil {
-		regexOk := false
-		for _, subReg := range regexes {
-			matchedAny := false
-			reg := regexp.MustCompile(subReg)
-			for _, c := range component {
-				if reg.FindStringIndex(c) != nil {
-					matchedAny = true
-					break
-				}
-			}
-			if matchedAny {
-				regexOk = true
+	if len(regexes) == 0 || len(component) == 0 {
+		return true
+	}
+	regexOk := false
+	for _, subReg := range regexes {
+		matchedAny := false
+		reg, err := regexp.Compile(subReg)
+		if err != nil {
+			log.Printf("Bad regexp: %s", subReg)
+			return false
+		}
+		for _, c := range component {
+			if reg.FindStringIndex(c) != nil {
+				matchedAny = true
 				break
 			}
 		}
-		return regexOk
+		if matchedAny {
+			regexOk = true
+			break
+		}
 	}
-	return true
+	return regexOk
 }
 
-// UpdateCertificateRequest updates a certificate request based on the zone configurataion retrieved from the remote endpoint
+// UpdateCertificateRequest updates a certificate request based on the zone configuration retrieved from the remote endpoint
 func (z *ZoneConfiguration) UpdateCertificateRequest(request *certificate.Request) {
-	if (request.Subject.Organization == nil || len(request.Subject.Organization) == 0) && z.Organization != "" {
+	if len(request.Subject.Organization) == 0 && z.Organization != "" {
 		request.Subject.Organization = []string{z.Organization}
-	} else {
-		if z.OrganizationLocked && !strings.EqualFold(request.Subject.Organization[0], z.Organization) {
-			request.Subject.Organization = []string{z.Organization}
-		}
 	}
-	if (request.Subject.OrganizationalUnit == nil || len(request.Subject.OrganizationalUnit) == 0) && z.OrganizationalUnit != nil {
+
+	if len(request.Subject.OrganizationalUnit) == 0 && z.OrganizationalUnit != nil {
 		request.Subject.OrganizationalUnit = z.OrganizationalUnit
 	}
 
-	if (request.Subject.Country == nil || len(request.Subject.Country) == 0) && z.Country != "" {
+	if len(request.Subject.Country) == 0 && z.Country != "" {
 		request.Subject.Country = []string{z.Country}
-	} else {
-		if z.CountryLocked && !strings.EqualFold(request.Subject.Country[0], z.Country) {
-			request.Subject.Country = []string{z.Country}
-		}
 	}
-	if (request.Subject.Province == nil || len(request.Subject.Province) == 0) && z.Province != "" {
+
+	if len(request.Subject.Province) == 0 && z.Province != "" {
 		request.Subject.Province = []string{z.Province}
-	} else {
-		if z.ProvinceLocked && !strings.EqualFold(request.Subject.Province[0], z.Province) {
-			request.Subject.Province = []string{z.Province}
-		}
 	}
-	if (request.Subject.Locality == nil || len(request.Subject.Locality) == 0) && z.Locality != "" {
+
+	if len(request.Subject.Locality) == 0 && z.Locality != "" {
 		request.Subject.Locality = []string{z.Locality}
-	} else {
-		if z.LocalityLocked && !strings.EqualFold(request.Subject.Locality[0], z.Locality) {
-			request.Subject.Locality = []string{z.Locality}
-		}
 	}
-	if z.HashAlgorithm != 0 {
+
+	if z.HashAlgorithm != x509.UnknownSignatureAlgorithm {
 		request.SignatureAlgorithm = z.HashAlgorithm
 	} else {
 		request.SignatureAlgorithm = x509.SHA256WithRSA
 	}
 
-	if z.KeySizeLocked {
-		for _, keyConf := range z.AllowedKeyConfigurations {
-			if keyConf.KeyType == request.KeyType {
-				sort.Sort(sort.Reverse(sort.IntSlice(keyConf.KeySizes)))
-				request.KeyLength = keyConf.KeySizes[0]
-			}
-		}
-	} else if z.AllowedKeyConfigurations != nil {
+	if len(z.AllowedKeyConfigurations) != 0 {
 		foundMatch := false
 		for _, keyConf := range z.AllowedKeyConfigurations {
 			if keyConf.KeyType == request.KeyType {
 				foundMatch = true
 				switch request.KeyType {
 				case certificate.KeyTypeECDSA:
-					if z.AllowedKeyConfigurations[0].KeyCurves != nil {
-						request.KeyCurve = z.AllowedKeyConfigurations[0].KeyCurves[0]
+					if len(keyConf.KeyCurves) != 0 {
+						request.KeyCurve = keyConf.KeyCurves[0]
 					} else {
-						request.KeyCurve = certificate.EllipticCurveP256
+						request.KeyCurve = certificate.EllipticCurveDefault
 					}
 				case certificate.KeyTypeRSA:
-					if keyConf.KeySizes != nil {
+					if len(keyConf.KeySizes) != 0 {
 						sizeOK := false
 						for _, size := range keyConf.KeySizes {
 							if size == request.KeyLength {
@@ -293,18 +297,19 @@ func (z *ZoneConfiguration) UpdateCertificateRequest(request *certificate.Reques
 			}
 		}
 		if !foundMatch {
-			request.KeyType = z.AllowedKeyConfigurations[0].KeyType
+			configuration := z.AllowedKeyConfigurations[0]
+			request.KeyType = configuration.KeyType
 			switch request.KeyType {
 			case certificate.KeyTypeECDSA:
-				if z.AllowedKeyConfigurations[0].KeyCurves != nil {
-					request.KeyCurve = z.AllowedKeyConfigurations[0].KeyCurves[0]
+				if len(configuration.KeyCurves) != 0 {
+					request.KeyCurve = configuration.KeyCurves[0]
 				} else {
-					request.KeyCurve = certificate.EllipticCurveP256
+					request.KeyCurve = certificate.EllipticCurveDefault
 				}
 			case certificate.KeyTypeRSA:
-				if z.AllowedKeyConfigurations[0].KeySizes != nil {
-					sort.Sort(sort.Reverse(sort.IntSlice(z.AllowedKeyConfigurations[0].KeySizes)))
-					request.KeyLength = z.AllowedKeyConfigurations[0].KeySizes[0]
+				if len(configuration.KeySizes) != 0 {
+					sort.Sort(sort.Reverse(sort.IntSlice(configuration.KeySizes)))
+					request.KeyLength = configuration.KeySizes[0]
 				} else {
 					request.KeyLength = 2048
 				}
@@ -316,6 +321,4 @@ func (z *ZoneConfiguration) UpdateCertificateRequest(request *certificate.Reques
 			request.KeyLength = 2048
 		}
 	}
-
-	return
 }
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/certificatePolicies.go b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/certificatePolicies.go
index 5c58df962..635c247b8 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/certificatePolicies.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/certificatePolicies.go
@@ -16,14 +16,19 @@
 
 package cloud
 
-import "time"
+import (
+	"github.com/Venafi/vcert/pkg/endpoint"
+	"regexp"
+	"strings"
+	"time"
+)
 
 type certificatePolicy struct {
 	CertificatePolicyType certificatePolicyType `json:"certificatePolicyType,omitempty"`
 	ID                    string                `json:"id,omitempty"`
 	CompanyID             string                `json:"companyId,omitempty"`
 	Name                  string                `json:"name,omitempty"`
-	SystemGenerated       bool                  `json:"systemGeneratedate,omitempty"`
+	SystemGenerated       bool                  `json:"systemGenerated,omitempty"`
 	CreationDateString    string                `json:"creationDate,omitempty"`
 	CreationDate          time.Time             `json:"-"`
 	CertificateProviderID string                `json:"certificateProviderId,omitempty"`
@@ -32,7 +37,7 @@ type certificatePolicy struct {
 	SubjectOURegexes      []string              `json:"subjectOURegexes,omitempty"`
 	SubjectSTRegexes      []string              `json:"subjectSTRegexes,omitempty"`
 	SubjectLRegexes       []string              `json:"subjectLRegexes,omitempty"`
-	SubjectCRegexes       []string              `json:"subjectCRegexes,omitempty"`
+	SubjectCRegexes       []string              `json:"subjectCValues,omitempty"`
 	SANRegexes            []string              `json:"sanRegexes,omitempty"`
 	KeyTypes              []allowedKeyType      `json:"keyTypes,omitempty"`
 	KeyReuse              bool                  `json:"keyReuse,omitempty"`
@@ -47,20 +52,87 @@ type certificatePolicyType string
 
 const (
 	certificatePolicyTypeIdentity certificatePolicyType = "CERTIFICATE_IDENTITY"
-	certificatePolicyTypeUse                            = "CERTIFICATE_USE"
+	certificatePolicyTypeUse      certificatePolicyType = "CERTIFICATE_USE"
 )
 
 type keyType string
 
-const (
-	keyTypeRSA        keyType = "RSA"
-	keyTypeDSA                = "DSA"
-	keyTypeEC                 = "EC"
-	keyTypeGost3410           = "GOST3410"
-	keyTypeECGost3410         = "ECGOST3410"
-	keyTypeReserved3          = "RESERVED3"
-	keyTypeUnknown            = "UNKNOWN"
-)
+func (cp certificatePolicy) toPolicy() (p endpoint.Policy) {
+	addStartEnd := func(s string) string {
+		if !strings.HasPrefix(s, "^") {
+			s = "^" + s
+		}
+		if !strings.HasSuffix(s, "$") {
+			s = s + "$"
+		}
+		return s
+	}
+	addStartEndToArray := func(ss []string) []string {
+		a := make([]string, len(ss))
+		for i, s := range ss {
+			a[i] = addStartEnd(s)
+		}
+		return a
+	}
+	p.SubjectCNRegexes = addStartEndToArray(cp.SubjectCNRegexes)
+	p.SubjectOURegexes = addStartEndToArray(cp.SubjectOURegexes)
+	p.SubjectCRegexes = addStartEndToArray(cp.SubjectCRegexes)
+	p.SubjectSTRegexes = addStartEndToArray(cp.SubjectSTRegexes)
+	p.SubjectLRegexes = addStartEndToArray(cp.SubjectLRegexes)
+	p.SubjectORegexes = addStartEndToArray(cp.SubjectORegexes)
+	p.DnsSanRegExs = addStartEndToArray(cp.SANRegexes)
+	p.AllowKeyReuse = cp.KeyReuse
+	allowWildCards := false
+	for _, s := range p.SubjectCNRegexes {
+		if strings.HasPrefix(s, "^.*") {
+			allowWildCards = true
+		}
+	}
+	if !allowWildCards {
+		for _, s := range p.DnsSanRegExs {
+			if strings.HasPrefix(s, "^.*") {
+				allowWildCards = true
+			}
+		}
+	}
+	p.AllowWildcards = allowWildCards
+	for _, kt := range cp.KeyTypes {
+		keyConfiguration := endpoint.AllowedKeyConfiguration{}
+		if err := keyConfiguration.KeyType.Set(string(kt.KeyType)); err != nil {
+			panic(err)
+		}
+		keyConfiguration.KeySizes = kt.KeyLengths[:]
+		p.AllowedKeyConfigurations = append(p.AllowedKeyConfigurations, keyConfiguration)
+	}
+	return
+}
+
+func isNotRegexp(s string) bool {
+	matched, err := regexp.MatchString(`[a-zA-Z0-9 ]+`, s)
+	if !matched || err != nil {
+		return false
+	}
+	return true
+}
+func (cp certificatePolicy) toZoneConfig(zc *endpoint.ZoneConfiguration) {
+	if len(cp.SubjectCRegexes) > 0 && isNotRegexp(cp.SubjectCRegexes[0]) {
+		zc.Country = cp.SubjectCRegexes[0]
+	}
+	if len(cp.SubjectORegexes) > 0 && isNotRegexp(cp.SubjectORegexes[0]) {
+		zc.Organization = cp.SubjectORegexes[0]
+	}
+	if len(cp.SubjectSTRegexes) > 0 && isNotRegexp(cp.SubjectSTRegexes[0]) {
+		zc.Province = cp.SubjectSTRegexes[0]
+	}
+	if len(cp.SubjectLRegexes) > 0 && isNotRegexp(cp.SubjectLRegexes[0]) {
+		zc.Locality = cp.SubjectLRegexes[0]
+	}
+	for _, ou := range cp.SubjectOURegexes {
+		if isNotRegexp(ou) {
+			zc.OrganizationalUnit = append(zc.OrganizationalUnit, ou)
+		}
+	}
+}
 
 /*
 "signatureAlgorithm":{"type":"string","enum":["MD2_WITH_RSA_ENCRYPTION","MD5_WITH_RSA_ENCRYPTION","SHA1_WITH_RSA_ENCRYPTION","SHA1_WITH_RSA_ENCRYPTION2","SHA256_WITH_RSA_ENCRYPTION","SHA384_WITH_RSA_ENCRYPTION","SHA512_WITH_RSA_ENCRYPTION","ID_DSA_WITH_SHA1","dsaWithSHA1","EC_DSA_WITH_SHA1","EC_DSA_WITH_SHA224","EC_DSA_WITH_SHA256","EC_DSA_WITH_SHA384","EC_DSA_WITH_SHA512","UNKNOWN","SHA1_WITH_RSAandMGF1","GOST_R3411_94_WITH_GOST_R3410_2001","GOST_R3411_94_WITH_GOST_R3410_94"]},
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/cloud.go b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/cloud.go
index 2bcd1d7e5..8538d89c1 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/cloud.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/cloud.go
@@ -17,15 +17,19 @@
 package cloud
 
 import (
+	"bytes"
+	"crypto/sha1"
 	"encoding/json"
-	"encoding/pem"
 	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
-	"github.com/Venafi/vcert/pkg/endpoint"
+	"io"
+	"io/ioutil"
+	"log"
 	"net/http"
-	"regexp"
 	"strings"
 	"time"
+
+	"github.com/Venafi/vcert/pkg/certificate"
+	"github.com/Venafi/vcert/pkg/endpoint"
 )
 
 type apiKey struct {
@@ -93,13 +97,49 @@ type CertificateStatusErrorInformation struct {
 	Args    []string `json:"args,omitempty"`
 }
 
+type importRequestEndpointCert struct {
+	Certificate string `json:"certificate"`
+	Fingerprint string `json:"fingerprint"`
+}
+
+type importRequestEndpointProtocol struct {
+	Certificates []string      `json:"certificates"`
+	Ciphers      []interface{} `json:"ciphers"` //todo: check type
+	Protocol     string        `json:"protocol"`
+}
+
+type importRequestEndpoint struct {
+	Alpn                bool                            `json:"alpn"`
+	Certificates        []importRequestEndpointCert     `json:"certificates"`
+	ClientRenegotiation bool                            `json:"clientRenegotiation"`
+	Drown               bool                            `json:"drown"`
+	Heartbleed          bool                            `json:"heartbleed"`
+	Host                string                          `json:"host"`
+	HSTS                bool                            `json:"hsts"`
+	IP                  string                          `json:"ip"`
+	LogJam              int                             `json:"logJam"`
+	Npn                 bool                            `json:"npn"`
+	OCSP                int                             `json:"ocsp"` //default 1
+	Poodle              bool                            `json:"poodle"`
+	PoodleTls           bool                            `json:"poodleTls"`
+	Port                int                             `json:"port"`
+	Protocols           []importRequestEndpointProtocol `json:"protocols"`
+	SecureRenegotiation bool                            `json:"secureRenegotiation"`
+	Sloth               bool                            `json:"sloth"`
+}
+
+type importRequest struct {
+	ZoneName  string                  `json:"zoneName"`
+	NetworkID string                  `json:"networkId"`
+	Endpoints []importRequestEndpoint `json:"endpoints"`
+}
+
 //GenerateRequest generates a CertificateRequest based on the zone configuration, and returns the request along with the private key.
 func (c *Connector) GenerateRequest(config *endpoint.ZoneConfiguration, req *certificate.Request) (err error) {
 	switch req.CsrOrigin {
 	case certificate.LocalGeneratedCSR:
-		var pk interface{}
 		if config == nil {
-			config, err = c.ReadZoneConfiguration(c.zone)
+			config, err = c.ReadZoneConfiguration()
 			if err != nil {
 				return fmt.Errorf("could not read zone configuration: %s", err)
 			}
@@ -109,33 +149,18 @@ func (c *Connector) GenerateRequest(config *endpoint.ZoneConfiguration, req *cer
 			return err
 		}
 		config.UpdateCertificateRequest(req)
-		switch req.KeyType {
-		case certificate.KeyTypeECDSA:
-			pk, err = certificate.GenerateECDSAPrivateKey(req.KeyCurve)
-		case certificate.KeyTypeRSA:
-			pk, err = certificate.GenerateRSAPrivateKey(req.KeyLength)
-		default:
-			return fmt.Errorf("Unable to generate certificate request, key type %s is not supported", req.KeyType.String())
-		}
-		if err != nil {
-			return err
-		}
-		req.PrivateKey = pk
-		err = certificate.GenerateRequest(req, pk)
-		if err != nil {
+		if err := req.GeneratePrivateKey(); err != nil {
 			return err
 		}
-		req.CSR = pem.EncodeToMemory(certificate.GetCertificateRequestPEMBlock(req.CSR))
-		return nil
-
+		err = req.GenerateCSR()
+		return
 	case certificate.UserProvidedCSR:
-		if req.CSR == nil || len(req.CSR) == 0 {
+		if len(req.GetCSR()) == 0 {
 			return fmt.Errorf("CSR was supposed to be provided by user, but it's empty")
 		}
 		return nil
 
 	case certificate.ServiceGeneratedCSR:
-		req.CSR = nil
 		return nil
 
 	default:
@@ -143,30 +168,66 @@ func (c *Connector) GenerateRequest(config *endpoint.ZoneConfiguration, req *cer
 	}
 }
 
-//SetBaseURL allows overriding the default URL used to communicate with Venafi Cloud
-func (c *Connector) SetBaseURL(url string) error {
-	if url == "" {
-		return fmt.Errorf("base URL cannot be empty")
+func (c *Connector) getURL(resource urlResource) string {
+	return fmt.Sprintf("%s%s", c.baseURL, resource)
+}
+
+func (c *Connector) request(method string, url string, data interface{}, authNotRequired ...bool) (statusCode int, statusText string, body []byte, err error) {
+	if c.user == nil || c.user.Company == nil {
+		if !(len(authNotRequired) == 1 && authNotRequired[0]) {
+			err = fmt.Errorf("Must be autheticated to retieve certificate")
+			return
+		}
 	}
-	modified := strings.ToLower(url)
-	reg := regexp.MustCompile("^http(|s)://")
-	if reg.FindStringIndex(modified) == nil {
-		modified = "https://" + modified
-	} else {
-		modified = reg.ReplaceAllString(modified, "https://")
+
+	var payload io.Reader
+	var b []byte
+	if method == "POST" {
+		b, _ = json.Marshal(data)
+		payload = bytes.NewReader(b)
 	}
-	reg = regexp.MustCompile("/v1(|/)$")
-	if reg.FindStringIndex(modified) == nil {
-		modified += "v1/"
+
+	r, err := http.NewRequest(method, url, payload)
+	if err != nil {
+		return
+	}
+	if c.apiKey != "" {
+		r.Header.Add("tppl-api-key", c.apiKey)
+	}
+	if method == "POST" {
+		r.Header.Add("Accept", "application/json")
+		r.Header.Add("content-type", "application/json")
 	} else {
-		modified = reg.ReplaceAllString(modified, "/v1/")
+		r.Header.Add("Accept", "*/*")
 	}
-	c.baseURL = modified
-	return nil
-}
+	r.Header.Add("cache-control", "no-cache")
 
-func (c *Connector) getURL(resource urlResource) string {
-	return fmt.Sprintf("%s%s", c.baseURL, resource)
+	res, err := http.DefaultClient.Do(r)
+	if res != nil {
+		statusCode = res.StatusCode
+		statusText = res.Status
+	}
+	if err != nil {
+		return
+	}
+
+	defer res.Body.Close()
+	body, err = ioutil.ReadAll(res.Body)
+	// Do not enable trace in production
+	trace := false // IMPORTANT: sensitive information can be diclosured
+	// I hope you know what are you doing
+	if trace {
+		log.Println("#################")
+		if method == "POST" {
+			log.Printf("JSON sent for %s\n%s\n", url, string(b))
+		} else {
+			log.Printf("%s request sent to %s\n", method, url)
+		}
+		log.Printf("Response:\n%s\n", string(body))
+	} else if c.verbose {
+		log.Printf("Got %s status for %s %s\n", statusText, method, url)
+	}
+	return
 }
 
 func parseUserDetailsResult(expectedStatusCode int, httpStatusCode int, httpStatus string, body []byte) (*userDetails, error) {
@@ -350,3 +411,8 @@ func parseCertificateRequestData(b []byte) (*certificateRequestResponse, error)
 func newPEMCollectionFromResponse(data []byte, chainOrder certificate.ChainOption) (*certificate.PEMCollection, error) {
 	return certificate.PEMCollectionFromBytes(data, chainOrder)
 }
+
+func certThumprint(asn1 []byte) string {
+	h := sha1.Sum(asn1)
+	return strings.ToUpper(fmt.Sprintf("%x", h))
+}
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/company.go b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/company.go
index 6f5661579..bb8c8909a 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/company.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/company.go
@@ -17,8 +17,6 @@
 package cloud
 
 import (
-	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
 	"github.com/Venafi/vcert/pkg/endpoint"
 	"time"
 )
@@ -41,7 +39,7 @@ type zone struct {
 	CertificatePolicyIDs             certificatePolicyID `json:"certificatePolicyIds,omitempty"`
 	DefaultCertificateIdentityPolicy string              `json:"defaultCertificateIdentityPolicyId,omitempty"`
 	DefaultCertificateUsePolicy      string              `json:"defaultCertificateUsePolicyId,omitempty"`
-	SystemGenerated                  bool                `json:"systemGeneratedate,omitempty"`
+	SystemGenerated                  bool                `json:"systemGenerated,omitempty"`
 	CreationDateString               string              `json:"creationDate,omitempty"`
 	CreationDate                     time.Time           `json:"-"`
 }
@@ -51,24 +49,14 @@ type certificatePolicyID struct {
 	CertificateUse      []string `json:"CERTIFICATE_USE,omitempty"`
 }
 
-func (z *zone) GetZoneConfiguration(ud *userDetails, policy *certificatePolicy) *endpoint.ZoneConfiguration {
-	zoneConfig := endpoint.ZoneConfiguration{}
-
-	if policy != nil {
-		if policy.KeyTypes != nil {
-			certKeyType := certificate.KeyTypeRSA
-			for _, kt := range policy.KeyTypes {
-				certKeyType.Set(fmt.Sprintf("%s", kt.KeyType))
-				keyConfiguration := endpoint.AllowedKeyConfiguration{}
-				keyConfiguration.KeyType = certKeyType
-				for _, size := range kt.KeyLengths {
-					keyConfiguration.KeySizes = append(keyConfiguration.KeySizes, size)
-				}
-				zoneConfig.AllowedKeyConfigurations = append(zoneConfig.AllowedKeyConfigurations, keyConfiguration)
-			}
-		}
+func (z *zone) getZoneConfiguration(ud *userDetails, policy *certificatePolicy) (zoneConfig *endpoint.ZoneConfiguration) {
+	zoneConfig = endpoint.NewZoneConfiguration()
+	if policy == nil {
+		return
 	}
-	return &zoneConfig
+	zoneConfig.Policy = policy.toPolicy()
+	policy.toZoneConfig(zoneConfig)
+	return
 }
 
 const (
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/connector.go b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/connector.go
index 0c2fa481a..097a08e25 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/connector.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/connector.go
@@ -17,17 +17,18 @@
 package cloud
 
 import (
-	"bytes"
 	"crypto/x509"
+	"encoding/base64"
 	"encoding/json"
+	"encoding/pem"
 	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
-	"github.com/Venafi/vcert/pkg/endpoint"
-	"io/ioutil"
-	"log"
 	"net/http"
+	"regexp"
 	"strings"
 	"time"
+
+	"github.com/Venafi/vcert/pkg/certificate"
+	"github.com/Venafi/vcert/pkg/endpoint"
 )
 
 const apiURL = "api.venafi.cloud/v1/"
@@ -35,26 +36,29 @@ const apiURL = "api.venafi.cloud/v1/"
 type urlResource string
 
 const (
-	urlResourceUserAccounts           urlResource = "useraccounts"
-	urlResourcePing                               = "ping"
-	urlResourceZones                              = "zones"
-	urlResourceZoneByTag                          = urlResourceZones + "/tag/%s"
-	urlResourceCertificatePolicies                = "certificatepolicies"
-	urlResourcePoliciesByID                       = urlResourceCertificatePolicies + "%s"
-	urlResourcePoliciesForZoneByID                = urlResourceCertificatePolicies + "?zoneId=%s"
-	urlResourceCertificateRequests                = "certificaterequests"
-	urlResourceCertificateStatus                  = urlResourceCertificateRequests + "/%s"
-	urlResourceCertificateRetrieve                = urlResourceCertificateRequests + "/%s/certificate"
-	urlResourceCertificateSearch                  = "certificatesearch"
-	urlResourceManagedCertificates                = "managedcertificates"
-	urlResourceManagedCertificateById             = urlResourceManagedCertificates + "/%s"
+	urlResourceUserAccounts              urlResource = "useraccounts"
+	urlResourcePing                                  = "ping"
+	urlResourceZones                                 = "zones"
+	urlResourceZoneByTag                             = urlResourceZones + "/tag/%s"
+	urlResourceCertificatePolicies                   = "certificatepolicies"
+	urlResourcePoliciesByID                          = urlResourceCertificatePolicies + "/%s"
+	urlResourcePoliciesForZoneByID                   = urlResourceCertificatePolicies + "?zoneId=%s"
+	urlResourceCertificateRequests                   = "certificaterequests"
+	urlResourceCertificateStatus                     = urlResourceCertificateRequests + "/%s"
+	urlResourceCertificateRetrieveViaCSR             = urlResourceCertificateRequests + "/%s/certificate"
+	urlResourceCertificateRetrieve                   = "certificates/%s"
+	urlResourceCertificateRetrievePem                = urlResourceCertificateRetrieve + "/encoded"
+	urlResourceCertificateSearch                     = "certificatesearch"
+	urlResourceManagedCertificates                   = "managedcertificates"
+	urlResourceManagedCertificateByID                = urlResourceManagedCertificates + "/%s"
+	urlResourceDiscovery                             = "discovery"
 )
 
 type condorChainOption string
 
 const (
 	condorChainOptionRootFirst condorChainOption = "ROOT_FIRST"
-	condorChainOptionRootLast                    = "EE_FIRST"
+	condorChainOptionRootLast  condorChainOption = "EE_FIRST"
 )
 
 // Connector contains the base data needed to communicate with the Venafi Cloud servers
@@ -68,10 +72,37 @@ type Connector struct {
 }
 
 // NewConnector creates a new Venafi Cloud Connector object used to communicate with Venafi Cloud
-func NewConnector(verbose bool, trust *x509.CertPool) *Connector {
-	c := Connector{verbose: verbose, trust: trust}
-	c.SetBaseURL(apiURL)
-	return &c
+func NewConnector(url string, zone string, verbose bool, trust *x509.CertPool) (*Connector, error) {
+	c := Connector{verbose: verbose, trust: trust, zone: zone}
+	var err error
+	c.baseURL, err = normalizeURL(url)
+	if err != nil {
+		return nil, err
+	}
+	return &c, nil
+}
+
+//normalizeURL allows overriding the default URL used to communicate with Venafi Cloud
+func normalizeURL(url string) (normalizedURL string, err error) {
+	if url == "" {
+		url = apiURL
+		//return "", fmt.Errorf("base URL cannot be empty")
+	}
+	modified := strings.ToLower(url)
+	reg := regexp.MustCompile("^http(|s)://")
+	if reg.FindStringIndex(modified) == nil {
+		modified = "https://" + modified
+	} else {
+		modified = reg.ReplaceAllString(modified, "https://")
+	}
+	reg = regexp.MustCompile("/v1(|/)$")
+	if reg.FindStringIndex(modified) == nil {
+		modified += "v1/"
+	} else {
+		modified = reg.ReplaceAllString(modified, "/v1/")
+	}
+	normalizedURL = modified
+	return normalizedURL, nil
 }
 
 func (c *Connector) SetZone(z string) {
@@ -82,108 +113,59 @@ func (c *Connector) GetType() endpoint.ConnectorType {
 	return endpoint.ConnectorTypeCloud
 }
 
-//Ping attempts to connect to the Venafi Cloud API and returns an errror if it cannot
+// Ping attempts to connect to the Venafi Cloud API and returns an errror if it cannot
 func (c *Connector) Ping() (err error) {
-	url := c.getURL(urlResourcePing)
 
-	resp, err := http.Get(url)
-	if err != nil {
-		return err
-	}
-	if resp.StatusCode != http.StatusOK {
-		err = fmt.Errorf("Unexpected status code on Venafi Cloud ping. Status: %d %s", resp.StatusCode, resp.Status)
-	}
-	return err
+	return nil
 }
 
-//Authenticate authenticates the user with Venafi Cloud using the provided API Key
+// Authenticate authenticates the user with Venafi Cloud using the provided API Key
 func (c *Connector) Authenticate(auth *endpoint.Authentication) (err error) {
 	if auth == nil {
 		return fmt.Errorf("failed to authenticate: missing credentials")
 	}
 	c.apiKey = auth.APIKey
 	url := c.getURL(urlResourceUserAccounts)
-	b := []byte{}
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("GET", url, reader)
-	if err != nil {
-		return err
-	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	resp, err := http.DefaultClient.Do(request)
-	if err != nil {
-		return err
-	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
+	statusCode, status, body, err := c.request("GET", url, nil, true)
 	if err != nil {
 		return err
 	}
-
-	ud, err := parseUserDetailsResult(http.StatusOK, resp.StatusCode, resp.Status, body)
+	ud, err := parseUserDetailsResult(http.StatusOK, statusCode, status, body)
 	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
-		}
-
-		return err
+		return
 	}
 	c.user = ud
-	return nil
+	return
 }
 
-//Register registers a new user with Venafi Cloud
-func (c *Connector) Register(email string) (err error) {
-	b, err := json.Marshal(userAccount{Username: email, UserAccountType: "API"})
-
-	url := c.getURL(urlResourceUserAccounts)
-
-	reader := bytes.NewReader(b)
-	resp, err := http.Post(url, "application/json", reader)
+func (c *Connector) ReadPolicyConfiguration() (policy *endpoint.Policy, err error) {
+	config, err := c.ReadZoneConfiguration()
 	if err != nil {
-		return err
-	}
-	defer resp.Body.Close()
-
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return err
-	}
-
-	//the user has already been registered and there is nothing to parse
-	if resp.StatusCode == http.StatusAccepted {
-		return nil
-	}
-	ud, err := parseUserDetailsResult(http.StatusCreated, resp.StatusCode, resp.Status, body)
-	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
-		}
-
-		return err
+		return nil, err
 	}
-	c.user = ud
-	return nil
+	policy = &config.Policy
+	return
 }
 
-//ReadZoneConfiguration reads the Zone information needed for generating and requesting a certificate from Venafi Cloud
-func (c *Connector) ReadZoneConfiguration(zone string) (config *endpoint.ZoneConfiguration, err error) {
-	z, err := c.getZoneByTag(zone)
+// ReadZoneConfiguration reads the Zone information needed for generating and requesting a certificate from Venafi Cloud
+func (c *Connector) ReadZoneConfiguration() (config *endpoint.ZoneConfiguration, err error) {
+	if c.zone == "" {
+		return nil, fmt.Errorf("empty zone name")
+	}
+	z, err := c.getZoneByTag(c.zone)
 	if err != nil {
 		return nil, err
 	}
 	p, err := c.getPoliciesByID([]string{z.DefaultCertificateIdentityPolicy, z.DefaultCertificateUsePolicy})
-	config = z.GetZoneConfiguration(c.user, p)
+	if err != nil {
+		return
+	}
+	config = z.getZoneConfiguration(c.user, p)
 	return config, nil
 }
 
-//RequestCertificate submits the CSR to the Venafi Cloud API for processing
-func (c *Connector) RequestCertificate(req *certificate.Request, zone string) (requestID string, err error) {
-
-	if zone == "" {
-		zone = c.zone
-	}
-
+// RequestCertificate submits the CSR to the Venafi Cloud API for processing
+func (c *Connector) RequestCertificate(req *certificate.Request) (requestID string, err error) {
 	if req.CsrOrigin == certificate.ServiceGeneratedCSR {
 		return "", fmt.Errorf("service generated CSR is not supported by Saas service")
 	}
@@ -192,34 +174,18 @@ func (c *Connector) RequestCertificate(req *certificate.Request, zone string) (r
 	if c.user == nil || c.user.Company == nil {
 		return "", fmt.Errorf("Must be autheticated to request a certificate")
 	}
-	z, err := c.getZoneByTag(zone)
-	if err != nil {
-		return "", err
-	}
-	b, _ := json.Marshal(certificateRequest{ZoneID: z.ID, CSR: string(req.CSR)})
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("POST", url, reader)
+	z, err := c.getZoneByTag(c.zone)
 	if err != nil {
 		return "", err
 	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	request.Header.Add("content-type", "application/json")
-	resp, err := http.DefaultClient.Do(request)
-	if err != nil {
-		return "", err
-	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
+
+	statusCode, status, body, err := c.request("POST", url, certificateRequest{ZoneID: z.ID, CSR: string(req.GetCSR())})
+
 	if err != nil {
 		return "", err
 	}
-
-	cr, err := parseCertificateRequestResult(resp.StatusCode, resp.Status, body)
+	cr, err := parseCertificateRequestResult(statusCode, status, body)
 	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
-		}
-
 		return "", err
 	}
 	requestID = cr.CertificateRequests[0].ID
@@ -227,61 +193,41 @@ func (c *Connector) RequestCertificate(req *certificate.Request, zone string) (r
 	return requestID, nil
 }
 
-func (c *Connector) getCertificateStatus(requestID string) (*certificateStatus, error) {
-	var err error
+func (c *Connector) getCertificateStatus(requestID string) (certStatus *certificateStatus, err error) {
 	url := c.getURL(urlResourceCertificateStatus)
-	if c.user == nil || c.user.Company == nil {
-		err = fmt.Errorf("Must be autheticated to retieve certificate")
-		return nil, err
-	}
 	url = fmt.Sprintf(url, requestID)
-
-	b := []byte{}
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("GET", url, reader)
+	statusCode, _, body, err := c.request("GET", url, nil)
 	if err != nil {
 		return nil, err
 	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	request.Header.Add("Accept", "application/json")
-	resp, err := http.DefaultClient.Do(request)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-
-	switch resp.StatusCode {
-	case http.StatusOK:
-		var data = &certificateStatus{}
-		err = json.Unmarshal(body, data)
+	if statusCode == http.StatusOK {
+		certStatus = &certificateStatus{}
+		err = json.Unmarshal(body, certStatus)
 		if err != nil {
 			return nil, fmt.Errorf("failed to parse certificate request status response: %s", err)
 		}
-		return data, nil
-	default:
-		if body != nil {
-			respErrors, err := parseResponseErrors(body)
-			if err == nil {
-				respError := fmt.Sprintf("Unexpected status code on Venafi Cloud certificate search. Status: %d\n", resp.StatusCode)
-				for _, e := range respErrors {
-					respError += fmt.Sprintf("Error Code: %d Error: %s\n", e.Code, e.Message)
-				}
-				return nil, fmt.Errorf(respError)
-			}
+		return
+	}
+	respErrors, err := parseResponseErrors(body)
+	if err == nil {
+		respError := fmt.Sprintf("Unexpected status code on Venafi Cloud certificate search. Status: %d\n", statusCode)
+		for _, e := range respErrors {
+			respError += fmt.Sprintf("Error Code: %d Error: %s\n", e.Code, e.Message)
 		}
-		return nil, fmt.Errorf("Unexpected status code on Venafi Cloud certificate search. Status: %d", resp.StatusCode)
+		return nil, fmt.Errorf(respError)
 	}
+
+	return nil, fmt.Errorf("Unexpected status code on Venafi Cloud certificate search. Status: %d", statusCode)
+
 }
 
-//RetrieveCertificate retrieves the certificate for the specified ID
+// RetrieveCertificate retrieves the certificate for the specified ID
 func (c *Connector) RetrieveCertificate(req *certificate.Request) (certificates *certificate.PEMCollection, err error) {
 
 	if req.FetchPrivateKey {
 		return nil, fmt.Errorf("Failed to retrieve private key from Venafi Cloud service: not supported")
 	}
-
-	if req.PickupID == "" && req.Thumbprint != "" {
+	if req.PickupID == "" && req.CertID == "" && req.Thumbprint != "" {
 		// search cert by Thumbprint and fill pickupID
 		var certificateRequestId string
 		searchResult, err := c.searchCertificatesByFingerprint(req.Thumbprint)
@@ -299,7 +245,12 @@ func (c *Connector) RetrieveCertificate(req *certificate.Request) (certificates
 			if certificateRequestId != "" && certificateRequestId != c.CertificateRequestId {
 				isOnlyOneCertificateRequestId = false
 			}
-			certificateRequestId = c.CertificateRequestId
+			if c.CertificateRequestId != "" {
+				certificateRequestId = c.CertificateRequestId
+			}
+			if c.Id != "" {
+				req.CertID = c.Id
+			}
 		}
 		if !isOnlyOneCertificateRequestId {
 			return nil, fmt.Errorf("More than one CertificateRequestId was found with the same Fingerprint: %s", reqIds)
@@ -309,66 +260,78 @@ func (c *Connector) RetrieveCertificate(req *certificate.Request) (certificates
 	}
 
 	startTime := time.Now()
-	for {
-		status, err := c.getCertificateStatus(req.PickupID)
-		if err != nil {
-			return nil, fmt.Errorf("unable to retrieve: %s", err)
-		}
-		if status.Status == "ISSUED" {
-			break // to fetch the cert itself
-		} else if status.Status == "FAILED" {
-			return nil, fmt.Errorf("Failed to retrieve certificate. Status: %v", status)
-		}
-		// status.Status == "REQUESTED" || status.Status == "PENDING"
-		if req.Timeout == 0 {
-			return nil, endpoint.ErrCertificatePending{CertificateID: req.PickupID, Status: status.Status}
-		}
-		if time.Now().After(startTime.Add(req.Timeout)) {
-			return nil, endpoint.ErrRetrieveCertificateTimeout{CertificateID: req.PickupID}
+	//Wait for certificate to be issued by checking it's PickupID
+	//If certID is filled then certificate should be already issued.
+	if req.CertID == "" {
+		for {
+			if req.PickupID == "" {
+				break
+			}
+			status, err := c.getCertificateStatus(req.PickupID)
+			if err != nil {
+				return nil, fmt.Errorf("unable to retrieve: %s", err)
+			}
+			if status.Status == "ISSUED" {
+				break // to fetch the cert itself
+			} else if status.Status == "FAILED" {
+				return nil, fmt.Errorf("Failed to retrieve certificate. Status: %v", status)
+			}
+			// status.Status == "REQUESTED" || status.Status == "PENDING"
+			if req.Timeout == 0 {
+				return nil, endpoint.ErrCertificatePending{CertificateID: req.PickupID, Status: status.Status}
+			}
+			if time.Now().After(startTime.Add(req.Timeout)) {
+				return nil, endpoint.ErrRetrieveCertificateTimeout{CertificateID: req.PickupID}
+			}
+			// fmt.Printf("pending... %s\n", status.Status)
+			time.Sleep(2 * time.Second)
 		}
-		// fmt.Printf("pending... %s\n", status.Status)
-		time.Sleep(2 * time.Second)
 	}
 
-	url := c.getURL(urlResourceCertificateRetrieve)
 	if c.user == nil || c.user.Company == nil {
 		return nil, fmt.Errorf("Must be autheticated to retieve certificate")
 	}
-	url = fmt.Sprintf(url, req.PickupID)
-	url += "?chainOrder=%s&format=PEM"
-	switch req.ChainOption {
-	case certificate.ChainOptionRootFirst:
-		url = fmt.Sprintf(url, condorChainOptionRootFirst)
-	default:
-		url = fmt.Sprintf(url, condorChainOptionRootLast)
-	}
-	b := []byte{}
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("GET", url, reader)
-	if err != nil {
-		return nil, err
-	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	request.Header.Add("Accept", "text/plain")
-	resp, err := http.DefaultClient.Do(request)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return nil, err
-	}
-	if resp.StatusCode == http.StatusOK {
-		return newPEMCollectionFromResponse(body, req.ChainOption)
-	} else if resp.StatusCode == http.StatusConflict { // Http Status Code 409 means the certificate has not been signed by the ca yet.
-		return nil, endpoint.ErrCertificatePending{CertificateID: req.PickupID}
-	} else {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
+
+	switch {
+	case req.CertID != "":
+		url := c.getURL(urlResourceCertificateRetrievePem)
+		url = fmt.Sprintf(url, req.CertID)
+		statusCode, status, body, err := c.request("GET", url, nil)
+		if err != nil {
+			return nil, err
+		}
+		if statusCode != http.StatusOK {
+			return nil, fmt.Errorf("Failed to retrieve certificate. StatusCode: %d -- Status: %s -- Server Data: %s", statusCode, status, body)
+		}
+		return newPEMCollectionFromResponse(body, certificate.ChainOptionIgnore)
+	case req.PickupID != "":
+		url := c.getURL(urlResourceCertificateRetrieveViaCSR)
+		url = fmt.Sprintf(url, req.PickupID)
+		url += "?chainOrder=%s&format=PEM"
+		switch req.ChainOption {
+		case certificate.ChainOptionRootFirst:
+			url = fmt.Sprintf(url, condorChainOptionRootFirst)
+		default:
+			url = fmt.Sprintf(url, condorChainOptionRootLast)
+		}
+		statusCode, status, body, err := c.request("GET", url, nil)
+		if err != nil {
+			return nil, err
+		}
+		if statusCode == http.StatusOK {
+			certificates, err = newPEMCollectionFromResponse(body, req.ChainOption)
+			if err != nil {
+				return nil, err
+			}
+			err = req.CheckCertificate(certificates.Certificate)
+			return certificates, err
+		} else if statusCode == http.StatusConflict { // Http Status Code 409 means the certificate has not been signed by the ca yet.
+			return nil, endpoint.ErrCertificatePending{CertificateID: req.PickupID}
+		} else {
+			return nil, fmt.Errorf("Failed to retrieve certificate. StatusCode: %d -- Status: %s -- Server Data: %s", statusCode, status, body) //todo:remove body from err
 		}
-		return nil, fmt.Errorf("Failed to retrieve certificate. StatusCode: %d -- Status: %s -- Server Data: %s", resp.StatusCode, resp.Status, body)
 	}
+	return nil, fmt.Errorf("Couldn't retrieve certificate because both PickupID and CertId are empty")
 }
 
 // RevokeCertificate attempts to revoke the certificate
@@ -423,7 +386,7 @@ func (c *Connector) RenewCertificate(renewReq *certificate.RenewalRequest) (requ
 		return "", fmt.Errorf("failed to submit renewal request for certificate: ManagedCertificateId is empty, certificate status is %s", previousRequest.Status)
 	}
 
-	if managedCertificateId == "" {
+	if zoneId == "" {
 		return "", fmt.Errorf("failed to submit renewal request for certificate: ZoneId is empty, certificate status is %s", previousRequest.Status)
 	}
 
@@ -451,40 +414,20 @@ func (c *Connector) RenewCertificate(renewReq *certificate.RenewalRequest) (requ
 		return "", fmt.Errorf("Must be autheticated to request a certificate")
 	}
 
-	req := certificateRequest{
-		ZoneID: zoneId,
-		ExistingManagedCertificateId: managedCertificateId,
-	}
-	if renewReq.CertificateRequest != nil && 0 < len(renewReq.CertificateRequest.CSR) {
-		req.CSR = string(renewReq.CertificateRequest.CSR)
+	req := certificateRequest{ZoneID: zoneId, ExistingManagedCertificateId: managedCertificateId}
+	if renewReq.CertificateRequest != nil && len(renewReq.CertificateRequest.GetCSR()) != 0 {
+		req.CSR = string(renewReq.CertificateRequest.GetCSR())
 		req.ReuseCSR = false
 	} else {
 		req.ReuseCSR = true
 	}
-	b, _ := json.Marshal(req)
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("POST", url, reader)
+	statusCode, status, body, err := c.request("POST", url, req)
 	if err != nil {
-		return "", err
-	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	request.Header.Add("content-type", "application/json")
-	resp, err := http.DefaultClient.Do(request)
-	if err != nil {
-		return "", err
-	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return "", err
+		return
 	}
 
-	cr, err := parseCertificateRequestResult(resp.StatusCode, resp.Status, body)
+	cr, err := parseCertificateRequestResult(statusCode, status, body)
 	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
-		}
-
 		return "", fmt.Errorf("Failed to renew certificate: %s", err)
 	}
 	return cr.CertificateRequests[0].ID, nil
@@ -496,65 +439,33 @@ func (c *Connector) getZoneByTag(tag string) (*zone, error) {
 		return nil, fmt.Errorf("Must be autheticated to read the zone configuration")
 	}
 	url = fmt.Sprintf(url, tag)
-	b := []byte{}
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("GET", url, reader)
+	statusCode, status, body, err := c.request("GET", url, nil)
 	if err != nil {
 		return nil, err
 	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	resp, err := http.DefaultClient.Do(request)
+	z, err := parseZoneConfigurationResult(statusCode, status, body)
 	if err != nil {
 		return nil, err
 	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return nil, err
-	}
-	z, err := parseZoneConfigurationResult(resp.StatusCode, resp.Status, body)
-	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
-		}
-
-		return nil, err
-	}
 	return z, nil
 }
 
 func (c *Connector) getPoliciesByID(ids []string) (*certificatePolicy, error) {
 	policy := new(certificatePolicy)
-	url := c.getURL(urlResourcePoliciesByID)
 	if c.user == nil {
 		return nil, fmt.Errorf("Must be autheticated to read the zone configuration")
 	}
 	for _, id := range ids {
+		url := c.getURL(urlResourcePoliciesByID)
 		url = fmt.Sprintf(url, id)
-		b := []byte{}
-		reader := bytes.NewReader(b)
-		request, err := http.NewRequest("GET", url, reader)
-		if err != nil {
-			return nil, err
-		}
-		request.Header.Add("tppl-api-key", c.apiKey)
-		resp, err := http.DefaultClient.Do(request)
+		statusCode, status, body, err := c.request("GET", url, nil)
 		if err != nil {
 			return nil, err
 		}
-		defer resp.Body.Close()
-		body, err := ioutil.ReadAll(resp.Body)
+		p, err := parseCertificatePolicyResult(statusCode, status, body)
 		if err != nil {
 			return nil, err
 		}
-		p, err := parseCertificatePolicyResult(resp.StatusCode, resp.Status, body)
-		if err != nil {
-			if c.verbose {
-				log.Printf("JSON sent for %s\n%s", url, b)
-			}
-
-			return nil, err
-		}
 		switch p.CertificatePolicyType {
 		case certificatePolicyTypeIdentity:
 			policy.SubjectCNRegexes = p.SubjectCNRegexes
@@ -564,11 +475,9 @@ func (c *Connector) getPoliciesByID(ids []string) (*certificatePolicy, error) {
 			policy.SubjectLRegexes = p.SubjectLRegexes
 			policy.SubjectCRegexes = p.SubjectCRegexes
 			policy.SANRegexes = p.SANRegexes
-			break
 		case certificatePolicyTypeUse:
 			policy.KeyTypes = p.KeyTypes
 			policy.KeyReuse = p.KeyReuse
-			break
 		}
 	}
 	return policy, nil
@@ -579,36 +488,11 @@ func (c *Connector) searchCertificates(req *SearchRequest) (*CertificateSearchRe
 	var err error
 
 	url := c.getURL(urlResourceCertificateSearch)
-	if c.user == nil || c.user.Company == nil {
-		err = fmt.Errorf("Must be autheticated")
-		return nil, err
-	}
-
-	b, _ := json.Marshal(req)
-	reader := bytes.NewReader(b)
-	request, err := http.NewRequest("POST", url, reader)
-	if err != nil {
-		return nil, err
-	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	request.Header.Add("content-type", "application/json")
-	request.Header.Add("accept", "application/json")
-
-	resp, err := http.DefaultClient.Do(request)
+	statusCode, _, body, err := c.request("POST", url, req)
 	if err != nil {
 		return nil, err
 	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return nil, err
-	}
-	if c.verbose {
-		fmt.Printf("REQ: %s\n", b)
-		fmt.Printf("RES: %s\n", body)
-	}
-
-	searchResult, err := ParseCertificateSearchResponse(resp.StatusCode, body)
+	searchResult, err := ParseCertificateSearchResponse(statusCode, body)
 	if err != nil {
 		return nil, err
 	}
@@ -653,35 +537,14 @@ type managedCertificate struct {
 
 func (c *Connector) getManagedCertificate(managedCertId string) (*managedCertificate, error) {
 	var err error
-	url := c.getURL(urlResourceManagedCertificateById)
+	url := c.getURL(urlResourceManagedCertificateByID)
 	url = fmt.Sprintf(url, managedCertId)
-	if c.user == nil || c.user.Company == nil {
-		err = fmt.Errorf("Must be autheticated")
-		return nil, err
-	}
-
-	request, err := http.NewRequest("GET", url, nil)
+	statusCode, _, body, err := c.request("GET", url, nil)
 	if err != nil {
 		return nil, err
 	}
-	request.Header.Add("tppl-api-key", c.apiKey)
-	request.Header.Add("accept", "application/json")
 
-	resp, err := http.DefaultClient.Do(request)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return nil, err
-	}
-	if c.verbose {
-		fmt.Printf("REQ: %s\n", url)
-		fmt.Printf("RES: %s\n", body)
-	}
-
-	switch resp.StatusCode {
+	switch statusCode {
 	case http.StatusOK:
 		var res = &managedCertificate{}
 		err = json.Unmarshal(body, res)
@@ -693,18 +556,75 @@ func (c *Connector) getManagedCertificate(managedCertId string) (*managedCertifi
 		if body != nil {
 			respErrors, err := parseResponseErrors(body)
 			if err == nil {
-				respError := fmt.Sprintf("Unexpected status code on Venafi Cloud certificate search. Status: %d\n", resp.StatusCode)
+				respError := fmt.Sprintf("Unexpected status code on Venafi Cloud certificate search. Status: %d\n", statusCode)
 				for _, e := range respErrors {
 					respError += fmt.Sprintf("Error Code: %d Error: %s\n", e.Code, e.Message)
 				}
 				return nil, fmt.Errorf(respError)
 			}
 		}
-		return nil, fmt.Errorf("Unexpected status code on Venafi Cloud certificate search. Status: %d", resp.StatusCode)
+		return nil, fmt.Errorf("Unexpected status code on Venafi Cloud certificate search. Status: %d", statusCode)
 	}
 
 }
 
 func (c *Connector) ImportCertificate(req *certificate.ImportRequest) (*certificate.ImportResponse, error) {
-	return nil, fmt.Errorf("import is not supported")
+	pBlock, _ := pem.Decode([]byte(req.CertificateData))
+	if pBlock == nil {
+		return nil, fmt.Errorf("can`t parse certificate")
+	}
+	zone := req.PolicyDN
+	if zone == "" {
+		zone = c.zone
+	}
+	base64.StdEncoding.EncodeToString(pBlock.Bytes)
+	fingerprint := certThumprint(pBlock.Bytes)
+	e := importRequestEndpoint{
+		OCSP: 1,
+		Certificates: []importRequestEndpointCert{
+			{
+				Certificate: base64.StdEncoding.EncodeToString(pBlock.Bytes),
+				Fingerprint: fingerprint,
+			},
+		},
+		Protocols: []importRequestEndpointProtocol{
+			{
+				Certificates: []string{fingerprint},
+			},
+		},
+	}
+	request := importRequest{
+		ZoneName:  zone,
+		Endpoints: []importRequestEndpoint{e},
+	}
+
+	url := c.getURL(urlResourceDiscovery)
+	statusCode, status, body, err := c.request("POST", url, request)
+	if err != nil {
+		return nil, err
+	}
+	var r struct {
+		CreatedCertificates int
+		CreatedInstances    int
+		UpdatedCertificates int
+		UpdatedInstances    int
+	}
+	err = json.Unmarshal(body, &r)
+	if statusCode != http.StatusCreated {
+		return nil, fmt.Errorf("bad server status responce %d %s", statusCode, status)
+	} else if err != nil {
+		return nil, fmt.Errorf("can`t unmarshal json response %s", err)
+	} else if !(r.CreatedCertificates == 1 || r.UpdatedCertificates == 1) {
+		return nil, fmt.Errorf("certificate was not imported on unknown reason")
+	}
+	foundCert, err := c.searchCertificatesByFingerprint(fingerprint)
+	if err != nil {
+		return nil, err
+	}
+	if len(foundCert.Certificates) != 1 {
+		return nil, fmt.Errorf("certificate has been imported but could not be found on platform after that")
+	}
+	cert := foundCert.Certificates[0]
+	resp := &certificate.ImportResponse{CertificateDN: cert.SubjectCN[0], CertId: cert.Id}
+	return resp, nil
 }
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/search.go b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/search.go
index 500289768..599acd6bb 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/search.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/cloud/search.go
@@ -50,13 +50,13 @@ type Paging struct {
 
 const (
 	EQ    Operator = "EQ"
-	FIND           = "FIND"
-	GT             = "GT"
-	GTE            = "GTE"
-	IN             = "IN"
-	LT             = "LT"
-	LTE            = "LTE"
-	MATCH          = "MATCH"
+	FIND  Operator = "FIND"
+	GT    Operator = "GT"
+	GTE   Operator = "GTE"
+	IN    Operator = "IN"
+	LT    Operator = "LT"
+	LTE   Operator = "LTE"
+	MATCH Operator = "MATCH"
 )
 
 type CertificateSearchResponse struct {
@@ -69,7 +69,7 @@ type Certificate struct {
 	ManagedCertificateId string   `json:"managedCertificateId"`
 	CertificateRequestId string   `json:"certificateRequestId"`
 	SubjectCN            []string `json:"subjectCN"`
-	/*...and many more fields... */
+	/* ... and many more fields ... */
 }
 
 func ParseCertificateSearchResponse(httpStatusCode int, body []byte) (searchResult *CertificateSearchResponse, err error) {
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/fake/connector.go b/vendor/github.com/Venafi/vcert/pkg/venafi/fake/connector.go
index 966caa68a..c12277242 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/fake/connector.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/fake/connector.go
@@ -17,17 +17,19 @@
 package fake
 
 import (
+	"crypto"
 	"crypto/rand"
 	"crypto/x509"
 	"encoding/base64"
 	"encoding/json"
 	"encoding/pem"
 	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
-	"github.com/Venafi/vcert/pkg/endpoint"
 	"math/big"
 	"strings"
 	"time"
+
+	"github.com/Venafi/vcert/pkg/certificate"
+	"github.com/Venafi/vcert/pkg/endpoint"
 )
 
 type Connector struct {
@@ -44,17 +46,12 @@ func (c *Connector) GetType() endpoint.ConnectorType {
 }
 
 func (c *Connector) SetZone(z string) {
-	return
 }
 
 func (c *Connector) Ping() (err error) {
 	return
 }
 
-func (c *Connector) Register(email string) (err error) {
-	return
-}
-
 func (c *Connector) Authenticate(auth *endpoint.Authentication) (err error) {
 	return
 }
@@ -71,8 +68,7 @@ func validateRequest(req *certificate.Request) error {
 	return nil
 }
 
-func (c *Connector) RequestCertificate(req *certificate.Request, zone string) (requestID string, err error) {
-
+func (c *Connector) RequestCertificate(req *certificate.Request) (requestID string, err error) {
 	err = validateRequest(req)
 	if err != nil {
 		return "", fmt.Errorf("certificate request validation fail: %s", err)
@@ -83,7 +79,7 @@ func (c *Connector) RequestCertificate(req *certificate.Request, zone string) (r
 	switch req.CsrOrigin {
 	case certificate.LocalGeneratedCSR, certificate.UserProvidedCSR:
 		// should return CSR as requestID payload
-		fakeRequest.CSR = base64.StdEncoding.EncodeToString(req.CSR)
+		fakeRequest.CSR = base64.StdEncoding.EncodeToString(req.GetCSR())
 
 	case certificate.ServiceGeneratedCSR:
 		// should return certificate.Request as requestID payload
@@ -114,7 +110,7 @@ func issueCertificate(csr *x509.CertificateRequest) ([]byte, error) {
 			nameSet[name] = true
 		}
 		uniqNames := []string{}
-		for name, _ := range nameSet {
+		for name := range nameSet {
 			uniqNames = append(uniqNames, name)
 		}
 		csr.DNSNames = uniqNames
@@ -159,33 +155,29 @@ func (c *Connector) RetrieveCertificate(req *certificate.Request) (pcc *certific
 	}
 
 	var csrPEMbytes []byte
-	var pk interface{}
+	var pk crypto.Signer
 
 	if fakeRequest.CSR != "" {
 		csrPEMbytes, err = base64.StdEncoding.DecodeString(fakeRequest.CSR)
+		if err != nil {
+			return nil, err
+		}
 
 	} else {
 		req := fakeRequest.Req
 
-		switch req.KeyType {
-		case certificate.KeyTypeECDSA:
-			req.PrivateKey, err = certificate.GenerateECDSAPrivateKey(req.KeyCurve)
-		case certificate.KeyTypeRSA:
-			req.PrivateKey, err = certificate.GenerateRSAPrivateKey(req.KeyLength)
-		default:
-			return nil, fmt.Errorf("Unable to generate certificate request, key type %s is not supported", req.KeyType.String())
-		}
+		err = req.GeneratePrivateKey()
 		if err != nil {
 			return
 		}
 
 		req.DNSNames = append(req.DNSNames, "fake-service-generated."+req.Subject.CommonName)
 
-		err = certificate.GenerateRequest(req, req.PrivateKey)
+		err = req.GenerateCSR()
 		if err != nil {
 			return
 		}
-		csrPEMbytes = pem.EncodeToMemory(certificate.GetCertificateRequestPEMBlock(req.CSR))
+		csrPEMbytes = req.GetCSR()
 		pk = req.PrivateKey
 	}
 
@@ -216,11 +208,17 @@ func (c *Connector) RetrieveCertificate(req *certificate.Request) (pcc *certific
 		certBytes = append(cert_pem, []byte(caCertPEM)...)
 	}
 	pcc, err = certificate.PEMCollectionFromBytes(certBytes, req.ChainOption)
-
+	if err != nil {
+		return nil, err
+	}
 	// no key password -- no key
 	if pk != nil && req.KeyPassword != "" {
-		pcc.AddPrivateKey(pk, []byte(req.KeyPassword))
+		err = pcc.AddPrivateKey(pk, []byte(req.KeyPassword))
+		if err != nil {
+			return
+		}
 	}
+	err = req.CheckCertificate(pcc.Certificate)
 	return
 }
 
@@ -229,7 +227,7 @@ func (c *Connector) RevokeCertificate(revReq *certificate.RevocationRequest) (er
 	return fmt.Errorf("revocation is not supported in -test-mode")
 }
 
-func (c *Connector) ReadZoneConfiguration(zone string) (config *endpoint.ZoneConfiguration, err error) {
+func (c *Connector) ReadZoneConfiguration() (config *endpoint.ZoneConfiguration, err error) {
 	return endpoint.NewZoneConfiguration(), nil
 }
 
@@ -241,3 +239,26 @@ func (c *Connector) RenewCertificate(revReq *certificate.RenewalRequest) (reques
 func (c *Connector) ImportCertificate(req *certificate.ImportRequest) (*certificate.ImportResponse, error) {
 	return nil, fmt.Errorf("import is not supported in -test-mode")
 }
+
+func (c *Connector) ReadPolicyConfiguration() (policy *endpoint.Policy, err error) {
+	policy = &endpoint.Policy{
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		[]endpoint.AllowedKeyConfiguration{
+			{certificate.KeyTypeRSA, certificate.AllSupportedKeySizes(), nil},
+			{certificate.KeyTypeECDSA, nil, certificate.AllSupportedCurves()},
+		},
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		[]string{".*"},
+		true,
+		true,
+	}
+	return
+}
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/fake/fake.go b/vendor/github.com/Venafi/vcert/pkg/venafi/fake/fake.go
index cd80a96f0..8e478e8aa 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/fake/fake.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/fake/fake.go
@@ -17,48 +17,32 @@
 package fake
 
 import (
-	"encoding/pem"
 	"fmt"
 	"github.com/Venafi/vcert/pkg/certificate"
 	"github.com/Venafi/vcert/pkg/endpoint"
 )
 
-func (c *Connector) SetBaseURL(url string) error {
-	return nil
-}
-
 //GenerateRequest creates a new certificate request, based on the zone/policy configuration and the user data
 func (c *Connector) GenerateRequest(config *endpoint.ZoneConfiguration, req *certificate.Request) (err error) {
 
 	switch req.CsrOrigin {
 	case certificate.LocalGeneratedCSR:
-		switch req.KeyType {
-		case certificate.KeyTypeECDSA:
-			req.PrivateKey, err = certificate.GenerateECDSAPrivateKey(req.KeyCurve)
-		case certificate.KeyTypeRSA:
-			if req.KeyLength == 0 {
-				req.KeyLength = 2048
-			}
-			req.PrivateKey, err = certificate.GenerateRSAPrivateKey(req.KeyLength)
-		default:
-			return fmt.Errorf("Unable to generate certificate request, key type %s is not supported", req.KeyType.String())
-		}
+		err = req.GeneratePrivateKey()
 		if err != nil {
 			return err
 		}
-		err = certificate.GenerateRequest(req, req.PrivateKey)
+		err = req.GenerateCSR()
 		if err != nil {
 			return err
 		}
-		req.CSR = pem.EncodeToMemory(certificate.GetCertificateRequestPEMBlock(req.CSR))
 
 	case certificate.UserProvidedCSR:
-		if req.CSR == nil {
+		if req.GetCSR() == nil {
 			return fmt.Errorf("CSR was supposed to be provided by user, but it's empty")
 		}
 
 	case certificate.ServiceGeneratedCSR:
-		req.CSR = nil
+		return nil
 
 	default:
 		return fmt.Errorf("Unexpected option in PrivateKeyOrigin")
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/connector.go b/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/connector.go
index efa991771..37d2f4a99 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/connector.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/connector.go
@@ -17,18 +17,16 @@
 package tpp
 
 import (
-	"bytes"
 	"crypto/x509"
 	"encoding/json"
 	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
-	"github.com/Venafi/vcert/pkg/endpoint"
-	"io/ioutil"
-	"log"
 	"net/http"
-	"strconv"
+	"regexp"
 	"strings"
 	"time"
+
+	"github.com/Venafi/vcert/pkg/certificate"
+	"github.com/Venafi/vcert/pkg/endpoint"
 )
 
 // Connector contains the base data needed to communicate with a TPP Server
@@ -41,9 +39,38 @@ type Connector struct {
 }
 
 // NewConnector creates a new TPP Connector object used to communicate with TPP
-func NewConnector(verbose bool, trust *x509.CertPool) *Connector {
-	c := Connector{trust: trust, verbose: verbose}
-	return &c
+func NewConnector(url string, zone string, verbose bool, trust *x509.CertPool) (*Connector, error) {
+	c := Connector{verbose: verbose, trust: trust, zone: zone}
+	var err error
+	c.baseURL, err = normalizeURL(url)
+	if err != nil {
+		return nil, err
+	}
+	return &c, nil
+}
+
+// normalizeURL normalizes the base URL used to communicate with TPP
+func normalizeURL(url string) (normalizedURL string, err error) {
+	var baseUrlRegex = regexp.MustCompile(`^https://[a-z\d]+[-a-z\d.]+[a-z\d][:\d]*/vedsdk/$`)
+	modified := strings.ToLower(url)
+	if strings.HasPrefix(modified, "http://") {
+		modified = "https://" + modified[7:]
+	} else if !strings.HasPrefix(modified, "https://") {
+		modified = "https://" + modified
+	}
+	if !strings.HasSuffix(modified, "/") {
+		modified = modified + "/"
+	}
+
+	if !strings.HasSuffix(modified, "vedsdk/") {
+		modified += "vedsdk/"
+	}
+	if loc := baseUrlRegex.FindStringIndex(modified); loc == nil {
+		return "", fmt.Errorf("The specified TPP URL is invalid. %s\nExpected TPP URL format 'https://tpp.company.com/vedsdk/'", url)
+	}
+
+	normalizedURL = modified
+	return normalizedURL, nil
 }
 
 func (c *Connector) SetZone(z string) {
@@ -56,28 +83,14 @@ func (c *Connector) GetType() endpoint.ConnectorType {
 
 //Ping attempts to connect to the TPP Server WebSDK API and returns an errror if it cannot
 func (c *Connector) Ping() (err error) {
-	url, err := c.getURL("")
+	statusCode, status, _, err := c.request("GET", "", nil)
 	if err != nil {
-		return err
+		return
 	}
-	req, _ := http.NewRequest("GET", url, nil)
-	req.Header.Add("content-type", "application/json")
-	req.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(req)
-	if err != nil {
-		return err
-	} else if res.StatusCode != http.StatusOK {
-		defer res.Body.Close()
-		body, _ := ioutil.ReadAll(res.Body)
-		err = fmt.Errorf("%s", string(body))
+	if statusCode != http.StatusOK {
+		err = fmt.Errorf(status)
 	}
-	return err
-}
-
-//Register does nothing for TPP
-func (c *Connector) Register(email string) (err error) {
-	return nil
+	return
 }
 
 // Authenticate authenticates the user to the TPP
@@ -85,33 +98,17 @@ func (c *Connector) Authenticate(auth *endpoint.Authentication) (err error) {
 	if auth == nil {
 		return fmt.Errorf("failed to authenticate: missing credentials")
 	}
-	url, err := c.getURL(urlResourceAuthorize)
+	statusCode, status, body, err := c.request("POST", urlResourceAuthorize, authorizeResquest{Username: auth.User, Password: auth.Password})
 	if err != nil {
-		return err
+		return
 	}
 
-	b, _ := json.Marshal(authorizeResquest{Username: auth.User, Password: auth.Password})
-	payload := bytes.NewReader(b)
-	req, _ := http.NewRequest("POST", url, payload)
-	req.Header.Add("content-type", "application/json")
-	req.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(req)
-	if err == nil {
-		defer res.Body.Close()
-		body, _ := ioutil.ReadAll(res.Body)
-
-		key, err := parseAuthorizeResult(res.StatusCode, res.Status, body)
-		if err != nil {
-			if c.verbose {
-				log.Printf("JSON sent for %s\n%s", urlResourceAuthorize, strings.Replace(fmt.Sprintf("%s", b), auth.Password, "********", -1))
-			}
-			return err
-		}
-		c.apiKey = key
-		return nil
+	key, err := parseAuthorizeResult(statusCode, status, body)
+	if err != nil {
+		return
 	}
-	return err
+	c.apiKey = key
+	return
 }
 
 func wrapAltNames(req *certificate.Request) (items []sanItem) {
@@ -127,6 +124,7 @@ func wrapAltNames(req *certificate.Request) (items []sanItem) {
 	return items
 }
 
+//todo:remove unused
 func wrapKeyType(kt certificate.KeyType) string {
 	switch kt {
 	case certificate.KeyTypeRSA:
@@ -143,13 +141,15 @@ func prepareRequest(req *certificate.Request, zone string) (tppReq certificateRe
 	case certificate.LocalGeneratedCSR, certificate.UserProvidedCSR:
 		tppReq = certificateRequest{
 			PolicyDN:                getPolicyDN(zone),
-			PKCS10:                  string(req.CSR),
+			CADN:                    req.CADN,
+			PKCS10:                  string(req.GetCSR()),
 			ObjectName:              req.FriendlyName,
 			DisableAutomaticRenewal: true}
 
 	case certificate.ServiceGeneratedCSR:
 		tppReq = certificateRequest{
 			PolicyDN:                getPolicyDN(zone),
+			CADN:                    req.CADN,
 			ObjectName:              req.FriendlyName,
 			Subject:                 req.Subject.CommonName, // TODO: there is some problem because Subject is not only CN
 			SubjectAltNames:         wrapAltNames(req),
@@ -172,43 +172,19 @@ func prepareRequest(req *certificate.Request, zone string) (tppReq certificateRe
 }
 
 // RequestCertificate submits the CSR to TPP returning the DN of the requested Certificate
-func (c *Connector) RequestCertificate(req *certificate.Request, zone string) (requestID string, err error) {
-
-	if zone == "" {
-		zone = c.zone
-	}
-
-	tppCertificateRequest, err := prepareRequest(req, zone)
-	if err != nil {
-		return "", err
-	}
+func (c *Connector) RequestCertificate(req *certificate.Request) (requestID string, err error) {
 
-	b, _ := json.Marshal(tppCertificateRequest)
-
-	url, err := c.getURL(urlResourceCertificateRequest)
+	tppCertificateRequest, err := prepareRequest(req, c.zone)
 	if err != nil {
 		return "", err
 	}
-	payload := bytes.NewReader(b)
-	request, _ := http.NewRequest("POST", url, payload)
-	request.Header.Add("x-venafi-api-key", c.apiKey)
-	request.Header.Add("content-type", "application/json")
-	request.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(request)
-
+	statusCode, status, body, err := c.request("POST", urlResourceCertificateRequest, tppCertificateRequest)
 	if err != nil {
 		return "", err
 	}
-
-	defer res.Body.Close()
-	body, _ := ioutil.ReadAll(res.Body)
-	requestID, err = parseRequestResult(res.StatusCode, res.Status, body)
+	requestID, err = parseRequestResult(statusCode, status, body)
 	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", urlResourceCertificateRequest, b)
-		}
-		return "", fmt.Errorf("%s: %s", err, string(body))
+		return "", fmt.Errorf("%s: %s", err, string(body)) //todo: remove body from error
 	}
 	req.PickupID = requestID
 	return requestID, nil
@@ -248,12 +224,18 @@ func (c *Connector) RetrieveCertificate(req *certificate.Request) (certificates
 
 	startTime := time.Now()
 	for {
-		retrieveResponse, err := c.retrieveCertificateOnce(certReq)
+		var retrieveResponse *certificateRetrieveResponse
+		retrieveResponse, err = c.retrieveCertificateOnce(certReq)
 		if err != nil {
 			return nil, fmt.Errorf("unable to retrieve: %s", err)
 		}
 		if retrieveResponse.CertificateData != "" {
-			return newPEMCollectionFromResponse(retrieveResponse.CertificateData, req.ChainOption)
+			certificates, err = newPEMCollectionFromResponse(retrieveResponse.CertificateData, req.ChainOption)
+			if err != nil {
+				return
+			}
+			err = req.CheckCertificate(certificates.Certificate)
+			return
 		}
 		if req.Timeout == 0 {
 			return nil, endpoint.ErrCertificatePending{CertificateID: req.PickupID, Status: retrieveResponse.Status}
@@ -266,34 +248,14 @@ func (c *Connector) RetrieveCertificate(req *certificate.Request) (certificates
 }
 
 func (c *Connector) retrieveCertificateOnce(certReq certificateRetrieveRequest) (*certificateRetrieveResponse, error) {
-	url, err := c.getURL(urlResourceCertificateRetrieve)
+	statusCode, status, body, err := c.request("POST", urlResourceCertificateRetrieve, certReq)
 	if err != nil {
 		return nil, err
 	}
-
-	b, _ := json.Marshal(certReq)
-
-	payload := bytes.NewReader(b)
-	r, _ := http.NewRequest("POST", url, payload)
-	r.Header.Add("x-venafi-api-key", c.apiKey)
-	r.Header.Add("content-type", "application/json")
-	r.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(r)
-
+	retrieveResponse, err := parseRetrieveResult(statusCode, status, body)
 	if err != nil {
 		return nil, err
 	}
-
-	defer res.Body.Close()
-	body, _ := ioutil.ReadAll(res.Body)
-	retrieveResponse, err := parseRetrieveResult(res.StatusCode, res.Status, body)
-	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", urlResourceCertificateRetrieve, b)
-		}
-		return nil, err
-	}
 	return &retrieveResponse, nil
 }
 
@@ -319,38 +281,18 @@ func (c *Connector) RenewCertificate(renewReq *certificate.RenewalRequest) (requ
 		return "", fmt.Errorf("failed to create renewal request: CertificateDN or Thumbprint required")
 	}
 
-	url, err := c.getURL(urlResourceCertificateRenew)
-	if err != nil {
-		return "", err
-	}
-
 	var r = certificateRenewRequest{}
 	r.CertificateDN = renewReq.CertificateDN
-	if renewReq.CertificateRequest != nil && len(renewReq.CertificateRequest.CSR) > 0 {
-		r.PKCS10 = string(renewReq.CertificateRequest.CSR)
+	if renewReq.CertificateRequest != nil && len(renewReq.CertificateRequest.GetCSR()) != 0 {
+		r.PKCS10 = string(renewReq.CertificateRequest.GetCSR())
 	}
-
-	b, _ := json.Marshal(r)
-	payload := bytes.NewReader(b)
-	req, _ := http.NewRequest("POST", url, payload)
-	req.Header.Add("x-venafi-api-key", c.apiKey)
-	req.Header.Add("content-type", "application/json")
-	req.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(req)
-
+	statusCode, status, body, err := c.request("POST", urlResourceCertificateRenew, r)
 	if err != nil {
 		return "", err
 	}
 
-	defer res.Body.Close()
-	body, _ := ioutil.ReadAll(res.Body)
-	response, err := parseRenewResult(res.StatusCode, res.Status, body)
+	response, err := parseRenewResult(statusCode, status, body)
 	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", url, b)
-			log.Printf("Response: %s", string(body))
-		}
 		return "", err
 	}
 	if !response.Success {
@@ -361,11 +303,6 @@ func (c *Connector) RenewCertificate(renewReq *certificate.RenewalRequest) (requ
 
 // RevokeCertificate attempts to revoke the certificate
 func (c *Connector) RevokeCertificate(revReq *certificate.RevocationRequest) (err error) {
-	url, err := c.getURL(urlResourceCertificateRevoke)
-	if err != nil {
-		return err
-	}
-
 	reason, ok := RevocationReasonsMap[revReq.Reason]
 	if !ok {
 		return fmt.Errorf("could not parse revocation reason `%s`", revReq.Reason)
@@ -378,28 +315,13 @@ func (c *Connector) RevokeCertificate(revReq *certificate.RevocationRequest) (er
 		revReq.Comments,
 		revReq.Disable,
 	}
-
-	b, _ := json.Marshal(r)
-	payload := bytes.NewReader(b)
-	req, _ := http.NewRequest("POST", url, payload)
-	req.Header.Add("x-venafi-api-key", c.apiKey)
-	req.Header.Add("content-type", "application/json")
-	req.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(req)
-
+	statusCode, status, body, err := c.request("POST", urlResourceCertificateRevoke, r)
 	if err != nil {
 		return err
 	}
-
-	defer res.Body.Close()
-	body, _ := ioutil.ReadAll(res.Body)
-	revokeResponse, err := parseRevokeResult(res.StatusCode, res.Status, body)
+	revokeResponse, err := parseRevokeResult(statusCode, status, body)
 	if err != nil {
-		if c.verbose {
-			log.Printf("JSON sent for %s\n%s", urlResourceCertificateRevoke, b)
-		}
-		return err
+		return
 	}
 	if !revokeResponse.Success {
 		return fmt.Errorf("Revocation error: %s", revokeResponse.Error)
@@ -407,128 +329,67 @@ func (c *Connector) RevokeCertificate(revReq *certificate.RevocationRequest) (er
 	return
 }
 
+func (c *Connector) ReadPolicyConfiguration() (policy *endpoint.Policy, err error) {
+	if c.zone == "" {
+		return nil, fmt.Errorf("empty zone")
+	}
+	rq := struct{ PolicyDN string }{getPolicyDN(c.zone)}
+	statusCode, status, body, err := c.request("POST", urlResourceCertificatePolicy, rq)
+	if err != nil {
+		return
+	}
+	var r struct {
+		Policy serverPolicy
+	}
+	if statusCode == http.StatusOK {
+		err = json.Unmarshal(body, &r)
+		p := r.Policy.toPolicy()
+		policy = &p
+	} else {
+		return nil, fmt.Errorf("Invalid status: %s Server data: %s", status, body)
+	}
+	return
+}
+
 //ReadZoneConfiguration reads the policy data from TPP to get locked and pre-configured values for certificate requests
-func (c *Connector) ReadZoneConfiguration(zone string) (config *endpoint.ZoneConfiguration, err error) {
+func (c *Connector) ReadZoneConfiguration() (config *endpoint.ZoneConfiguration, err error) {
+	if c.zone == "" {
+		return nil, fmt.Errorf("empty zone")
+	}
 	zoneConfig := endpoint.NewZoneConfiguration()
-	zoneConfig.HashAlgorithm = x509.SHA256WithRSA
-	policyDN := getPolicyDN(zone)
-	keyType := certificate.KeyTypeRSA
-
-	url, err := c.getURL(urlResourceFindPolicy)
+	zoneConfig.HashAlgorithm = x509.SHA256WithRSA //todo: check this can have problem with ECDSA key
+	rq := struct{ PolicyDN string }{getPolicyDN(c.zone)}
+	statusCode, status, body, err := c.request("POST", urlResourceCertificatePolicy, rq)
 	if err != nil {
-		return nil, err
+		return
 	}
-	attributes := []string{tppAttributeOrg, tppAttributeOrgUnit, tppAttributeCountry, tppAttributeState, tppAttributeLocality, tppAttributeKeyAlgorithm, tppAttributeKeySize, tppAttributeEllipticCurve, tppAttributeRequestHash, tppAttributeManagementType, tppAttributeManualCSR}
-	for _, attrib := range attributes {
-		b, _ := json.Marshal(policyRequest{ObjectDN: policyDN, Class: "X509 Certificate", AttributeName: attrib})
-		payload := bytes.NewReader(b)
-		req, _ := http.NewRequest("POST", url, payload)
-		req.Header.Add("x-venafi-api-key", c.apiKey)
-		req.Header.Add("content-type", "application/json")
-		req.Header.Add("cache-control", "no-cache")
-
-		res, err := c.getHTTPClient().Do(req)
-
-		if err == nil {
-			defer res.Body.Close()
-			body, _ := ioutil.ReadAll(res.Body)
-
-			tppData, err := parseConfigResult(res.StatusCode, res.Status, body)
-			if tppData.Error == "" && (err != nil || tppData.Values == nil || len(tppData.Values) == 0) {
-				continue
-			} else if tppData.Error != "" && tppData.Result == 400 { //object does not exist
-				return nil, fmt.Errorf(tppData.Error)
-			}
-
-			switch attrib {
-			case tppAttributeOrg:
-				zoneConfig.Organization = tppData.Values[0]
-				zoneConfig.OrganizationLocked = tppData.Locked
-			case tppAttributeOrgUnit:
-				zoneConfig.OrganizationalUnit = tppData.Values
-			case tppAttributeCountry:
-				zoneConfig.Country = tppData.Values[0]
-				zoneConfig.CountryLocked = tppData.Locked
-			case tppAttributeState:
-				zoneConfig.Province = tppData.Values[0]
-				zoneConfig.ProvinceLocked = tppData.Locked
-			case tppAttributeLocality:
-				zoneConfig.Locality = tppData.Values[0]
-				zoneConfig.LocalityLocked = tppData.Locked
-			case tppAttributeKeyAlgorithm:
-				err = keyType.Set(tppData.Values[0])
-				if err == nil {
-					zoneConfig.AllowedKeyConfigurations = []endpoint.AllowedKeyConfiguration{endpoint.AllowedKeyConfiguration{KeyType: keyType}}
-				}
-			case tppAttributeKeySize:
-				temp, err := strconv.Atoi(tppData.Values[0])
-				if err == nil {
-					zoneConfig.AllowedKeyConfigurations = []endpoint.AllowedKeyConfiguration{endpoint.AllowedKeyConfiguration{KeyType: keyType, KeySizes: []int{temp}}}
-					zoneConfig.KeySizeLocked = tppData.Locked
-				}
-			case tppAttributeEllipticCurve:
-				curve := certificate.EllipticCurveP256
-				err = curve.Set(tppData.Values[0])
-				if err == nil {
-					zoneConfig.AllowedKeyConfigurations = []endpoint.AllowedKeyConfiguration{endpoint.AllowedKeyConfiguration{KeyType: certificate.KeyTypeECDSA, KeyCurves: []certificate.EllipticCurve{curve}}}
-					zoneConfig.KeySizeLocked = tppData.Locked
-				}
-			case tppAttributeRequestHash:
-				alg, err := strconv.Atoi(tppData.Values[0])
-				if err == nil {
-					switch alg {
-					case pkcs10HashAlgorithmSha1:
-						zoneConfig.HashAlgorithm = x509.SHA1WithRSA
-					case pkcs10HashAlgorithmSha384:
-						zoneConfig.HashAlgorithm = x509.SHA384WithRSA
-					case pkcs10HashAlgorithmSha512:
-						zoneConfig.HashAlgorithm = x509.SHA512WithRSA
-					default:
-						zoneConfig.HashAlgorithm = x509.SHA256WithRSA
-					}
-				}
-			case tppAttributeManagementType, tppAttributeManualCSR:
-				if tppData.Locked {
-					zoneConfig.CustomAttributeValues[attrib] = tppData.Values[0]
-				}
-			}
-		} else {
-			if c.verbose {
-				log.Printf("JSON sent for %s\n%s", urlResourceFindPolicy, b)
-			}
-			return nil, err
-		}
+	var r struct {
+		Policy serverPolicy
 	}
-
+	if statusCode != http.StatusOK {
+		return nil, fmt.Errorf("Invalid status: %s Server response: %s", status, string(body))
+	}
+	err = json.Unmarshal(body, &r)
+	if err != nil {
+		return nil, err
+	}
+	p := r.Policy.toPolicy()
+	r.Policy.toZoneConfig(zoneConfig)
+	zoneConfig.Policy = p
 	return zoneConfig, nil
 }
 
 func (c *Connector) ImportCertificate(r *certificate.ImportRequest) (*certificate.ImportResponse, error) {
-	url, err := c.getURL(urlResourceCertificateImport)
-	if err != nil {
-		return nil, err
-	}
 
 	if r.PolicyDN == "" {
 		r.PolicyDN = getPolicyDN(c.zone)
 	}
 
-	b, _ := json.Marshal(r)
-	payload := bytes.NewReader(b)
-	req, _ := http.NewRequest("POST", url, payload)
-	req.Header.Add("x-venafi-api-key", c.apiKey)
-	req.Header.Add("content-type", "application/json")
-	req.Header.Add("cache-control", "no-cache")
-
-	res, err := c.getHTTPClient().Do(req)
+	statusCode, _, body, err := c.request("POST", urlResourceCertificateImport, r)
 	if err != nil {
 		return nil, err
 	}
-
-	defer res.Body.Close()
-	body, _ := ioutil.ReadAll(res.Body)
-
-	switch res.StatusCode {
+	switch statusCode {
 	case http.StatusOK:
 
 		var response = &certificate.ImportResponse{}
@@ -546,6 +407,6 @@ func (c *Connector) ImportCertificate(r *certificate.ImportRequest) (*certificat
 		}
 		return nil, fmt.Errorf("%s", errorResponse.Error)
 	default:
-		return nil, fmt.Errorf("unexpected response status %d: %s", res.StatusCode, string(b))
+		return nil, fmt.Errorf("unexpected response status %d: %s", statusCode, string(body))
 	}
 }
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/search.go b/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/search.go
index e9e4b13f6..01057cc27 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/search.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/search.go
@@ -19,7 +19,6 @@ package tpp
 import (
 	"encoding/json"
 	"fmt"
-	"io/ioutil"
 	"net/http"
 	"strings"
 )
@@ -53,33 +52,12 @@ func (c *Connector) searchCertificates(req *SearchRequest) (*CertificateSearchRe
 
 	var err error
 
-	url, _ := c.getURL(urlResourceCertificateSearch)
-
-	url = fmt.Sprintf("%s?%s", url, strings.Join(*req, "&"))
-
-	request, err := http.NewRequest("GET", url, nil)
-	if err != nil {
-		return nil, err
-	}
-	request.Header.Add("x-venafi-api-key", c.apiKey)
-	request.Header.Add("cache-control", "no-cache")
-	request.Header.Add("accept", "application/json")
-
-	resp, err := http.DefaultClient.Do(request)
+	url := fmt.Sprintf("%s?%s", urlResourceCertificateSearch, strings.Join(*req, "&"))
+	statusCode, _, body, err := c.request("GET", urlResource(url), nil)
 	if err != nil {
 		return nil, err
 	}
-	defer resp.Body.Close()
-	body, err := ioutil.ReadAll(resp.Body)
-	if err != nil {
-		return nil, err
-	}
-	if c.verbose {
-		fmt.Printf("REQ: %s\n", url)
-		fmt.Printf("RES: %s\n", body)
-	}
-
-	searchResult, err := ParseCertificateSearchResponse(resp.StatusCode, body)
+	searchResult, err := ParseCertificateSearchResponse(statusCode, body)
 	if err != nil {
 		return nil, err
 	}
diff --git a/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/tpp.go b/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/tpp.go
index 07e774e0d..00a191fa5 100644
--- a/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/tpp.go
+++ b/vendor/github.com/Venafi/vcert/pkg/venafi/tpp/tpp.go
@@ -17,17 +17,21 @@
 package tpp
 
 import (
+	"bytes"
 	"crypto/tls"
 	"crypto/x509"
 	"encoding/base64"
 	"encoding/json"
-	"encoding/pem"
 	"fmt"
-	"github.com/Venafi/vcert/pkg/certificate"
-	"github.com/Venafi/vcert/pkg/endpoint"
+	"io"
+	"io/ioutil"
+	"log"
 	"net/http"
 	"regexp"
 	"strings"
+
+	"github.com/Venafi/vcert/pkg/certificate"
+	"github.com/Venafi/vcert/pkg/endpoint"
 )
 
 const defaultKeySize = 2048
@@ -73,7 +77,7 @@ type certificateRetrieveResponse struct {
 
 type RevocationReason int
 
-// this maps *certificate.RevocationRequest.Reason to TPP-specific webSDK codes
+// RevocationReasonsMap maps *certificate.RevocationRequest.Reason to TPP-specific webSDK codes
 var RevocationReasonsMap = map[string]RevocationReason{
 	"":                       0, // NoReason
 	"none":                   0, //
@@ -145,13 +149,14 @@ type urlResource string
 
 const (
 	urlResourceAuthorize           urlResource = "authorize/"
-	urlResourceCertificateRequest              = "certificates/request"
-	urlResourceCertificateRetrieve             = "certificates/retrieve"
-	urlResourceFindPolicy                      = "config/findpolicy"
-	urlResourceCertificateRevoke               = "certificates/revoke"
-	urlResourceCertificateRenew                = "certificates/renew"
-	urlResourceCertificateSearch               = "certificates/"
-	urlResourceCertificateImport               = "certificates/import"
+	urlResourceCertificateRequest  urlResource = "certificates/request"
+	urlResourceCertificateRetrieve urlResource = "certificates/retrieve"
+	urlResourceFindPolicy          urlResource = "config/findpolicy"
+	urlResourceCertificateRevoke   urlResource = "certificates/revoke"
+	urlResourceCertificateRenew    urlResource = "certificates/renew"
+	urlResourceCertificateSearch   urlResource = "certificates/"
+	urlResourceCertificateImport   urlResource = "certificates/import"
+	urlResourceCertificatePolicy   urlResource = "certificates/checkpolicy"
 )
 
 const (
@@ -201,56 +206,77 @@ func retrieveChainOptionFromString(order string) retrieveChainOption {
 	}
 }
 
-// SetBaseURL sets the base URL used to cummuncate with TPP
-func (c *Connector) SetBaseURL(url string) error {
-	modified := strings.ToLower(url)
-	reg := regexp.MustCompile("^http(|s)://")
-	if reg.FindStringIndex(modified) == nil {
-		modified = "https://" + modified
-	} else {
-		modified = reg.ReplaceAllString(modified, "https://")
-	}
-	reg = regexp.MustCompile("^https://.+?/")
-	if reg.FindStringIndex(modified) == nil {
-		modified = modified + "/"
+func (c *Connector) getURL(resource urlResource) (string, error) {
+	if c.baseURL == "" {
+		return "", fmt.Errorf("The Host URL has not been set")
 	}
+	return fmt.Sprintf("%s%s", c.baseURL, resource), nil
+}
 
-	reg = regexp.MustCompile("/vedsdk(|/)$")
-	if reg.FindStringIndex(modified) == nil {
-		modified += "vedsdk/"
-	} else {
-		modified = reg.ReplaceAllString(modified, "/vedsdk/")
+func (c *Connector) request(method string, resource urlResource, data interface{}) (statusCode int, statusText string, body []byte, err error) {
+	url, err := c.getURL(resource)
+	if err != nil {
+		return
+	}
+	var payload io.Reader
+	var b []byte
+	if method == "POST" {
+		b, _ = json.Marshal(data)
+		payload = bytes.NewReader(b)
 	}
 
-	reg = regexp.MustCompile("^https://[a-z\\d]+[-a-z\\d.]+[a-z\\d][:\\d]*/vedsdk/$")
-	if loc := reg.FindStringIndex(modified); loc == nil {
-		return fmt.Errorf("The specified TPP URL is invalid. %s\nExpected TPP URL format 'https://tpp.company.com/vedsdk/'", url)
+	r, _ := http.NewRequest(method, url, payload)
+	if c.apiKey != "" {
+		r.Header.Add("x-venafi-api-key", c.apiKey)
 	}
+	r.Header.Add("content-type", "application/json")
+	r.Header.Add("cache-control", "no-cache")
 
-	c.baseURL = modified
-	return nil
-}
+	res, err := c.getHTTPClient().Do(r)
+	if res != nil {
+		statusCode = res.StatusCode
+		statusText = res.Status
+	}
+	if err != nil {
+		return
+	}
 
-func (c *Connector) getURL(resource urlResource) (string, error) {
-	if c.baseURL == "" {
-		return "", fmt.Errorf("The Host URL has not been set")
+	defer res.Body.Close()
+	body, err = ioutil.ReadAll(res.Body)
+	// Do not enable trace in production
+	trace := false // IMPORTANT: sensitive information can be diclosured
+	// I hope you know what are you doing
+	if trace {
+		log.Println("#################")
+		if method == "POST" {
+			log.Printf("JSON sent for %s\n%s\n", url, string(b))
+		} else {
+			log.Printf("%s request sent to %s\n", method, url)
+		}
+		log.Printf("Response:\n%s\n", string(body))
+	} else if c.verbose {
+		log.Printf("Got %s status for %s %s\n", statusText, method, url)
 	}
-	return fmt.Sprintf("%s%s", c.baseURL, resource), nil
+	return
 }
 
 func (c *Connector) getHTTPClient() *http.Client {
 	if c.trust != nil {
-		tr := &http.Transport{TLSClientConfig: &tls.Config{RootCAs: c.trust}}
-		return &http.Client{Transport: tr}
+		tlsConfig := http.DefaultTransport.(*http.Transport).TLSClientConfig
+		if tlsConfig == nil {
+			tlsConfig = &tls.Config{}
+		}
+		tlsConfig.RootCAs = c.trust
+		return &http.Client{Transport: &http.Transport{TLSClientConfig: tlsConfig}}
 	}
 
 	return http.DefaultClient
 }
 
-//GenerateRequest creates a new certificate request, based on the zone/policy configuration and the user data
+// GenerateRequest creates a new certificate request, based on the zone/policy configuration and the user data
 func (c *Connector) GenerateRequest(config *endpoint.ZoneConfiguration, req *certificate.Request) (err error) {
 	if config == nil {
-		config, err = c.ReadZoneConfiguration(c.zone)
+		config, err = c.ReadZoneConfiguration()
 		if err != nil {
 			return fmt.Errorf("could not read zone configuration: %s", err)
 		}
@@ -268,42 +294,32 @@ func (c *Connector) GenerateRequest(config *endpoint.ZoneConfiguration, req *cer
 		if config.CustomAttributeValues[tppAttributeManualCSR] == "0" {
 			return fmt.Errorf("Unable to request certificate by local generated CSR when zone configuration is 'Manual Csr' = 0")
 		}
-		switch req.KeyType {
-		case certificate.KeyTypeECDSA:
-			req.PrivateKey, err = certificate.GenerateECDSAPrivateKey(req.KeyCurve)
-		case certificate.KeyTypeRSA:
-			req.PrivateKey, err = certificate.GenerateRSAPrivateKey(req.KeyLength)
-		default:
-			return fmt.Errorf("Unable to generate certificate request, key type %s is not supported", req.KeyType.String())
-		}
+		err = req.GeneratePrivateKey()
 		if err != nil {
 			return err
 		}
-		err = certificate.GenerateRequest(req, req.PrivateKey)
+		err = req.GenerateCSR()
 		if err != nil {
 			return err
 		}
-		req.CSR = pem.EncodeToMemory(certificate.GetCertificateRequestPEMBlock(req.CSR))
-
 	case certificate.UserProvidedCSR:
 		if config.CustomAttributeValues[tppAttributeManualCSR] == "0" {
 			return fmt.Errorf("Unable to request certificate with user provided CSR when zone configuration is 'Manual Csr' = 0")
 		}
-		if req.CSR == nil || len(req.CSR) == 0 {
+		if len(req.GetCSR()) == 0 {
 			return fmt.Errorf("CSR was supposed to be provided by user, but it's empty")
 		}
 
 	case certificate.ServiceGeneratedCSR:
-		req.CSR = nil
 	}
 	return nil
 }
 
 func getPolicyDN(zone string) string {
 	modified := zone
-	reg := regexp.MustCompile("^\\\\VED\\\\Policy")
+	reg := regexp.MustCompile(`^\\VED\\Policy`)
 	if reg.FindStringIndex(modified) == nil {
-		reg = regexp.MustCompile("^\\\\")
+		reg = regexp.MustCompile(`^\\`)
 		if reg.FindStringIndex(modified) == nil {
 			modified = "\\" + modified
 		}
@@ -325,14 +341,9 @@ func parseAuthorizeResult(httpStatusCode int, httpStatus string, body []byte) (s
 	}
 }
 
-func parseAuthorizeData(b []byte) (authorizeResponse, error) {
-	var data authorizeResponse
-	err := json.Unmarshal(b, &data)
-	if err != nil {
-		return data, err
-	}
-
-	return data, nil
+func parseAuthorizeData(b []byte) (data authorizeResponse, err error) {
+	err = json.Unmarshal(b, &data)
+	return
 }
 
 func parseConfigResult(httpStatusCode int, httpStatus string, body []byte) (tppData tppPolicyData, err error) {
@@ -349,14 +360,9 @@ func parseConfigResult(httpStatusCode int, httpStatus string, body []byte) (tppD
 	}
 }
 
-func parseConfigData(b []byte) (tppPolicyData, error) {
-	var data tppPolicyData
-	err := json.Unmarshal(b, &data)
-	if err != nil {
-		return data, err
-	}
-
-	return data, nil
+func parseConfigData(b []byte) (data tppPolicyData, err error) {
+	err = json.Unmarshal(b, &data)
+	return
 }
 
 func parseRequestResult(httpStatusCode int, httpStatus string, body []byte) (string, error) {
@@ -372,14 +378,9 @@ func parseRequestResult(httpStatusCode int, httpStatus string, body []byte) (str
 	}
 }
 
-func parseRequestData(b []byte) (certificateRequestResponse, error) {
-	var data certificateRequestResponse
-	err := json.Unmarshal(b, &data)
-	if err != nil {
-		return data, err
-	}
-
-	return data, nil
+func parseRequestData(b []byte) (data certificateRequestResponse, err error) {
+	err = json.Unmarshal(b, &data)
+	return
 }
 
 func parseRetrieveResult(httpStatusCode int, httpStatus string, body []byte) (certificateRetrieveResponse, error) {
@@ -396,14 +397,9 @@ func parseRetrieveResult(httpStatusCode int, httpStatus string, body []byte) (ce
 	}
 }
 
-func parseRetrieveData(b []byte) (certificateRetrieveResponse, error) {
-	var data certificateRetrieveResponse
-	err := json.Unmarshal(b, &data)
-	if err != nil {
-		return data, err
-	}
-	// fmt.Printf("\n\n%s\n\n%+v\n\n", string(b), data)
-	return data, nil
+func parseRetrieveData(b []byte) (data certificateRetrieveResponse, err error) {
+	err = json.Unmarshal(b, &data)
+	return
 }
 
 func parseRevokeResult(httpStatusCode int, httpStatus string, body []byte) (certificateRevokeResponse, error) {
@@ -420,13 +416,9 @@ func parseRevokeResult(httpStatusCode int, httpStatus string, body []byte) (cert
 	}
 }
 
-func parseRevokeData(b []byte) (certificateRevokeResponse, error) {
-	var data certificateRevokeResponse
-	err := json.Unmarshal(b, &data)
-	if err != nil {
-		return data, err
-	}
-	return data, nil
+func parseRevokeData(b []byte) (data certificateRevokeResponse, err error) {
+	err = json.Unmarshal(b, &data)
+	return
 }
 
 func parseRenewResult(httpStatusCode int, httpStatus string, body []byte) (resp certificateRenewResponse, err error) {
@@ -437,10 +429,9 @@ func parseRenewResult(httpStatusCode int, httpStatus string, body []byte) (resp
 	return resp, nil
 }
 
-func parseRenewData(b []byte) (certificateRenewResponse, error) {
-	var data certificateRenewResponse
-	err := json.Unmarshal(b, &data)
-	return data, err
+func parseRenewData(b []byte) (data certificateRenewResponse, err error) {
+	err = json.Unmarshal(b, &data)
+	return
 }
 
 func newPEMCollectionFromResponse(base64Response string, chainOrder certificate.ChainOption) (*certificate.PEMCollection, error) {
@@ -454,3 +445,191 @@ func newPEMCollectionFromResponse(base64Response string, chainOrder certificate.
 	}
 	return nil, nil
 }
+
+type _strValue struct {
+	Locked bool
+	Value  string
+}
+
+type serverPolicy struct {
+	CertificateAuthority _strValue
+	CsrGeneration        _strValue
+	KeyGeneration        _strValue
+	KeyPair              struct {
+		KeyAlgorithm _strValue
+		KeySize      struct {
+			Locked bool
+			Value  int
+		}
+		EllipticCurve struct {
+			Locked bool
+			Value  string
+		}
+	}
+	ManagementType _strValue
+
+	PrivateKeyReuseAllowed  bool
+	SubjAltNameDnsAllowed   bool
+	SubjAltNameEmailAllowed bool
+	SubjAltNameIpAllowed    bool
+	SubjAltNameUpnAllowed   bool
+	SubjAltNameUriAllowed   bool
+	Subject                 struct {
+		City               _strValue
+		Country            _strValue
+		Organization       _strValue
+		OrganizationalUnit struct {
+			Locked bool
+			Values []string
+		}
+
+		State _strValue
+	}
+	UniqueSubjectEnforced bool
+	WhitelistedDomains    []string
+	WildcardsAllowed      bool
+}
+
+func (sp serverPolicy) toZoneConfig(zc *endpoint.ZoneConfiguration) {
+	zc.Country = sp.Subject.Country.Value
+	zc.Organization = sp.Subject.Organization.Value
+	zc.OrganizationalUnit = sp.Subject.OrganizationalUnit.Values
+	zc.Province = sp.Subject.State.Value
+	zc.Locality = sp.Subject.City.Value
+}
+
+func (sp serverPolicy) toPolicy() (p endpoint.Policy) {
+	addStartEnd := func(s string) string {
+		if !strings.HasPrefix(s, "^") {
+			s = "^" + s
+		}
+		if !strings.HasSuffix(s, "$") {
+			s = s + "$"
+		}
+		return s
+	}
+	escapeOne := func(s string) string {
+		return addStartEnd(regexp.QuoteMeta(s))
+	}
+	escapeArray := func(l []string) []string {
+		escaped := make([]string, len(l))
+		for i, r := range l {
+			escaped[i] = escapeOne(r)
+		}
+		return escaped
+	}
+	const allAllowedRegex = ".*"
+	if len(sp.WhitelistedDomains) == 0 {
+		p.SubjectCNRegexes = []string{allAllowedRegex}
+	} else {
+		p.SubjectCNRegexes = make([]string, len(sp.WhitelistedDomains))
+		for i, d := range sp.WhitelistedDomains {
+			if sp.WildcardsAllowed {
+				p.SubjectCNRegexes[i] = addStartEnd(".*" + regexp.QuoteMeta("."+d))
+			} else {
+				p.SubjectCNRegexes[i] = escapeOne(d)
+			}
+		}
+	}
+	if sp.Subject.OrganizationalUnit.Locked {
+		p.SubjectOURegexes = escapeArray(sp.Subject.OrganizationalUnit.Values)
+	} else {
+		p.SubjectOURegexes = []string{allAllowedRegex}
+	}
+	if sp.Subject.Organization.Locked {
+		p.SubjectORegexes = []string{escapeOne(sp.Subject.Organization.Value)}
+	} else {
+		p.SubjectORegexes = []string{allAllowedRegex}
+	}
+	if sp.Subject.City.Locked {
+		p.SubjectLRegexes = []string{escapeOne(sp.Subject.City.Value)}
+	} else {
+		p.SubjectLRegexes = []string{allAllowedRegex}
+	}
+	if sp.Subject.State.Locked {
+		p.SubjectSTRegexes = []string{escapeOne(sp.Subject.State.Value)}
+	} else {
+		p.SubjectSTRegexes = []string{allAllowedRegex}
+	}
+	if sp.Subject.Country.Locked {
+		p.SubjectCRegexes = []string{escapeOne(sp.Subject.Country.Value)}
+	} else {
+		p.SubjectCRegexes = []string{allAllowedRegex}
+	}
+	if sp.SubjAltNameDnsAllowed {
+		if len(sp.WhitelistedDomains) == 0 {
+			p.DnsSanRegExs = []string{allAllowedRegex}
+		} else {
+			p.DnsSanRegExs = make([]string, len(sp.WhitelistedDomains))
+			for i, d := range sp.WhitelistedDomains {
+				if sp.WildcardsAllowed {
+					p.DnsSanRegExs[i] = addStartEnd(".*" + regexp.QuoteMeta("."+d))
+				} else {
+					p.DnsSanRegExs[i] = escapeOne(d)
+				}
+			}
+		}
+	} else {
+		p.DnsSanRegExs = []string{}
+	}
+	if sp.SubjAltNameIpAllowed {
+		p.IpSanRegExs = []string{allAllowedRegex}
+	} else {
+		p.IpSanRegExs = []string{}
+	}
+	if sp.SubjAltNameEmailAllowed {
+		p.EmailSanRegExs = []string{allAllowedRegex}
+	} else {
+		p.EmailSanRegExs = []string{}
+	}
+	if sp.SubjAltNameUriAllowed {
+		p.UriSanRegExs = []string{allAllowedRegex}
+	} else {
+		p.UriSanRegExs = []string{}
+	}
+	if sp.SubjAltNameUpnAllowed {
+		p.UpnSanRegExs = []string{allAllowedRegex}
+	} else {
+		p.UpnSanRegExs = []string{}
+	}
+	if sp.KeyPair.KeyAlgorithm.Locked {
+		var keyType certificate.KeyType
+		if err := keyType.Set(sp.KeyPair.KeyAlgorithm.Value); err != nil {
+			panic(err)
+		}
+		key := endpoint.AllowedKeyConfiguration{KeyType: keyType}
+		if keyType == certificate.KeyTypeRSA {
+			if sp.KeyPair.KeySize.Locked {
+				for _, i := range certificate.AllSupportedKeySizes() {
+					if i >= sp.KeyPair.KeySize.Value {
+						key.KeySizes = append(key.KeySizes, i)
+					}
+				}
+			} else {
+				key.KeySizes = certificate.AllSupportedKeySizes()
+			}
+		} else {
+			var curve certificate.EllipticCurve
+			if sp.KeyPair.EllipticCurve.Locked {
+				if err := curve.Set(sp.KeyPair.EllipticCurve.Value); err != nil {
+					panic(err)
+				}
+				key.KeyCurves = append(key.KeyCurves, curve)
+			} else {
+				key.KeyCurves = certificate.AllSupportedCurves()
+			}
+
+		}
+		p.AllowedKeyConfigurations = append(p.AllowedKeyConfigurations, key)
+	} else {
+		p.AllowedKeyConfigurations = append(p.AllowedKeyConfigurations, endpoint.AllowedKeyConfiguration{
+			KeyType: certificate.KeyTypeRSA, KeySizes: certificate.AllSupportedKeySizes(),
+		})
+		p.AllowedKeyConfigurations = append(p.AllowedKeyConfigurations, endpoint.AllowedKeyConfiguration{
+			KeyType: certificate.KeyTypeECDSA, KeyCurves: certificate.AllSupportedCurves(),
+		})
+	}
+	p.AllowWildcards = sp.WildcardsAllowed
+	p.AllowKeyReuse = sp.PrivateKeyReuseAllowed
+	return
+}
diff --git a/vendor/github.com/Venafi/vcert/vcert.go b/vendor/github.com/Venafi/vcert/vcert.go
index daadfaa31..218ac031e 100644
--- a/vendor/github.com/Venafi/vcert/vcert.go
+++ b/vendor/github.com/Venafi/vcert/vcert.go
@@ -13,19 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+VCert is a Go library, SDK, and command line utility designed to simplify key generation and enrollment of machine identities (also known as SSL/TLS certificates and keys) that comply with enterprise security policy by using the Venafi Platform or Venafi Cloud.
+*/
 package vcert
 
 import (
 	"fmt"
 )
 
-//ProjectName contains the friendly name of the vcert utiltity
-const ProjectName string = "Venafi Certificate Utility"
+//projectName contains the friendly name of the vcert utiltity
+const projectName string = "Venafi Certificate Utility"
 
 var (
-	versionString         string
 	versionBuildTimeStamp string
+	versionString         string
 )
 
 //GetFormattedVersionString gets a friendly printable string to represent the version
@@ -33,13 +35,8 @@ func GetFormattedVersionString() string {
 	if versionBuildTimeStamp != "" {
 		versionBuildTimeStamp = fmt.Sprintf("\tBuild Timestamp: %s\n", versionBuildTimeStamp)
 	}
-	return fmt.Sprintf("%s\n\tVersion: %s\n%s", ProjectName, GetVersionString(), versionBuildTimeStamp)
-}
-
-//GetVersionString gets a simple version string
-func GetVersionString() string {
 	if versionString == "" {
-		versionString = "3.18.3.1"
+		versionString = "Unknown"
 	}
-	return versionString
+	return fmt.Sprintf("%s\n\tVersion: %s\n%s", projectName, versionString, versionBuildTimeStamp)
 }
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 8eafd7056..61a162027 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -24,7 +24,7 @@ github.com/NYTimes/gziphandler
 github.com/PuerkitoBio/purell
 # github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578
 github.com/PuerkitoBio/urlesc
-# github.com/Venafi/vcert v0.0.0-20181029235941-5068538d4d65
+# github.com/Venafi/vcert v0.0.0-20190530133915-e207710a0ab9
 github.com/Venafi/vcert
 github.com/Venafi/vcert/pkg/certificate
 github.com/Venafi/vcert/pkg/endpoint
