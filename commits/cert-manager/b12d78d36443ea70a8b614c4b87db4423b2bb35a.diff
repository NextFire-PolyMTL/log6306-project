commit b12d78d36443ea70a8b614c4b87db4423b2bb35a (from 952a4502e338abf3a6049f3a33f55d42d0126a9b)
Merge: 952a4502e 5d5656657
Author: jetstack-bot <32282838+jetstack-bot@users.noreply.github.com>
Date:   Thu Jan 27 12:45:40 2022 +0000

    Merge pull request #4746 from JoshVanL/controller-readiness-certificates-spec-match
    
    Certificates controller policies refactor

diff --git a/BUILD.bazel b/BUILD.bazel
index c0c56f631..b36dc58a7 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -88,6 +88,7 @@ filegroup(
         "//test/internal/apiserver:all-srcs",
         "//test/internal/util:all-srcs",
         "//test/unit/coreclients:all-srcs",
+        "//test/unit/crypto:all-srcs",
         "//test/unit/discovery:all-srcs",
         "//test/unit/gen:all-srcs",
         "//test/unit/listers:all-srcs",
diff --git a/internal/BUILD.bazel b/internal/BUILD.bazel
index 2b00024e8..e3fd2d84e 100644
--- a/internal/BUILD.bazel
+++ b/internal/BUILD.bazel
@@ -13,6 +13,7 @@ filegroup(
         "//internal/apis/certmanager:all-srcs",
         "//internal/apis/config/webhook:all-srcs",
         "//internal/apis/meta:all-srcs",
+        "//internal/controller/certificates:all-srcs",
         "//internal/controller/feature:all-srcs",
         "//internal/ingress:all-srcs",
         "//internal/plugin:all-srcs",
diff --git a/internal/controller/certificates/BUILD.bazel b/internal/controller/certificates/BUILD.bazel
new file mode 100644
index 000000000..e0337736b
--- /dev/null
+++ b/internal/controller/certificates/BUILD.bazel
@@ -0,0 +1,42 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
+
+go_library(
+    name = "go_default_library",
+    srcs = ["secrets.go"],
+    importpath = "github.com/jetstack/cert-manager/internal/controller/certificates",
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//pkg/api/util:go_default_library",
+        "//pkg/apis/certmanager/v1:go_default_library",
+        "//pkg/util/pki:go_default_library",
+    ],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = ["secrets_test.go"],
+    embed = [":go_default_library"],
+    deps = [
+        "//pkg/apis/certmanager/v1:go_default_library",
+        "//pkg/apis/meta/v1:go_default_library",
+        "//test/unit/gen:go_default_library",
+        "@com_github_stretchr_testify//assert:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [
+        ":package-srcs",
+        "//internal/controller/certificates/policies:all-srcs",
+    ],
+    tags = ["automanaged"],
+    visibility = ["//visibility:public"],
+)
diff --git a/pkg/controller/certificates/trigger/policies/BUILD.bazel b/internal/controller/certificates/policies/BUILD.bazel
similarity index 83%
rename from pkg/controller/certificates/trigger/policies/BUILD.bazel
rename to internal/controller/certificates/policies/BUILD.bazel
index 37bf5e3d5..eb46ebfab 100644
--- a/pkg/controller/certificates/trigger/policies/BUILD.bazel
+++ b/internal/controller/certificates/policies/BUILD.bazel
@@ -3,13 +3,15 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 go_library(
     name = "go_default_library",
     srcs = [
+        "checks.go",
         "constants.go",
         "gatherer.go",
         "policies.go",
     ],
-    importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies",
+    importpath = "github.com/jetstack/cert-manager/internal/controller/certificates/policies",
     visibility = ["//visibility:public"],
     deps = [
+        "//internal/controller/certificates:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/client/listers/certmanager/v1:go_default_library",
         "//pkg/controller/certificates:go_default_library",
@@ -20,25 +22,28 @@ go_library(
         "@io_k8s_apimachinery//pkg/api/errors:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/labels:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/sets:go_default_library",
         "@io_k8s_client_go//listers/core/v1:go_default_library",
+        "@io_k8s_sigs_structured_merge_diff_v4//fieldpath:go_default_library",
         "@io_k8s_utils//clock:go_default_library",
+        "@io_k8s_utils//pointer:go_default_library",
     ],
 )
 
 go_test(
     name = "go_default_test",
     srcs = [
+        "checks_test.go",
         "gatherer_test.go",
-        "policies_test.go",
     ],
     embed = [":go_default_library"],
     deps = [
         "//pkg/api:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
-        "//pkg/controller/certificates/internal/test:go_default_library",
         "//pkg/controller/test:go_default_library",
         "//pkg/logs:go_default_library",
+        "//test/unit/crypto:go_default_library",
         "//test/unit/gen:go_default_library",
         "@com_github_go_logr_logr//testing:go_default_library",
         "@com_github_stretchr_testify//assert:go_default_library",
diff --git a/pkg/controller/certificates/trigger/policies/policies.go b/internal/controller/certificates/policies/checks.go
similarity index 59%
rename from pkg/controller/certificates/trigger/policies/policies.go
rename to internal/controller/certificates/policies/checks.go
index af8942b43..52c53db62 100644
--- a/pkg/controller/certificates/trigger/policies/policies.go
+++ b/internal/controller/certificates/policies/checks.go
@@ -14,74 +14,29 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */
 
-//Package policies provides functionality to evaluate Certificate's state
 package policies
 
 import (
+	"bytes"
 	"crypto/tls"
+	"crypto/x509"
 	"fmt"
+	"strings"
 	"time"
 
 	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/util/sets"
 	"k8s.io/utils/clock"
+	"k8s.io/utils/pointer"
+	"sigs.k8s.io/structured-merge-diff/v4/fieldpath"
 
+	internalcertificates "github.com/jetstack/cert-manager/internal/controller/certificates"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	"github.com/jetstack/cert-manager/pkg/controller/certificates"
 	"github.com/jetstack/cert-manager/pkg/util/pki"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 )
 
-type Input struct {
-	Certificate *cmapi.Certificate
-	Secret      *corev1.Secret
-
-	// The "current" certificate request designates the certificate request that
-	// led to the current revision of the certificate. The "current" certificate
-	// request is by definition in a ready state, and can be seen as the source
-	// of information of the current certificate. Take a look at the gatherer
-	// package's documentation to see more about why we care about the "current"
-	// certificate request.
-	CurrentRevisionRequest *cmapi.CertificateRequest
-
-	// The "next" certificate request is the one that is currently being issued.
-	// Take a look at the gatherer package's documentation to see more about why
-	// we care about the "next" certificate request.
-	NextRevisionRequest *cmapi.CertificateRequest
-}
-
-// A Func evaluates the given input data and decides whether a
-// re-issuance is required, returning additional human readable information
-// in the 'reason' and 'message' return parameters if so.
-type Func func(Input) (reason, message string, reissue bool)
-
-// A Chain of PolicyFuncs to be evaluated in order.
-type Chain []Func
-
-// Evaluate will evaluate the entire policy chain using the provided input.
-// As soon as it is discovered that the input violates one policy,
-// Evaluate will return and not evaluate the rest of the chain.
-func (c Chain) Evaluate(input Input) (string, string, bool) {
-	for _, policyFunc := range c {
-		reason, message, violationFound := policyFunc(input)
-		if violationFound {
-			return reason, message, violationFound
-		}
-	}
-	return "", "", false
-}
-
-func NewTriggerPolicyChain(c clock.Clock) Chain {
-	return Chain{
-		SecretDoesNotExist,
-		SecretIsMissingData,
-		SecretPublicKeysDiffer,
-		SecretPrivateKeyMatchesSpec,
-		SecretIssuerAnnotationsNotUpToDate,
-		CurrentCertificateRequestNotValidForSpec,
-		CurrentCertificateNearingExpiry(c),
-	}
-}
-
 func SecretDoesNotExist(input Input) (string, string, bool) {
 	if input.Secret == nil {
 		return DoesNotExist, "Issuing certificate as Secret does not exist", true
@@ -207,7 +162,7 @@ func CurrentCertificateNearingExpiry(c clock.Clock) Func {
 		if err != nil {
 			// This case should never happen as it should always be caught by the
 			// secretPublicKeysMatch function beforehand, but handle it just in case.
-			return "InvalidCertificate", fmt.Sprintf("Failed to decode stored certificate: %v", err), true
+			return InvalidCertificate, fmt.Sprintf("Failed to decode stored certificate: %v", err), true
 		}
 
 		notBefore := metav1.NewTime(x509cert.NotBefore)
@@ -239,7 +194,7 @@ func CurrentCertificateHasExpired(c clock.Clock) Func {
 		if err != nil {
 			// This case should never happen as it should always be caught by the
 			// secretPublicKeysMatch function beforehand, but handle it just in case.
-			return "InvalidCertificate", fmt.Sprintf("Failed to decode stored certificate: %v", err), true
+			return InvalidCertificate, fmt.Sprintf("Failed to decode stored certificate: %v", err), true
 		}
 
 		if c.Now().After(cert.NotAfter) {
@@ -281,3 +236,135 @@ func issuerGroupsEqual(l, r string) bool {
 	}
 	return l == r
 }
+
+// SecretTemplateMismatchesSecret will inspect the given Secret's Annotations
+// and Labels, and compare these maps against those that appear on the given
+// Certificate's SecretTemplate.
+// Returns false if all the Certificate's SecretTemplate Annotations and Labels
+// appear on the Secret, or put another way, the Certificate's SecretTemplate
+// is a subset of that in the Secret's Annotations/Labels.
+// Returns true otherwise.
+func SecretTemplateMismatchesSecret(input Input) (string, string, bool) {
+	if input.Certificate.Spec.SecretTemplate == nil {
+		return "", "", false
+	}
+
+	for kSpec, vSpec := range input.Certificate.Spec.SecretTemplate.Annotations {
+		if v, ok := input.Secret.Annotations[kSpec]; !ok || v != vSpec {
+			return SecretTemplateMismatch, "Certificate's SecretTemplate Annotations missing or incorrect value on Secret", true
+		}
+	}
+
+	for kSpec, vSpec := range input.Certificate.Spec.SecretTemplate.Labels {
+		if v, ok := input.Secret.Labels[kSpec]; !ok || v != vSpec {
+			return SecretTemplateMismatch, "Certificate's SecretTemplate Labels missing or incorrect value on Secret", true
+		}
+	}
+
+	return "", "", false
+}
+
+// SecretTemplateMismatchesSecretManagedFields will inspect the given Secret's
+// managed fields for its Annotations and Labels, and compare this against the
+// SecretTemplate on the given Certificate. Returns false if Annotations and
+// Labels match on both the Certificate's SecretTemplate and the Secret's
+// managed fields, true otherwise.
+// Also returns true if the managed fields or signed certificate were not able
+// to be decoded.
+func SecretTemplateMismatchesSecretManagedFields(fieldManager string) Func {
+	return func(input Input) (string, string, bool) {
+		// Only attempt to decode the signed certificate, if one is available.
+		var x509cert *x509.Certificate
+		if len(input.Secret.Data[corev1.TLSCertKey]) > 0 {
+			var err error
+			x509cert, err = pki.DecodeX509CertificateBytes(input.Secret.Data[corev1.TLSCertKey])
+			if err != nil {
+				// This case should never happen as it should always be caught by the
+				// secretPublicKeysMatch function beforehand, but handle it just in case.
+				return InvalidCertificate, fmt.Sprintf("Failed to decode stored certificate: %v", err), true
+			}
+		}
+
+		baseAnnotations := internalcertificates.AnnotationsForCertificateSecret(input.Certificate, x509cert)
+
+		managedLabels, managedAnnotations := sets.NewString(), sets.NewString()
+
+		for _, managedField := range input.Secret.ManagedFields {
+			// If the managed field isn't owned by the cert-manager controller, ignore.
+			if managedField.Manager != fieldManager || managedField.FieldsV1 == nil {
+				continue
+			}
+
+			// Decode the managed field.
+			var fieldset fieldpath.Set
+			if err := fieldset.FromJSON(bytes.NewReader(managedField.FieldsV1.Raw)); err != nil {
+				return ManagedFieldsParseError, fmt.Sprintf("failed to decode managed fields on Secret: %s", err), true
+			}
+
+			// Extract the labels and annotations of the managed fields.
+			metadata := fieldset.Children.Descend(fieldpath.PathElement{
+				FieldName: pointer.String("metadata"),
+			})
+			labels := metadata.Children.Descend(fieldpath.PathElement{
+				FieldName: pointer.String("labels"),
+			})
+			annotations := metadata.Children.Descend(fieldpath.PathElement{
+				FieldName: pointer.String("annotations"),
+			})
+
+			// Gather the annotations and labels on the managed fields. Remove the '.'
+			// prefix which appears on managed field keys.
+			labels.Iterate(func(path fieldpath.Path) {
+				managedLabels.Insert(strings.TrimPrefix(path.String(), "."))
+			})
+			annotations.Iterate(func(path fieldpath.Path) {
+				managedAnnotations.Insert(strings.TrimPrefix(path.String(), "."))
+			})
+		}
+
+		// Remove the base Annotations from the managed Annotations so we can compare
+		// 1 to 1 against the SecretTemplate.
+		for k := range baseAnnotations {
+			managedAnnotations = managedAnnotations.Delete(k)
+		}
+
+		// Check early for Secret Template being nil, and whether managed
+		// labels/annotations are not.
+		if input.Certificate.Spec.SecretTemplate == nil {
+			if len(managedLabels) > 0 || len(managedAnnotations) > 0 {
+				return SecretTemplateMismatch, "SecretTemplate is nil, but Secret contains extra managed entries", true
+			}
+			// SecretTemplate is nil. Managed annotations and labels are also empty.
+			// Return false.
+			return "", "", false
+		}
+
+		// SecretTemplate is not nil. Do length checks.
+		if len(input.Certificate.Spec.SecretTemplate.Labels) != len(managedLabels) ||
+			len(input.Certificate.Spec.SecretTemplate.Annotations) != len(managedAnnotations) {
+			return SecretTemplateMismatch, "Certificate's SecretTemplate doesn't match Secret", true
+		}
+
+		// Check equal unsorted for SecretTemplate keys, and the managed fields
+		// equivalents.
+		for _, smap := range []struct {
+			specMap    map[string]string
+			managedSet sets.String
+		}{
+			{specMap: input.Certificate.Spec.SecretTemplate.Labels, managedSet: managedLabels},
+			{specMap: input.Certificate.Spec.SecretTemplate.Annotations, managedSet: managedAnnotations},
+		} {
+
+			specSet := sets.NewString()
+			for kSpec := range smap.specMap {
+				specSet.Insert(kSpec)
+			}
+
+			if !specSet.Equal(smap.managedSet) {
+				return SecretTemplateMismatch, "Certificate's SecretTemplate doesn't match Secret", true
+			}
+		}
+
+		return "", "", false
+	}
+}
diff --git a/internal/controller/certificates/policies/checks_test.go b/internal/controller/certificates/policies/checks_test.go
new file mode 100644
index 000000000..a43f4fc97
--- /dev/null
+++ b/internal/controller/certificates/policies/checks_test.go
@@ -0,0 +1,1030 @@
+/*
+Copyright 2020 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package policies
+
+import (
+	"testing"
+	"time"
+
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	fakeclock "k8s.io/utils/clock/testing"
+
+	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
+	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
+	testcrypto "github.com/jetstack/cert-manager/test/unit/crypto"
+	"github.com/jetstack/cert-manager/test/unit/gen"
+	"github.com/stretchr/testify/assert"
+)
+
+// Runs a full set of tests against the trigger 'policy chain' once it is
+// composed together.
+// These tests account for the ordering of the policy chain, and are in place
+// to ensure we do not break behaviour when introducing a new policy or
+// modifying existing code.
+func Test_NewTriggerPolicyChain(t *testing.T) {
+	clock := &fakeclock.FakeClock{}
+	staticFixedPrivateKey := testcrypto.MustCreatePEMPrivateKey(t)
+	tests := map[string]struct {
+		// policy inputs
+		certificate *cmapi.Certificate
+		request     *cmapi.CertificateRequest
+		secret      *corev1.Secret
+
+		// expected outputs
+		reason, message string
+		reissue         bool
+	}{
+		"trigger issuance if Secret is missing": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			reason:      DoesNotExist,
+			message:     "Issuing certificate as Secret does not exist",
+			reissue:     true,
+		},
+		"trigger issuance as Secret does not contain any data": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret:      &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"}},
+			reason:      MissingData,
+			message:     "Issuing certificate as Secret does not contain any data",
+			reissue:     true,
+		},
+		"trigger issuance as Secret is missing private key": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
+				Data: map[string][]byte{corev1.TLSCertKey: []byte("test")},
+			},
+			reason:  MissingData,
+			message: "Issuing certificate as Secret does not contain a private key",
+			reissue: true,
+		},
+		"trigger issuance as Secret is missing certificate": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
+				Data: map[string][]byte{corev1.TLSPrivateKeyKey: []byte("test")},
+			},
+			reason:  MissingData,
+			message: "Issuing certificate as Secret does not contain a certificate",
+			reissue: true,
+		},
+		"trigger issuance as Secret contains corrupt private key and certificate data": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: []byte("test"),
+					corev1.TLSCertKey:       []byte("test"),
+				},
+			},
+			reason:  InvalidKeyPair,
+			message: "Issuing certificate as Secret contains an invalid key-pair: tls: failed to find any PEM data in certificate input",
+			reissue: true,
+		},
+		"trigger issuance as Secret contains corrupt certificate data": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: testcrypto.MustCreatePEMPrivateKey(t),
+					corev1.TLSCertKey:       []byte("test"),
+				},
+			},
+			reason:  InvalidKeyPair,
+			message: "Issuing certificate as Secret contains an invalid key-pair: tls: failed to find any PEM data in certificate input",
+			reissue: true,
+		},
+		"trigger issuance as Secret contains corrupt private key data": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: []byte("invalid"),
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, testcrypto.MustCreatePEMPrivateKey(t),
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+					),
+				},
+			},
+			reason:  InvalidKeyPair,
+			message: "Issuing certificate as Secret contains an invalid key-pair: tls: failed to find any PEM data in key input",
+			reissue: true,
+		},
+		"trigger issuance as Secret contains a non-matching key-pair": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: testcrypto.MustCreatePEMPrivateKey(t),
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, testcrypto.MustCreatePEMPrivateKey(t),
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+					),
+				},
+			},
+			reason:  InvalidKeyPair,
+			message: "Issuing certificate as Secret contains an invalid key-pair: tls: private key does not match public key",
+			reissue: true,
+		},
+		"trigger issuance as Secret has old/incorrect 'issuer name' annotation": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				SecretName: "something",
+				IssuerRef: cmmeta.ObjectReference{
+					Name: "testissuer",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey: "oldissuer",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+					),
+				},
+			},
+			reason:  IncorrectIssuer,
+			message: "Issuing certificate as Secret was previously issued by Issuer.cert-manager.io/oldissuer",
+			reissue: true,
+		},
+		"trigger issuance as Secret has old/incorrect 'issuer kind' annotation": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				SecretName: "something",
+				IssuerRef: cmmeta.ObjectReference{
+					Name: "testissuer",
+					Kind: "NewIssuerKind",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey: "testissuer",
+						cmapi.IssuerKindAnnotationKey: "OldIssuerKind",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+					),
+				},
+			},
+			reason:  IncorrectIssuer,
+			message: "Issuing certificate as Secret was previously issued by OldIssuerKind.cert-manager.io/testissuer",
+			reissue: true,
+		},
+		"trigger issuance as Secret has old/incorrect 'issuer group' annotation": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				SecretName: "something",
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "old.example.com",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "new.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+					),
+				},
+			},
+			reason:  IncorrectIssuer,
+			message: "Issuing certificate as Secret was previously issued by IssuerKind.new.example.com/testissuer",
+			reissue: true,
+		},
+		// we only have a basic test here for this as unit tests for the
+		// `certificates.RequestMatchesSpec` function cover all other cases.
+		"trigger issuance when CertificateRequest does not match certificate spec": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				CommonName: "new.example.com",
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "group.example.com",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						// It does not matter what certificate data is stored in the Secret
+						// as the CertificateRequest will be used to determine whether a
+						// re-issuance is required.
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "does-not-matter.example.com"}},
+					),
+				},
+			},
+			request: &cmapi.CertificateRequest{Spec: cmapi.CertificateRequestSpec{
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "group.example.com",
+				},
+				Request: testcrypto.MustGenerateCSRImpl(t, staticFixedPrivateKey, &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+					CommonName: "old.example.com",
+				}}),
+			}},
+			reason:  RequestChanged,
+			message: "Fields on existing CertificateRequest resource not up to date: [spec.commonName]",
+			reissue: true,
+		},
+		"do nothing if CertificateRequest matches spec": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				CommonName: "example.com",
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "group.example.com",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						// It does not matter what certificate data is stored in the Secret
+						// as the CertificateRequest will be used to determine whether a
+						// re-issuance is required.
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "does-not-matter.example.com"}},
+					),
+				},
+			},
+			request: &cmapi.CertificateRequest{Spec: cmapi.CertificateRequestSpec{
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "group.example.com",
+				},
+				Request: testcrypto.MustGenerateCSRImpl(t, staticFixedPrivateKey, &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+					CommonName: "example.com",
+				}}),
+			}},
+		},
+		"compare signed x509 certificate in Secret with spec if CertificateRequest does not exist": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				CommonName: "new.example.com",
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "group.example.com",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "old.example.com"}},
+					),
+				},
+			},
+			reason:  SecretMismatch,
+			message: "Existing issued Secret is not up to date for spec: [spec.commonName]",
+			reissue: true,
+		},
+		"do nothing if signed x509 certificate in Secret matches spec (when request does not exist)": {
+			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
+				CommonName: "example.com",
+				IssuerRef: cmmeta.ObjectReference{
+					Name:  "testissuer",
+					Kind:  "IssuerKind",
+					Group: "group.example.com",
+				},
+			}},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+					),
+				},
+			},
+		},
+		"trigger renewal if renewalTime is right now": {
+			certificate: &cmapi.Certificate{
+				Spec: cmapi.CertificateSpec{
+					CommonName: "example.com",
+					IssuerRef: cmmeta.ObjectReference{
+						Name:  "testissuer",
+						Kind:  "IssuerKind",
+						Group: "group.example.com",
+					},
+					RenewBefore: &metav1.Duration{Duration: time.Minute * 5},
+				},
+				Status: cmapi.CertificateStatus{
+					RenewalTime: &metav1.Time{Time: clock.Now()},
+				},
+			},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+						clock.Now().Add(time.Minute*-30),
+						// expires in 1 minute time
+						clock.Now().Add(time.Minute*1),
+					),
+				},
+			},
+			reason:  Renewing,
+			message: "Renewing certificate as renewal was scheduled at 0001-01-01 00:00:00 +0000 UTC",
+			reissue: true,
+		},
+		"trigger renewal if renewalTime is in the past": {
+			certificate: &cmapi.Certificate{
+				Spec: cmapi.CertificateSpec{
+					CommonName: "example.com",
+					IssuerRef: cmmeta.ObjectReference{
+						Name:  "testissuer",
+						Kind:  "IssuerKind",
+						Group: "group.example.com",
+					},
+					RenewBefore: &metav1.Duration{Duration: time.Minute * 5},
+				},
+				Status: cmapi.CertificateStatus{
+					RenewalTime: &metav1.Time{Time: clock.Now().Add(-1 * time.Minute)},
+				},
+			},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+						clock.Now().Add(time.Minute*-30),
+						// expires in 1 minute time
+						clock.Now().Add(time.Minute*1),
+					),
+				},
+			},
+			reason:  Renewing,
+			message: "Renewing certificate as renewal was scheduled at 0000-12-31 23:59:00 +0000 UTC",
+			reissue: true,
+		},
+		"does not trigger renewal if the x509 cert has been re-issued, but Certificate's renewal time has not been updated yet": {
+			certificate: &cmapi.Certificate{
+				Spec: cmapi.CertificateSpec{
+					CommonName: "example.com",
+					IssuerRef: cmmeta.ObjectReference{
+						Name:  "testissuer",
+						Kind:  "IssuerKind",
+						Group: "group.example.com",
+					},
+					RenewBefore: &metav1.Duration{Duration: time.Minute * 1},
+				},
+				Status: cmapi.CertificateStatus{
+					RenewalTime: &metav1.Time{Time: clock.Now()},
+				},
+			},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+						clock.Now(),
+						// expires in 30 minutes time
+						clock.Now().Add(time.Minute*30),
+					),
+				},
+			},
+		},
+		"does not trigger renewal if renewal time is in 1 minute": {
+			certificate: &cmapi.Certificate{
+				Spec: cmapi.CertificateSpec{
+					CommonName: "example.com",
+					IssuerRef: cmmeta.ObjectReference{
+						Name:  "testissuer",
+						Kind:  "IssuerKind",
+						Group: "group.example.com",
+					},
+					RenewBefore: &metav1.Duration{Duration: time.Minute * 1},
+				},
+				Status: cmapi.CertificateStatus{
+					RenewalTime: &metav1.Time{Time: clock.Now().Add(time.Minute)},
+				},
+			},
+			secret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{Name: "something",
+					Annotations: map[string]string{
+						cmapi.IssuerNameAnnotationKey:  "testissuer",
+						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
+						cmapi.IssuerGroupAnnotationKey: "group.example.com",
+					},
+				},
+				Data: map[string][]byte{
+					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
+					corev1.TLSCertKey: testcrypto.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
+						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
+						clock.Now().Add(time.Minute*-30),
+						// expires in 5 minutes time
+						clock.Now().Add(time.Minute*5),
+					),
+				},
+			},
+		},
+	}
+	policyChain := NewTriggerPolicyChain(clock)
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			reason, message, reissue := policyChain.Evaluate(Input{
+				Certificate:            test.certificate,
+				CurrentRevisionRequest: test.request,
+				Secret:                 test.secret,
+			})
+
+			if test.reason != reason {
+				t.Errorf("unexpected 'reason' exp=%s, got=%s", test.reason, reason)
+			}
+			if test.message != message {
+				t.Errorf("unexpected 'message' exp=%s, got=%s", test.message, message)
+			}
+			if test.reissue != reissue {
+				t.Errorf("unexpected 'reissue' exp=%v, got=%v", test.reissue, reissue)
+			}
+		})
+	}
+}
+
+func Test_SecretTemplateMismatchesSecret(t *testing.T) {
+	tests := map[string]struct {
+		tmpl         *cmapi.CertificateSecretTemplate
+		secret       *corev1.Secret
+		expViolation bool
+		expReason    string
+		expMessage   string
+	}{
+		"if SecretTemplate is nil, Secret Annotations and Labels are nil, return false": {
+			tmpl:         nil,
+			secret:       &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Annotations: nil, Labels: nil}},
+			expViolation: false,
+			expReason:    "",
+			expMessage:   "",
+		},
+		"if SecretTemplate is nil, Secret Annotations are nil, Labels are non-nil, return false": {
+			tmpl:         nil,
+			secret:       &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Annotations: nil, Labels: map[string]string{"foo": "bar"}}},
+			expViolation: false,
+			expReason:    "",
+			expMessage:   "",
+		},
+		"if SecretTemplate is nil, Secret Annotations are non-nil, Labels are nil, return false": {
+			tmpl:         nil,
+			secret:       &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{"foo": "bar"}, Labels: nil}},
+			expViolation: false,
+			expReason:    "",
+			expMessage:   "",
+		},
+		"if SecretTemplate is nil, Secret Annotations and Labels are non-nil, return false": {
+			tmpl: nil,
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo": "bar"},
+				Labels:      map[string]string{"bar": "foo"},
+			}},
+			expViolation: false,
+			expReason:    "",
+			expMessage:   "",
+		},
+		"if SecretTemplate is non-nil, Secret Annotations match but Labels are nil, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      nil,
+			}},
+			expViolation: true,
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate Labels missing or incorrect value on Secret",
+		},
+		"if SecretTemplate is non-nil, Secret Labels match but Annotations are nil, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: nil,
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			}},
+			expViolation: true,
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate Annotations missing or incorrect value on Secret",
+		},
+		"if SecretTemplate is non-nil, Secret Labels match but Annotations don't match keys, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo2": "bar1", "foo1": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			}},
+			expViolation: true,
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate Annotations missing or incorrect value on Secret",
+		},
+		"if SecretTemplate is non-nil, Secret Annoations match but Labels don't match keys, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"def": "123", "abc": "456"},
+			}},
+			expViolation: true,
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate Labels missing or incorrect value on Secret",
+		},
+		"if SecretTemplate is non-nil, Secret Labels match but Annotations don't match values, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo1": "bar2", "foo2": "bar1"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			}},
+			expViolation: true,
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate Annotations missing or incorrect value on Secret",
+		},
+		"if SecretTemplate is non-nil, Secret Annotations match but Labels don't match values, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "456", "def": "123"},
+			}},
+			expViolation: true,
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate Labels missing or incorrect value on Secret",
+		},
+		"if SecretTemplate is non-nil, Secret Annotations and Labels match, return false": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			}},
+			expViolation: false,
+			expReason:    "",
+			expMessage:   "",
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			gotReason, gotMessage, gotViolation := SecretTemplateMismatchesSecret(Input{
+				Certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretTemplate: test.tmpl}},
+				Secret:      test.secret,
+			})
+
+			assert.Equal(t, test.expReason, gotReason, "unexpected reason")
+			assert.Equal(t, test.expMessage, gotMessage, "unexpected message")
+			assert.Equal(t, test.expViolation, gotViolation, "unexpected violation")
+		})
+	}
+}
+
+func Test_SecretTemplateMismatchesSecretManagedFields(t *testing.T) {
+	const fieldManager = "cert-manager-unit-test"
+
+	var (
+		fixedClockStart = time.Now()
+		fixedClock      = fakeclock.NewFakeClock(fixedClockStart)
+		baseCertBundle  = testcrypto.MustCreateCryptoBundle(t,
+			gen.Certificate("test-certificate", gen.SetCertificateCommonName("cert-manager")), fixedClock)
+	)
+
+	tests := map[string]struct {
+		tmpl                *cmapi.CertificateSecretTemplate
+		secretManagedFields []metav1.ManagedFieldsEntry
+		secretData          map[string][]byte
+
+		expReason    string
+		expMessage   string
+		expViolation bool
+	}{
+		"if template is nil and no managed fields, should return false": {
+			tmpl:                nil,
+			secretManagedFields: nil,
+			expReason:           "",
+			expMessage:          "",
+			expViolation:        false,
+		},
+		"if template is nil, managed fields is not nil but not managed by cert-manager, should return false": {
+			tmpl: nil,
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: "not-cert-manager", FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:bar": {}
+							},
+							"f:labels": {
+								"f:123": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    "",
+			expMessage:   "",
+			expViolation: false,
+		},
+		"if template is nil, managed fields is not nil but fields are nil, should return false": {
+			tmpl:                nil,
+			secretManagedFields: []metav1.ManagedFieldsEntry{{Manager: fieldManager, FieldsV1: nil}},
+			expReason:           "",
+			expMessage:          "",
+			expViolation:        false,
+		},
+		"if template is not-nil but managed fields is nil, should return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo": "bar"},
+				Labels:      map[string]string{"abc": "123"},
+			},
+			secretManagedFields: nil,
+			expReason:           SecretTemplateMismatch,
+			expMessage:          "Certificate's SecretTemplate doesn't match Secret",
+			expViolation:        true,
+		},
+		"if template is nil but managed fields is not nil, should return true": {
+			tmpl: nil,
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo": {}
+							},
+							"f:labels": {
+								"f:abc": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "SecretTemplate is nil, but Secret contains extra managed entries",
+			expViolation: true,
+		},
+		"if template annotations do not match managed fields, should return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo3": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+		"if template labels do not match managed fields, should return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:erg": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+		"if template annotations and labels match managed fields, should return false": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    "",
+			expMessage:   "",
+			expViolation: false,
+		},
+		"if template annotations is a subset of managed fields, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {},
+								"f:foo3": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+		"if template labels is a subset of managed fields, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {},
+								"f:ghi": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+		"if managed fields annotations is a subset of template, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2", "foo3": "bar3"},
+				Labels:      map[string]string{"abc": "123", "def": "456"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+		"if managed fields labels is a subset of template, return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+				Labels:      map[string]string{"abc": "123", "def": "456", "ghi": "789"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{{
+				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+		"if managed fields matches template but is split across multiple managed fields, should return false": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2", "foo3": "bar3"},
+				Labels:      map[string]string{"abc": "123", "def": "456", "ghi": "789"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{
+				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:labels": {
+								"f:ghi": {}
+							}
+						}}`),
+				}},
+				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo3": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+				}},
+				{Manager: fieldManager,
+					FieldsV1: &metav1.FieldsV1{
+						Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {}
+							},
+							"f:labels": {
+								"f:abc": {},
+								"f:def": {}
+							}
+						}}`),
+					}},
+			},
+			expReason:    "",
+			expMessage:   "",
+			expViolation: false,
+		},
+		"if managed fields matches template and base cert-manager annotations are present with no certificate data, should return false": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{
+				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {},
+								"f:cert-manager.io/certificate-name": {},
+								"f:cert-manager.io/issuer-name": {},
+								"f:cert-manager.io/issuer-kind": {},
+								"f:cert-manager.io/issuer-group": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    "",
+			expMessage:   "",
+			expViolation: false,
+		},
+		"if managed fields matches template and base cert-manager annotations are present with certificate data, should return false": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{
+				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {},
+								"f:cert-manager.io/certificate-name": {},
+								"f:cert-manager.io/issuer-name": {},
+								"f:cert-manager.io/issuer-kind": {},
+								"f:cert-manager.io/issuer-group": {},
+								"f:cert-manager.io/common-name": {},
+								"f:cert-manager.io/alt-names":  {},
+								"f:cert-manager.io/ip-sans": {},
+								"f:cert-manager.io/uri-sans": {}
+							}
+						}}`),
+				}},
+			},
+			secretData:   map[string][]byte{corev1.TLSCertKey: baseCertBundle.CertBytes},
+			expViolation: false,
+		},
+		"if managed fields matches template and base cert-manager annotations are present with certificate data but certificate data is nil, should return true": {
+			tmpl: &cmapi.CertificateSecretTemplate{
+				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
+			},
+			secretManagedFields: []metav1.ManagedFieldsEntry{
+				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
+					Raw: []byte(`{"f:metadata": {
+							"f:annotations": {
+								"f:foo1": {},
+								"f:foo2": {},
+								"f:cert-manager.io/certificate-name": {},
+								"f:cert-manager.io/issuer-name": {},
+								"f:cert-manager.io/issuer-kind": {},
+								"f:cert-manager.io/issuer-group": {},
+								"f:cert-manager.io/common-name": {},
+								"f:cert-manager.io/alt-names":  {},
+								"f:cert-manager.io/ip-sans": {},
+								"f:cert-manager.io/uri-sans": {}
+							}
+						}}`),
+				}},
+			},
+			expReason:    SecretTemplateMismatch,
+			expMessage:   "Certificate's SecretTemplate doesn't match Secret",
+			expViolation: true,
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			gotReason, gotMessage, gotViolation := SecretTemplateMismatchesSecretManagedFields(fieldManager)(Input{
+				Certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretTemplate: test.tmpl}},
+				Secret:      &corev1.Secret{ObjectMeta: metav1.ObjectMeta{ManagedFields: test.secretManagedFields}, Data: test.secretData},
+			})
+
+			assert.Equal(t, test.expReason, gotReason, "unexpected reason")
+			assert.Equal(t, test.expMessage, gotMessage, "unexpected message")
+			assert.Equal(t, test.expViolation, gotViolation, "unexpected violation")
+		})
+	}
+}
diff --git a/pkg/controller/certificates/trigger/policies/constants.go b/internal/controller/certificates/policies/constants.go
similarity index 74%
rename from pkg/controller/certificates/trigger/policies/constants.go
rename to internal/controller/certificates/policies/constants.go
index 033187235..caa6448b9 100644
--- a/pkg/controller/certificates/trigger/policies/constants.go
+++ b/internal/controller/certificates/policies/constants.go
@@ -26,6 +26,9 @@ const (
 	// InvalidKeyPair is a policy violation reason for a scenario where public
 	// key of certificate does not match private key.
 	InvalidKeyPair string = "InvalidKeyPair"
+	// InvalidCertificate is a policy violation whereby the signed certificate in
+	// the Input Secret could not be parsed or decoded.
+	InvalidCertificate string = "InvalidCertificate"
 	// SecretMismatch is a policy violation reason for a scenario where Secret's
 	// private key does not match spec.
 	SecretMismatch string = "SecretMismatch"
@@ -41,4 +44,11 @@ const (
 	// Expired is a policy violation reason for a scenario where Certificate has
 	// expired.
 	Expired string = "Expired"
+	// SecretTemplateMisMatch is a policy violation whereby the Certificate's
+	// SecretTemplate is not reflected on the target Secret, either by having
+	// extra, missing, or wrong Annotations or Labels.
+	SecretTemplateMismatch string = "SecretTemplateMismatch"
+	// ManagedFieldsParseError is a policy violation whereby cert-manager was
+	// unable to decode the managed fields on a resource.
+	ManagedFieldsParseError string = "ManagedFieldsParseError"
 )
diff --git a/pkg/controller/certificates/trigger/policies/gatherer.go b/internal/controller/certificates/policies/gatherer.go
similarity index 100%
rename from pkg/controller/certificates/trigger/policies/gatherer.go
rename to internal/controller/certificates/policies/gatherer.go
diff --git a/pkg/controller/certificates/trigger/policies/gatherer_test.go b/internal/controller/certificates/policies/gatherer_test.go
similarity index 100%
rename from pkg/controller/certificates/trigger/policies/gatherer_test.go
rename to internal/controller/certificates/policies/gatherer_test.go
diff --git a/internal/controller/certificates/policies/policies.go b/internal/controller/certificates/policies/policies.go
new file mode 100644
index 000000000..591c164b9
--- /dev/null
+++ b/internal/controller/certificates/policies/policies.go
@@ -0,0 +1,110 @@
+/*
+Copyright 2020 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+//Package policies provides functionality to evaluate Certificate's state
+package policies
+
+import (
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/utils/clock"
+
+	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
+)
+
+type Input struct {
+	Certificate *cmapi.Certificate
+	Secret      *corev1.Secret
+
+	// The "current" certificate request designates the certificate request that
+	// led to the current revision of the certificate. The "current" certificate
+	// request is by definition in a ready state, and can be seen as the source
+	// of information of the current certificate. Take a look at the gatherer
+	// package's documentation to see more about why we care about the "current"
+	// certificate request.
+	CurrentRevisionRequest *cmapi.CertificateRequest
+
+	// The "next" certificate request is the one that is currently being issued.
+	// Take a look at the gatherer package's documentation to see more about why
+	// we care about the "next" certificate request.
+	NextRevisionRequest *cmapi.CertificateRequest
+}
+
+// A Func evaluates the given input data and decides whether a check has passed
+// or failed, returning additional human readable information in the 'reason'
+// and 'message' return parameters if so.
+type Func func(Input) (reason, message string, failed bool)
+
+// A Chain of PolicyFuncs to be evaluated in order.
+type Chain []Func
+
+// Evaluate will evaluate the entire policy chain using the provided input.
+// As soon as it is discovered that the input violates one policy,
+// Evaluate will return and not evaluate the rest of the chain.
+func (c Chain) Evaluate(input Input) (string, string, bool) {
+	for _, policyFunc := range c {
+		reason, message, violationFound := policyFunc(input)
+		if violationFound {
+			return reason, message, violationFound
+		}
+	}
+	return "", "", false
+}
+
+// NewTriggerPolicyChain includes trigger policy checks, which if return true,
+// should cause a Certificate to be marked for issuance.
+func NewTriggerPolicyChain(c clock.Clock) Chain {
+	return Chain{
+		SecretDoesNotExist,
+		SecretIsMissingData,
+		SecretPublicKeysDiffer,
+		SecretPrivateKeyMatchesSpec,
+		SecretIssuerAnnotationsNotUpToDate,
+		CurrentCertificateRequestNotValidForSpec,
+		CurrentCertificateNearingExpiry(c),
+	}
+}
+
+// NewReadinessPolicyChain includes readiness policy checks, which if return
+// true, would cause a Certificate to be marked as not ready.
+func NewReadinessPolicyChain(c clock.Clock) Chain {
+	return Chain{
+		SecretDoesNotExist,
+		SecretIsMissingData,
+		SecretPublicKeysDiffer,
+		CurrentCertificateRequestNotValidForSpec,
+		CurrentCertificateHasExpired(c),
+	}
+}
+
+// NewSecretPostIssuancePolicyChain includes policy checks that are to be
+// performed _after_ issuance has been successful, testing for the presence and
+// correctness of metadata and output formats of Certificate's Secrets.
+func NewSecretPostIssuancePolicyChain(fieldManager string) Chain {
+	return Chain{
+		SecretTemplateMismatchesSecret,
+		SecretTemplateMismatchesSecretManagedFields(fieldManager),
+	}
+}
+
+// NewTemporaryCertificatePolicyChain includes policy checks for ensuing a
+// temporary certificate is valid.
+func NewTemporaryCertificatePolicyChain() Chain {
+	return Chain{
+		SecretDoesNotExist,
+		SecretIsMissingData,
+		SecretPublicKeysDiffer,
+	}
+}
diff --git a/internal/controller/certificates/secrets.go b/internal/controller/certificates/secrets.go
new file mode 100644
index 000000000..e275fc85b
--- /dev/null
+++ b/internal/controller/certificates/secrets.go
@@ -0,0 +1,50 @@
+/*
+Copyright 2020 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package certificates
+
+import (
+	"crypto/x509"
+	"strings"
+
+	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
+	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
+	utilpki "github.com/jetstack/cert-manager/pkg/util/pki"
+)
+
+// AnnotationsForCertificateSecret returns a map which is set on all
+// Certificate Secret's Annotations when issued. These annotations contain
+// information about the Issuer and Certificate.
+// If the X.509 certificate is not-nil, additional annotations will be added
+// relating to its Common Name and Subject Alternative Names.
+func AnnotationsForCertificateSecret(crt *cmapi.Certificate, certificate *x509.Certificate) map[string]string {
+	annotations := make(map[string]string)
+
+	annotations[cmapi.CertificateNameKey] = crt.Name
+	annotations[cmapi.IssuerNameAnnotationKey] = crt.Spec.IssuerRef.Name
+	annotations[cmapi.IssuerKindAnnotationKey] = apiutil.IssuerKind(crt.Spec.IssuerRef)
+	annotations[cmapi.IssuerGroupAnnotationKey] = crt.Spec.IssuerRef.Group
+
+	// Only add certificate data if certificate is non-nil.
+	if certificate != nil {
+		annotations[cmapi.CommonNameAnnotationKey] = certificate.Subject.CommonName
+		annotations[cmapi.AltNamesAnnotationKey] = strings.Join(certificate.DNSNames, ",")
+		annotations[cmapi.IPSANAnnotationKey] = strings.Join(utilpki.IPAddressesToString(certificate.IPAddresses), ",")
+		annotations[cmapi.URISANAnnotationKey] = strings.Join(utilpki.URLsToString(certificate.URIs), ",")
+	}
+
+	return annotations
+}
diff --git a/internal/controller/certificates/secrets_test.go b/internal/controller/certificates/secrets_test.go
new file mode 100644
index 000000000..139473587
--- /dev/null
+++ b/internal/controller/certificates/secrets_test.go
@@ -0,0 +1,163 @@
+/*
+Copyright 2020 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package certificates
+
+import (
+	"crypto/x509"
+	"crypto/x509/pkix"
+	"net"
+	"net/url"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+
+	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
+	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
+	"github.com/jetstack/cert-manager/test/unit/gen"
+)
+
+func Test_AnnotationsForCertificateSecret(t *testing.T) {
+	var urls []*url.URL
+	for _, u := range []string{"spiffe.io//cert-manager.io/test", "spiffe.io//hello.world"} {
+		url, err := url.Parse(u)
+		assert.NoError(t, err)
+		urls = append(urls, url)
+	}
+
+	tests := map[string]struct {
+		crt            *cmapi.Certificate
+		certificate    *x509.Certificate
+		expAnnotations map[string]string
+	}{
+		"if pass non-nil certificate, expect all Annotations to be present": {
+			crt: gen.Certificate("test-certificate",
+				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "another-test-issuer", Kind: "GoogleCASIssuer", Group: "my-group.hello.world"}),
+			),
+			certificate: &x509.Certificate{
+				Subject: pkix.Name{
+					CommonName: "cert-manager",
+				},
+				DNSNames:    []string{"example.com", "cert-manager.io"},
+				IPAddresses: []net.IP{{1, 1, 1, 1}, {1, 2, 3, 4}},
+				URIs:        urls,
+			},
+			expAnnotations: map[string]string{
+				"cert-manager.io/certificate-name": "test-certificate",
+				"cert-manager.io/issuer-name":      "another-test-issuer",
+				"cert-manager.io/issuer-kind":      "GoogleCASIssuer",
+				"cert-manager.io/issuer-group":     "my-group.hello.world",
+				"cert-manager.io/common-name":      "cert-manager",
+				"cert-manager.io/alt-names":        "example.com,cert-manager.io",
+				"cert-manager.io/ip-sans":          "1.1.1.1,1.2.3.4",
+				"cert-manager.io/uri-sans":         "spiffe.io//cert-manager.io/test,spiffe.io//hello.world",
+			},
+		},
+		"if pass non-nil certificate with only CommonName, expect all Annotations to be present": {
+			crt: gen.Certificate("test-certificate",
+				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "another-test-issuer", Kind: "GoogleCASIssuer", Group: "my-group.hello.world"}),
+			),
+			certificate: &x509.Certificate{
+				Subject: pkix.Name{
+					CommonName: "cert-manager",
+				},
+			},
+			expAnnotations: map[string]string{
+				"cert-manager.io/certificate-name": "test-certificate",
+				"cert-manager.io/issuer-name":      "another-test-issuer",
+				"cert-manager.io/issuer-kind":      "GoogleCASIssuer",
+				"cert-manager.io/issuer-group":     "my-group.hello.world",
+				"cert-manager.io/common-name":      "cert-manager",
+				"cert-manager.io/alt-names":        "",
+				"cert-manager.io/ip-sans":          "",
+				"cert-manager.io/uri-sans":         "",
+			},
+		},
+		"if pass non-nil certificate with only IP Addresses, expect all Annotations to be present": {
+			crt: gen.Certificate("test-certificate",
+				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "another-test-issuer", Kind: "GoogleCASIssuer", Group: "my-group.hello.world"}),
+			),
+			certificate: &x509.Certificate{
+				IPAddresses: []net.IP{{1, 1, 1, 1}, {1, 2, 3, 4}},
+			},
+			expAnnotations: map[string]string{
+				"cert-manager.io/certificate-name": "test-certificate",
+				"cert-manager.io/issuer-name":      "another-test-issuer",
+				"cert-manager.io/issuer-kind":      "GoogleCASIssuer",
+				"cert-manager.io/issuer-group":     "my-group.hello.world",
+				"cert-manager.io/common-name":      "",
+				"cert-manager.io/alt-names":        "",
+				"cert-manager.io/ip-sans":          "1.1.1.1,1.2.3.4",
+				"cert-manager.io/uri-sans":         "",
+			},
+		},
+		"if pass non-nil certificate with only URI SANs, expect all Annotations to be present": {
+			crt: gen.Certificate("test-certificate",
+				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "another-test-issuer", Kind: "GoogleCASIssuer", Group: "my-group.hello.world"}),
+			),
+			certificate: &x509.Certificate{
+				URIs: urls,
+			},
+			expAnnotations: map[string]string{
+				"cert-manager.io/certificate-name": "test-certificate",
+				"cert-manager.io/issuer-name":      "another-test-issuer",
+				"cert-manager.io/issuer-kind":      "GoogleCASIssuer",
+				"cert-manager.io/issuer-group":     "my-group.hello.world",
+				"cert-manager.io/common-name":      "",
+				"cert-manager.io/alt-names":        "",
+				"cert-manager.io/ip-sans":          "",
+				"cert-manager.io/uri-sans":         "spiffe.io//cert-manager.io/test,spiffe.io//hello.world",
+			},
+		},
+		"if pass non-nil certificate with only DNS names, expect all Annotations to be present": {
+			crt: gen.Certificate("test-certificate",
+				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "another-test-issuer", Kind: "GoogleCASIssuer", Group: "my-group.hello.world"}),
+			),
+			certificate: &x509.Certificate{
+				DNSNames: []string{"example.com", "cert-manager.io"},
+			},
+			expAnnotations: map[string]string{
+				"cert-manager.io/certificate-name": "test-certificate",
+				"cert-manager.io/issuer-name":      "another-test-issuer",
+				"cert-manager.io/issuer-kind":      "GoogleCASIssuer",
+				"cert-manager.io/issuer-group":     "my-group.hello.world",
+				"cert-manager.io/common-name":      "",
+				"cert-manager.io/alt-names":        "example.com,cert-manager.io",
+				"cert-manager.io/ip-sans":          "",
+				"cert-manager.io/uri-sans":         "",
+			},
+		},
+		"if no certificate data, then expect no X.509 related annotations": {
+			crt: gen.Certificate("test-certificate",
+				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "test-issuer", Kind: "", Group: "cert-manager.io"}),
+			),
+			certificate: nil,
+			expAnnotations: map[string]string{
+				"cert-manager.io/certificate-name": "test-certificate",
+				"cert-manager.io/issuer-name":      "test-issuer",
+				"cert-manager.io/issuer-kind":      "Issuer",
+				"cert-manager.io/issuer-group":     "cert-manager.io",
+			},
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			gotAnnotations := AnnotationsForCertificateSecret(test.crt, test.certificate)
+			assert.Equal(t, test.expAnnotations, gotAnnotations)
+		})
+	}
+}
diff --git a/pkg/controller/certificates/BUILD.bazel b/pkg/controller/certificates/BUILD.bazel
index 381c70b09..45905de07 100644
--- a/pkg/controller/certificates/BUILD.bazel
+++ b/pkg/controller/certificates/BUILD.bazel
@@ -39,8 +39,6 @@ filegroup(
     name = "all-srcs",
     srcs = [
         ":package-srcs",
-        "//pkg/controller/certificates/internal/secretsmanager:all-srcs",
-        "//pkg/controller/certificates/internal/test:all-srcs",
         "//pkg/controller/certificates/issuing:all-srcs",
         "//pkg/controller/certificates/keymanager:all-srcs",
         "//pkg/controller/certificates/metrics:all-srcs",
diff --git a/pkg/controller/certificates/issuing/BUILD.bazel b/pkg/controller/certificates/issuing/BUILD.bazel
index 9db18f96b..fd7986384 100644
--- a/pkg/controller/certificates/issuing/BUILD.bazel
+++ b/pkg/controller/certificates/issuing/BUILD.bazel
@@ -10,6 +10,7 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/issuing",
     visibility = ["//visibility:public"],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/api/util:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
@@ -18,8 +19,7 @@ go_library(
         "//pkg/client/listers/certmanager/v1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/controller/certificates:go_default_library",
-        "//pkg/controller/certificates/internal/secretsmanager:go_default_library",
-        "//pkg/controller/certificates/trigger/policies:go_default_library",
+        "//pkg/controller/certificates/issuing/internal:go_default_library",
         "//pkg/logs:go_default_library",
         "//pkg/util:go_default_library",
         "//pkg/util/kube:go_default_library",
@@ -30,7 +30,6 @@ go_library(
         "@io_k8s_apimachinery//pkg/api/errors:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/labels:go_default_library",
-        "@io_k8s_apimachinery//pkg/util/sets:go_default_library",
         "@io_k8s_client_go//informers:go_default_library",
         "@io_k8s_client_go//kubernetes:go_default_library",
         "@io_k8s_client_go//listers/core/v1:go_default_library",
@@ -38,9 +37,7 @@ go_library(
         "@io_k8s_client_go//tools/cache:go_default_library",
         "@io_k8s_client_go//tools/record:go_default_library",
         "@io_k8s_client_go//util/workqueue:go_default_library",
-        "@io_k8s_sigs_structured_merge_diff_v4//fieldpath:go_default_library",
         "@io_k8s_utils//clock:go_default_library",
-        "@io_k8s_utils//pointer:go_default_library",
     ],
 )
 
@@ -53,7 +50,10 @@ filegroup(
 
 filegroup(
     name = "all-srcs",
-    srcs = [":package-srcs"],
+    srcs = [
+        ":package-srcs",
+        "//pkg/controller/certificates/issuing/internal:all-srcs",
+    ],
     tags = ["automanaged"],
     visibility = ["//visibility:public"],
 )
@@ -66,11 +66,12 @@ go_test(
     ],
     embed = [":go_default_library"],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
-        "//pkg/controller/certificates/internal/secretsmanager:go_default_library",
-        "//pkg/controller/certificates/internal/test:go_default_library",
+        "//pkg/controller/certificates/issuing/internal:go_default_library",
         "//pkg/controller/test:go_default_library",
+        "//test/unit/crypto:go_default_library",
         "//test/unit/gen:go_default_library",
         "@com_github_stretchr_testify//assert:go_default_library",
         "@com_github_stretchr_testify//require:go_default_library",
diff --git a/pkg/controller/certificates/internal/secretsmanager/BUILD.bazel b/pkg/controller/certificates/issuing/internal/BUILD.bazel
similarity index 95%
rename from pkg/controller/certificates/internal/secretsmanager/BUILD.bazel
rename to pkg/controller/certificates/issuing/internal/BUILD.bazel
index dbaa51a31..05e2cfced 100644
--- a/pkg/controller/certificates/internal/secretsmanager/BUILD.bazel
+++ b/pkg/controller/certificates/issuing/internal/BUILD.bazel
@@ -6,11 +6,11 @@ go_library(
         "keystore.go",
         "secret.go",
     ],
-    importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/secretsmanager",
+    importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/issuing/internal",
     visibility = ["//pkg/controller/certificates:__subpackages__"],
     deps = [
+        "//internal/controller/certificates:go_default_library",
         "//internal/controller/feature:go_default_library",
-        "//pkg/api/util:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
         "//pkg/logs:go_default_library",
@@ -42,11 +42,11 @@ go_test(
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
         "//pkg/controller:go_default_library",
-        "//pkg/controller/certificates/internal/test:go_default_library",
         "//pkg/controller/test:go_default_library",
         "//pkg/util/feature:go_default_library",
         "//pkg/util/pki:go_default_library",
         "//test/unit/coreclients:go_default_library",
+        "//test/unit/crypto:go_default_library",
         "//test/unit/gen:go_default_library",
         "//test/unit/listers:go_default_library",
         "@com_github_google_gofuzz//:go_default_library",
diff --git a/pkg/controller/certificates/internal/secretsmanager/keystore.go b/pkg/controller/certificates/issuing/internal/keystore.go
similarity index 99%
rename from pkg/controller/certificates/internal/secretsmanager/keystore.go
rename to pkg/controller/certificates/issuing/internal/keystore.go
index 51dbc186b..061bd809f 100644
--- a/pkg/controller/certificates/internal/secretsmanager/keystore.go
+++ b/pkg/controller/certificates/issuing/internal/keystore.go
@@ -20,7 +20,7 @@ limitations under the License.
 // release.
 // This should hopefully not exist by the next time you come to read this :)
 
-package secretsmanager
+package internal
 
 import (
 	"bytes"
diff --git a/pkg/controller/certificates/internal/secretsmanager/keystore_test.go b/pkg/controller/certificates/issuing/internal/keystore_test.go
similarity index 99%
rename from pkg/controller/certificates/internal/secretsmanager/keystore_test.go
rename to pkg/controller/certificates/issuing/internal/keystore_test.go
index 674350e81..56a971448 100644
--- a/pkg/controller/certificates/internal/secretsmanager/keystore_test.go
+++ b/pkg/controller/certificates/issuing/internal/keystore_test.go
@@ -14,7 +14,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */
 
-package secretsmanager
+package internal
 
 import (
 	"bytes"
diff --git a/pkg/controller/certificates/internal/secretsmanager/secret.go b/pkg/controller/certificates/issuing/internal/secret.go
similarity index 85%
rename from pkg/controller/certificates/internal/secretsmanager/secret.go
rename to pkg/controller/certificates/issuing/internal/secret.go
index ef631acfa..29fdd8cb6 100644
--- a/pkg/controller/certificates/internal/secretsmanager/secret.go
+++ b/pkg/controller/certificates/issuing/internal/secret.go
@@ -14,14 +14,14 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */
 
-package secretsmanager
+package internal
 
 import (
 	"bytes"
 	"context"
+	"crypto/x509"
 	"encoding/pem"
 	"fmt"
-	"strings"
 
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
@@ -32,8 +32,8 @@ import (
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/rest"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates"
 	"github.com/jetstack/cert-manager/internal/controller/feature"
-	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
@@ -67,10 +67,10 @@ type SecretData struct {
 	PrivateKey, Certificate, CA []byte
 }
 
-// New returns a new SecretsManager. Setting enableSecretOwnerReferences to
-// true will mean that secrets will be deleted when the corresponding
-// Certificate is deleted.
-func New(
+// NewSecretsManager returns a new SecretsManager. Setting
+// enableSecretOwnerReferences to true will mean that secrets will be deleted
+// when the corresponding Certificate is deleted.
+func NewSecretsManager(
 	secretClient coreclient.SecretsGetter,
 	secretLister corelisters.SecretLister,
 	restConfig *rest.Config,
@@ -137,34 +137,6 @@ func (s *SecretsManager) UpdateData(ctx context.Context, crt *cmapi.Certificate,
 	return err
 }
 
-// SecretCertificateAnnotations returns a map which should be set on all
-// Certificate Secret's Annotations, containing information about the Issuer
-// and Certificate.
-func SecretCertificateAnnotations(crt *cmapi.Certificate, data SecretData) (map[string]string, error) {
-	annotations := make(map[string]string)
-
-	annotations[cmapi.CertificateNameKey] = crt.Name
-	annotations[cmapi.IssuerNameAnnotationKey] = crt.Spec.IssuerRef.Name
-	annotations[cmapi.IssuerKindAnnotationKey] = apiutil.IssuerKind(crt.Spec.IssuerRef)
-	annotations[cmapi.IssuerGroupAnnotationKey] = crt.Spec.IssuerRef.Group
-
-	// Only add certificate data if it exists
-	if len(data.Certificate) > 0 {
-		x509Cert, err := utilpki.DecodeX509CertificateBytes(data.Certificate)
-		// TODO: handle InvalidData here?
-		if err != nil {
-			return nil, err
-		}
-
-		annotations[cmapi.CommonNameAnnotationKey] = x509Cert.Subject.CommonName
-		annotations[cmapi.AltNamesAnnotationKey] = strings.Join(x509Cert.DNSNames, ",")
-		annotations[cmapi.IPSANAnnotationKey] = strings.Join(utilpki.IPAddressesToString(x509Cert.IPAddresses), ",")
-		annotations[cmapi.URISANAnnotationKey] = strings.Join(utilpki.URLsToString(x509Cert.URIs), ",")
-	}
-
-	return annotations, nil
-}
-
 // setValues will update the Secret resource 'secret' with the data contained
 // in the given secretData.
 // It will update labels and annotations on the Secret resource appropriately.
@@ -191,14 +163,17 @@ func (s *SecretsManager) setValues(crt *cmapi.Certificate, secret *corev1.Secret
 		secret.Data[cmmeta.TLSCAKey] = data.CA
 	}
 
-	annotations, err := SecretCertificateAnnotations(crt, data)
-	if err != nil {
-		return fmt.Errorf("failed to build Secret annotations: %w", err)
+	var certificate *x509.Certificate
+	if len(data.Certificate) > 0 {
+		var err error
+		certificate, err = utilpki.DecodeX509CertificateBytes(data.Certificate)
+		// TODO: handle InvalidData here?
+		if err != nil {
+			return err
+		}
 	}
 
-	if secret.Annotations == nil {
-		secret.Annotations = make(map[string]string)
-	}
+	secret.Annotations = certificates.AnnotationsForCertificateSecret(crt, certificate)
 	if secret.Labels == nil {
 		secret.Labels = make(map[string]string)
 	}
@@ -212,10 +187,6 @@ func (s *SecretsManager) setValues(crt *cmapi.Certificate, secret *corev1.Secret
 		}
 	}
 
-	for k, v := range annotations {
-		secret.Annotations[k] = v
-	}
-
 	return nil
 }
 
@@ -323,8 +294,8 @@ func (s *SecretsManager) setKeystores(crt *cmapi.Certificate, secret *corev1.Sec
 // setAdditionalOutputFormat will set extra Secret Data keys with additional
 // output formats according to any OutputFormats which have been configured.
 func setAdditionalOutputFormats(crt *cmapi.Certificate, secret *corev1.Secret, data SecretData) error {
-	for _, f := range crt.Spec.AdditionalOutputFormats {
-		switch f.Type {
+	for _, format := range crt.Spec.AdditionalOutputFormats {
+		switch format.Type {
 		case cmapi.CertificateOutputFormatDER:
 			// Store binary format of the private key
 			block, _ := pem.Decode(data.PrivateKey)
@@ -333,7 +304,7 @@ func setAdditionalOutputFormats(crt *cmapi.Certificate, secret *corev1.Secret, d
 			// Combine tls.key and tls.crt
 			secret.Data[cmapi.CertificateOutputFormatCombinedPEMKey] = bytes.Join([][]byte{data.PrivateKey, data.Certificate}, []byte("\n"))
 		default:
-			return fmt.Errorf("unknown additional output format %s", f.Type)
+			return fmt.Errorf("unknown additional output format %s", format.Type)
 		}
 	}
 
diff --git a/pkg/controller/certificates/internal/secretsmanager/secret_test.go b/pkg/controller/certificates/issuing/internal/secret_test.go
similarity index 92%
rename from pkg/controller/certificates/internal/secretsmanager/secret_test.go
rename to pkg/controller/certificates/issuing/internal/secret_test.go
index a3cc4c58f..c0affb098 100644
--- a/pkg/controller/certificates/internal/secretsmanager/secret_test.go
+++ b/pkg/controller/certificates/issuing/internal/secret_test.go
@@ -14,7 +14,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */
 
-package secretsmanager
+package internal
 
 import (
 	"context"
@@ -42,9 +42,9 @@ import (
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
-	internaltest "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test"
 	utilpki "github.com/jetstack/cert-manager/pkg/util/pki"
 	testcoreclients "github.com/jetstack/cert-manager/test/unit/coreclients"
+	testcrypto "github.com/jetstack/cert-manager/test/unit/crypto"
 	"github.com/jetstack/cert-manager/test/unit/gen"
 	testcorelisters "github.com/jetstack/cert-manager/test/unit/listers"
 )
@@ -69,7 +69,7 @@ func Test_SecretsManager(t *testing.T) {
 		gen.SetCertificateDNSNames("example.com"),
 		gen.SetCertificateUID(apitypes.UID("test-uid")),
 	)
-	baseCertBundle := internaltest.MustCreateCryptoBundle(t, gen.CertificateFrom(baseCert,
+	baseCertBundle := testcrypto.MustCreateCryptoBundle(t, gen.CertificateFrom(baseCert,
 		gen.SetCertificateDNSNames("example.com"),
 	), fixedClock)
 
@@ -701,7 +701,7 @@ func Test_SecretsManager(t *testing.T) {
 			}
 			secretLister := testcorelisters.NewFakeSecretLister(mod)
 
-			testManager := New(
+			testManager := NewSecretsManager(
 				secretClient, secretLister,
 				&rest.Config{UserAgent: "cert-manager-test"},
 				test.certificateOptions.EnableOwnerRef,
@@ -801,64 +801,3 @@ func Test_getCertificateSecret(t *testing.T) {
 		})
 	}
 }
-
-func Test_SecretCertificateAnnotations(t *testing.T) {
-	baseCertBundle := internaltest.MustCreateCryptoBundle(t, gen.Certificate("test-certificate",
-		gen.SetCertificateCommonName("cert-manager"),
-		gen.SetCertificateDNSNames("example.com", "cert-manager.io"),
-		gen.SetCertificateIPs("1.1.1.1", "1.2.3.4"),
-		gen.SetCertificateURIs("spiffe.io//cert-manager.io/test", "spiffe.io//hello.world"),
-	), fixedClock)
-
-	tests := map[string]struct {
-		crt            *cmapi.Certificate
-		data           SecretData
-		expAnnotations map[string]string
-		expError       bool
-	}{
-		"if data contains valid certificate, expect all Annotations to be present": {
-			crt: gen.CertificateFrom(baseCertBundle.Certificate,
-				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "another-test-issuer", Kind: "GoogleCASIssuer", Group: "my-group.hello.world"}),
-			),
-			data: SecretData{Certificate: baseCertBundle.CertBytes},
-			expAnnotations: map[string]string{
-				"cert-manager.io/certificate-name": "test-certificate",
-				"cert-manager.io/issuer-name":      "another-test-issuer",
-				"cert-manager.io/issuer-kind":      "GoogleCASIssuer",
-				"cert-manager.io/issuer-group":     "my-group.hello.world",
-				"cert-manager.io/common-name":      "cert-manager",
-				"cert-manager.io/alt-names":        "example.com,cert-manager.io",
-				"cert-manager.io/ip-sans":          "1.1.1.1,1.2.3.4",
-				"cert-manager.io/uri-sans":         "spiffe.io//cert-manager.io/test,spiffe.io//hello.world",
-			},
-			expError: false,
-		},
-		"if no certificate data, then expect no X.509 related annotations": {
-			crt: gen.Certificate("test-certificate",
-				gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "test-issuer", Kind: "", Group: "cert-manager.io"}),
-			),
-			data: SecretData{Certificate: nil},
-			expAnnotations: map[string]string{
-				"cert-manager.io/certificate-name": "test-certificate",
-				"cert-manager.io/issuer-name":      "test-issuer",
-				"cert-manager.io/issuer-kind":      "Issuer",
-				"cert-manager.io/issuer-group":     "cert-manager.io",
-			},
-			expError: false,
-		},
-		"if data contains invalid certificate data, expect error": {
-			crt:            gen.Certificate("test-certificate"),
-			data:           SecretData{Certificate: []byte("invalid data")},
-			expAnnotations: nil,
-			expError:       true,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			gotAnnotations, gotErr := SecretCertificateAnnotations(test.crt, test.data)
-			assert.Equal(t, test.expError, gotErr != nil, "%v", gotErr)
-			assert.Equal(t, test.expAnnotations, gotAnnotations)
-		})
-	}
-}
diff --git a/pkg/controller/certificates/issuing/issuing_controller.go b/pkg/controller/certificates/issuing/issuing_controller.go
index 1a492c061..61b2736df 100644
--- a/pkg/controller/certificates/issuing/issuing_controller.go
+++ b/pkg/controller/certificates/issuing/issuing_controller.go
@@ -36,6 +36,7 @@ import (
 	"k8s.io/client-go/util/workqueue"
 	"k8s.io/utils/clock"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
@@ -44,7 +45,7 @@ import (
 	cmlisters "github.com/jetstack/cert-manager/pkg/client/listers/certmanager/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
 	"github.com/jetstack/cert-manager/pkg/controller/certificates"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/internal/secretsmanager"
+	"github.com/jetstack/cert-manager/pkg/controller/certificates/issuing/internal"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 	"github.com/jetstack/cert-manager/pkg/util"
 	utilkube "github.com/jetstack/cert-manager/pkg/util/kube"
@@ -73,11 +74,11 @@ type controller struct {
 	// secretsUpdateData is used by the SecretTemplate controller for
 	// re-reconciling Secrets where the SecretTemplate is not up to date with a
 	// Certificate's secret.
-	secretsUpdateData func(context.Context, *cmapi.Certificate, secretsmanager.SecretData) error
+	secretsUpdateData func(context.Context, *cmapi.Certificate, internal.SecretData) error
 
-	// fieldManager is the string which will be used as the field Manager on
-	// fields created or edited by the cert-manager Kubernetes client.
-	fieldManager string
+	// postIssuancePolicyChain is the policies chain to ensure that all Secret
+	// metadata and output formats are kept are present and correct.
+	postIssuancePolicyChain policies.Chain
 
 	// localTemporarySigner signs a certificate that is stored temporarily
 	localTemporarySigner localTemporarySignerFn
@@ -127,7 +128,7 @@ func NewController(
 		certificateInformer.Informer().HasSynced,
 	}
 
-	secretsManager := secretsmanager.New(
+	secretsManager := internal.NewSecretsManager(
 		kubeClient.CoreV1(), secretsInformer.Lister(),
 		restConfig, certificateControllerOptions.EnableOwnerRef,
 	)
@@ -140,7 +141,7 @@ func NewController(
 		recorder:                 recorder,
 		clock:                    clock,
 		secretsUpdateData:        secretsManager.UpdateData,
-		fieldManager:             util.PrefixFromUserAgent(restConfig.UserAgent),
+		postIssuancePolicyChain:  policies.NewSecretPostIssuancePolicyChain(util.PrefixFromUserAgent(restConfig.UserAgent)),
 		localTemporarySigner:     certificates.GenerateLocallySignedTemporaryCertificate,
 	}, queue, mustSync
 }
@@ -363,7 +364,7 @@ func (c *controller) issueCertificate(ctx context.Context, nextRevision int, crt
 	if err != nil {
 		return err
 	}
-	secretData := secretsmanager.SecretData{
+	secretData := internal.SecretData{
 		PrivateKey:  pkData,
 		Certificate: req.Status.Certificate,
 		CA:          req.Status.CA,
diff --git a/pkg/controller/certificates/issuing/issuing_controller_test.go b/pkg/controller/certificates/issuing/issuing_controller_test.go
index 812d367d4..ae32fe29e 100644
--- a/pkg/controller/certificates/issuing/issuing_controller_test.go
+++ b/pkg/controller/certificates/issuing/issuing_controller_test.go
@@ -33,9 +33,9 @@ import (
 
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/internal/secretsmanager"
-	internaltest "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test"
+	"github.com/jetstack/cert-manager/pkg/controller/certificates/issuing/internal"
 	testpkg "github.com/jetstack/cert-manager/pkg/controller/test"
+	testcrypto "github.com/jetstack/cert-manager/test/unit/crypto"
 	"github.com/jetstack/cert-manager/test/unit/gen"
 )
 
@@ -55,7 +55,7 @@ func TestIssuingController(t *testing.T) {
 		builder *testpkg.Builder
 
 		certificate             *cmapi.Certificate
-		expSecretUpdateDataCall *secretsmanager.SecretData
+		expSecretUpdateDataCall *internal.SecretData
 
 		expectedErr bool
 	}
@@ -71,9 +71,9 @@ func TestIssuingController(t *testing.T) {
 		gen.SetCertificateRevision(1),
 		gen.SetCertificateNextPrivateKeySecretName(nextPrivateKeySecretName),
 	)
-	exampleBundle := internaltest.MustCreateCryptoBundle(t, baseCert.DeepCopy(), fixedClock)
+	exampleBundle := testcrypto.MustCreateCryptoBundle(t, baseCert.DeepCopy(), fixedClock)
 
-	exampleBundleAlt := internaltest.MustCreateCryptoBundle(t, baseCert.DeepCopy(), fixedClock)
+	exampleBundleAlt := testcrypto.MustCreateCryptoBundle(t, baseCert.DeepCopy(), fixedClock)
 	metaFixedClockStart := metav1.NewTime(fixedClockStart)
 
 	issuingCert := gen.CertificateFrom(baseCert.DeepCopy(),
@@ -186,7 +186,7 @@ func TestIssuingController(t *testing.T) {
 				CertManagerObjects: []runtime.Object{
 					issuingCert.DeepCopy(),
 					gen.CertificateRequestFrom(
-						internaltest.MustCreateCryptoBundle(t,
+						testcrypto.MustCreateCryptoBundle(t,
 							gen.CertificateFrom(issuingCert,
 								gen.SetCertificateDNSNames("foo.com"), // Mismatch since the cert has "example.com"
 							), fixedClock,
@@ -452,7 +452,7 @@ func TestIssuingController(t *testing.T) {
 					"Normal Issuing The certificate has been successfully issued",
 				},
 			},
-			expSecretUpdateDataCall: &secretsmanager.SecretData{
+			expSecretUpdateDataCall: &internal.SecretData{
 				Certificate: exampleBundle.CertificateRequestReady.Status.Certificate,
 				PrivateKey:  exampleBundle.PrivateKeyBytes,
 				CA:          nil,
@@ -506,7 +506,7 @@ func TestIssuingController(t *testing.T) {
 					"Normal Issuing The certificate has been successfully issued",
 				},
 			},
-			expSecretUpdateDataCall: &secretsmanager.SecretData{
+			expSecretUpdateDataCall: &internal.SecretData{
 				Certificate: exampleBundle.CertificateRequestReady.Status.Certificate,
 				PrivateKey:  exampleBundle.PrivateKeyBytes,
 				CA:          nil,
@@ -543,7 +543,7 @@ func TestIssuingController(t *testing.T) {
 					"Normal Issuing Issued temporary certificate",
 				},
 			},
-			expSecretUpdateDataCall: &secretsmanager.SecretData{
+			expSecretUpdateDataCall: &internal.SecretData{
 				Certificate: exampleBundle.LocalTemporaryCertificateBytes,
 				PrivateKey:  exampleBundle.PrivateKeyBytes,
 				CA:          nil,
@@ -591,7 +591,7 @@ func TestIssuingController(t *testing.T) {
 					"Normal Issuing Issued temporary certificate",
 				},
 			},
-			expSecretUpdateDataCall: &secretsmanager.SecretData{
+			expSecretUpdateDataCall: &internal.SecretData{
 				Certificate: exampleBundle.LocalTemporaryCertificateBytes,
 				PrivateKey:  exampleBundle.PrivateKeyBytes,
 				CA:          nil,
@@ -688,7 +688,7 @@ func TestIssuingController(t *testing.T) {
 					"Normal Issuing Issued temporary certificate",
 				},
 			},
-			expSecretUpdateDataCall: &secretsmanager.SecretData{
+			expSecretUpdateDataCall: &internal.SecretData{
 				Certificate: exampleBundle.LocalTemporaryCertificateBytes,
 				PrivateKey:  exampleBundle.PrivateKeyBytes,
 				CA:          nil,
@@ -783,7 +783,7 @@ func TestIssuingController(t *testing.T) {
 					"Normal Issuing The certificate has been successfully issued",
 				},
 			},
-			expSecretUpdateDataCall: &secretsmanager.SecretData{
+			expSecretUpdateDataCall: &internal.SecretData{
 				Certificate: exampleBundle.CertificateRequestReady.Status.Certificate,
 				PrivateKey:  exampleBundle.PrivateKeyBytes,
 				CA:          nil,
@@ -915,7 +915,7 @@ func TestIssuingController(t *testing.T) {
 			w.controller.localTemporarySigner = testLocalTemporarySignerFn(exampleBundle.LocalTemporaryCertificateBytes)
 
 			var secretsUpdateDataCalled bool
-			w.controller.secretsUpdateData = func(_ context.Context, _ *cmapi.Certificate, secretData secretsmanager.SecretData) error {
+			w.controller.secretsUpdateData = func(_ context.Context, _ *cmapi.Certificate, secretData internal.SecretData) error {
 				secretsUpdateDataCalled = true
 				assert.Equal(t, *test.expSecretUpdateDataCall, secretData)
 				return nil
diff --git a/pkg/controller/certificates/issuing/secret_manager.go b/pkg/controller/certificates/issuing/secret_manager.go
index be7a73b5e..51d95b22b 100644
--- a/pkg/controller/certificates/issuing/secret_manager.go
+++ b/pkg/controller/certificates/issuing/secret_manager.go
@@ -17,21 +17,17 @@ limitations under the License.
 package issuing
 
 import (
-	"bytes"
 	"context"
-	"fmt"
-	"strings"
+	"errors"
 
 	"github.com/go-logr/logr"
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
-	"k8s.io/apimachinery/pkg/util/sets"
-	"k8s.io/utils/pointer"
-	"sigs.k8s.io/structured-merge-diff/v4/fieldpath"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/internal/secretsmanager"
+	"github.com/jetstack/cert-manager/pkg/controller/certificates/issuing/internal"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 )
 
@@ -57,166 +53,43 @@ func (c *controller) ensureSecretData(ctx context.Context, log logr.Logger, crt
 		return err
 	}
 
-	secret = secret.DeepCopy()
+	log = log.WithValues("secret", secret.Name)
 
-	var data secretsmanager.SecretData
+	var data internal.SecretData
 	if secret.Data != nil {
-		data = secretsmanager.SecretData{
+		data = internal.SecretData{
 			PrivateKey:  secret.Data[corev1.TLSPrivateKeyKey],
 			Certificate: secret.Data[corev1.TLSCertKey],
 			CA:          secret.Data[cmmeta.TLSCAKey],
 		}
 	}
 
-	log = log.WithValues("secret", secret.Name)
-
-	// Check whether the Certificate's SecretTemplate matches that on the Secret.
-	secretTemplateMatchManagedFields, err := c.secretTemplateMatchesManagedFields(crt, secret, data)
-	if err != nil {
-		// An error here indicates that the managed fields are malformed and the
-		// decoder doesn't understand the managed fields on the Secret, or the
-		// signed certificate data could not be decoded. There is nothing more the
-		// controller can do here, so we exit nil so this controller doesn't end in
-		// an infinite loop.
-		log.Error(err, "failed to determine whether the SecretTemplate matches Secret")
-		return nil
-	}
-
-	// - secretTemplateMatchesSecret: If a key or value changed on the
-	// Annotations or Labels in the SecretTemplate, the SecretTemplate will not
-	// match the Annotations or Labels on the Secret.
-	// - secretTemplateMatchManagedFields: If a key was removed on the
-	// SecretTemplate, then the managed fields on the Secret won't match.
-	// In either case, the Secret needs to be re-reconciled with the Secrets
-	// Manager.
-	if !secretTemplateMatchesSecret(crt, secret) || !secretTemplateMatchManagedFields {
-		log.Info("mismatch between SecretTemplate and Secret, updating Secret annotations/labels")
-		return c.secretsUpdateData(ctx, crt, data)
-	}
-
-	// SecretTemplate matches Secret, nothing to do.
-
-	return nil
-}
-
-// secretTemplateMatchesSecret will inspect the given Secret's Annotations and
-// Labels, and compare these maps against those that appear on the given
-// Certificate's SecretTemplate.
-// Returns true if all the Certificate's SecretTemplate Annotations and Labels
-// appear on the Secret, or put another way, the Secret Annotations/Labels are
-// a subset of that in the Certificate's SecretTemplate. Returns false
-// otherwise.
-func secretTemplateMatchesSecret(crt *cmapi.Certificate, secret *corev1.Secret) bool {
-	if crt.Spec.SecretTemplate == nil {
-		return true
-	}
-
-	for kSpec, vSpec := range crt.Spec.SecretTemplate.Annotations {
-		if v, ok := secret.Annotations[kSpec]; !ok || v != vSpec {
-			return false
-		}
-	}
-
-	for kSpec, vSpec := range crt.Spec.SecretTemplate.Labels {
-		if v, ok := secret.Labels[kSpec]; !ok || v != vSpec {
-			return false
+	// Check whether the Certificate's Secret has correct output format and
+	// metadata.
+	reason, message, isViolation := c.postIssuancePolicyChain.Evaluate(policies.Input{
+		Certificate: crt,
+		Secret:      secret,
+	})
+
+	if isViolation {
+		switch reason {
+		case policies.InvalidCertificate, policies.ManagedFieldsParseError:
+			//An error here indicates that the managed fields are malformed and the
+			//decoder doesn't understand the managed fields on the Secret, or the
+			//signed certificate data could not be decoded. There is nothing more the
+			//controller can do here, so we exit nil so this controller doesn't end in
+			//an infinite loop.
+			log.Error(errors.New(message), "failed to determine whether the SecretTemplate matches Secret")
+			return nil
+		default:
+
+			// Here the Certificate need to be re-reconciled.
+			log.Info("applying Secret data", "message", message)
+			return c.secretsUpdateData(ctx, crt, data)
 		}
 	}
 
-	return true
-}
+	// No Secret violations, nothing to do.
 
-// secretTemplateMatchesManagedFields will inspect the given Secret's managed
-// fields for its Annotations and Labels, and compare this against the
-// SecretTemplate on the given Certificate. Returns true if Annotations and
-// Labels match on both the Certificate's SecretTemplate and the Secret's
-// managed fields, false otherwise.
-// An error is returned if the managed fields were not able to be decoded.
-func (c *controller) secretTemplateMatchesManagedFields(crt *cmapi.Certificate, secret *corev1.Secret, data secretsmanager.SecretData) (bool, error) {
-	managedLabels, managedAnnotations := sets.NewString(), sets.NewString()
-
-	// Build the base annotations of the Secret, so we can omit them from the
-	// managed annotations when comparing against the SecretTemplate.
-	baseAnnotations, err := secretsmanager.SecretCertificateAnnotations(crt, data)
-	if err != nil {
-		return false, fmt.Errorf("failed to determine target Secret's base Annotations: %w", err)
-	}
-
-	for _, managedField := range secret.ManagedFields {
-		// If the managed field isn't owned by the cert-manager controller, ignore.
-		if managedField.Manager != c.fieldManager || managedField.FieldsV1 == nil {
-			continue
-		}
-
-		// Decode the managed field.
-		var fieldset fieldpath.Set
-		if err := fieldset.FromJSON(bytes.NewReader(managedField.FieldsV1.Raw)); err != nil {
-			return false, fmt.Errorf("failed to decode the Secret's managed field: %w", err)
-		}
-
-		// Extract the labels and annotations of the managed fields.
-		metadata := fieldset.Children.Descend(fieldpath.PathElement{
-			FieldName: pointer.String("metadata"),
-		})
-		labels := metadata.Children.Descend(fieldpath.PathElement{
-			FieldName: pointer.String("labels"),
-		})
-		annotations := metadata.Children.Descend(fieldpath.PathElement{
-			FieldName: pointer.String("annotations"),
-		})
-
-		// Gather the annotations and labels on the managed fields. Remove the '.'
-		// prefix which appears on managed field keys.
-		labels.Iterate(func(path fieldpath.Path) {
-			managedLabels.Insert(strings.TrimPrefix(path.String(), "."))
-		})
-		annotations.Iterate(func(path fieldpath.Path) {
-			managedAnnotations.Insert(strings.TrimPrefix(path.String(), "."))
-		})
-	}
-
-	// Remove the base Annotations from the managed Annotations so we can compare
-	// 1 to 1 against the SecretTemplate.
-	for k := range baseAnnotations {
-		managedAnnotations = managedAnnotations.Delete(k)
-	}
-
-	// Check early for Secret Template being nil, and whether managed
-	// labels/annotations are not.
-	if crt.Spec.SecretTemplate == nil {
-		if len(managedLabels) > 0 || len(managedAnnotations) > 0 {
-			return false, nil
-		}
-		// SecretTemplate is nil. Managed annotations and labels are also empty.
-		// Return true.
-		return true, nil
-	}
-
-	// SecretTemplate is not nil. Do length checks.
-	if len(crt.Spec.SecretTemplate.Labels) != managedLabels.Len() ||
-		len(crt.Spec.SecretTemplate.Annotations) != managedAnnotations.Len() {
-		return false, nil
-	}
-
-	// Check equal unsorted for SecretTemplate keys, and the managed fields
-	// equivalents.
-	for _, smap := range []struct {
-		specMap    map[string]string
-		managedSet sets.String
-	}{
-		{specMap: crt.Spec.SecretTemplate.Labels, managedSet: managedLabels},
-		{specMap: crt.Spec.SecretTemplate.Annotations, managedSet: managedAnnotations},
-	} {
-
-		specSet := sets.NewString()
-		for kSpec := range smap.specMap {
-			specSet.Insert(kSpec)
-		}
-
-		if !specSet.Equal(smap.managedSet) {
-			return false, nil
-		}
-	}
-
-	return true, nil
+	return nil
 }
diff --git a/pkg/controller/certificates/issuing/secret_manager_test.go b/pkg/controller/certificates/issuing/secret_manager_test.go
index bc306117a..be23938f1 100644
--- a/pkg/controller/certificates/issuing/secret_manager_test.go
+++ b/pkg/controller/certificates/issuing/secret_manager_test.go
@@ -24,12 +24,11 @@ import (
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/internal/secretsmanager"
-	internaltest "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test"
+	"github.com/jetstack/cert-manager/pkg/controller/certificates/issuing/internal"
 	testpkg "github.com/jetstack/cert-manager/pkg/controller/test"
-	"github.com/jetstack/cert-manager/test/unit/gen"
 )
 
 func Test_ensureSecretData(t *testing.T) {
@@ -258,11 +257,11 @@ func Test_ensureSecretData(t *testing.T) {
 			assert.NoError(t, err)
 
 			var actionCalled bool
-			w.secretsUpdateData = func(_ context.Context, _ *cmapi.Certificate, _ secretsmanager.SecretData) error {
+			w.secretsUpdateData = func(_ context.Context, _ *cmapi.Certificate, _ internal.SecretData) error {
 				actionCalled = true
 				return nil
 			}
-			w.fieldManager = fieldManager
+			w.postIssuancePolicyChain = policies.NewSecretPostIssuancePolicyChain(fieldManager)
 
 			// Start the informers and begin processing updates.
 			builder.Start()
@@ -285,465 +284,3 @@ func Test_ensureSecretData(t *testing.T) {
 		})
 	}
 }
-
-func Test_secretTemplateMatchesManagedFields(t *testing.T) {
-	const fieldManager = "cert-manager-unit-test"
-
-	baseCertBundle := internaltest.MustCreateCryptoBundle(t, gen.Certificate("test-certificate",
-		gen.SetCertificateCommonName("cert-manager"),
-		gen.SetCertificateDNSNames("example.com", "cert-manager.io"),
-		gen.SetCertificateIPs("1.1.1.1", "1.2.3.4"),
-		gen.SetCertificateURIs("spiffe.io//cert-manager.io/test", "spiffe.io//hello.world"),
-	), fixedClock)
-
-	tests := map[string]struct {
-		tmpl     *cmapi.CertificateSecretTemplate
-		data     secretsmanager.SecretData
-		secret   []metav1.ManagedFieldsEntry
-		expMatch bool
-	}{
-		"if template is nil and no managed fields, should return true": {
-			tmpl:     nil,
-			secret:   nil,
-			expMatch: true,
-		},
-		"if template is nil, managed fields is not nil but not managed by cert-manager, should return true": {
-			tmpl: nil,
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: "not-cert-manager", FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:bar": {}
-							},
-							"f:labels": {
-								"f:123": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: true,
-		},
-		"if template is nil, managed fields is not nil but fields are nil, should return true": {
-			tmpl:     nil,
-			secret:   []metav1.ManagedFieldsEntry{{Manager: fieldManager, FieldsV1: nil}},
-			expMatch: true,
-		},
-		"if template is not-nil but managed fields is nil, should return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo": "bar"},
-				Labels:      map[string]string{"abc": "123"},
-			},
-			secret:   nil,
-			expMatch: false,
-		},
-		"if template is nil but managed fields is not nil, should return false": {
-			tmpl: nil,
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo": {}
-							},
-							"f:labels": {
-								"f:abc": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if template annotations do not match managed fields, should return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo3": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if template labels do not match managed fields, should return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:erg": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if template annotations and labels match managed fields, should return true": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: true,
-		},
-		"if template annotations is a subset of managed fields, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {},
-								"f:foo3": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if template labels is a subset of managed fields, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {},
-								"f:ghi": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if managed fields annotations is a subset of template, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2", "foo3": "bar3"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if managed fields labels is a subset of template, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456", "ghi": "789"},
-			},
-			secret: []metav1.ManagedFieldsEntry{{
-				Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: false,
-		},
-		"if managed fields matches template but is split across multiple managed fields, should return true": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2", "foo3": "bar3"},
-				Labels:      map[string]string{"abc": "123", "def": "456", "ghi": "789"},
-			},
-			secret: []metav1.ManagedFieldsEntry{
-				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:labels": {
-								"f:ghi": {}
-							}
-						}}`),
-				}},
-				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo3": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-				}},
-				{Manager: fieldManager,
-					FieldsV1: &metav1.FieldsV1{
-						Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {}
-							},
-							"f:labels": {
-								"f:abc": {},
-								"f:def": {}
-							}
-						}}`),
-					}},
-			},
-			expMatch: true,
-		},
-		"if managed fields matches template and base cert-manager annotations are present with no certificate data, should return true": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-			},
-			secret: []metav1.ManagedFieldsEntry{
-				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {},
-                "f:cert-manager.io/certificate-name": {},
-                "f:cert-manager.io/issuer-name": {},
-                "f:cert-manager.io/issuer-kind": {},
-                "f:cert-manager.io/issuer-group": {}
-							}
-						}}`),
-				}},
-			},
-			expMatch: true,
-		},
-		"if managed fields matches template and base cert-manager annotations are present with certificate data, should return true": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-			},
-			secret: []metav1.ManagedFieldsEntry{
-				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {},
-                "f:cert-manager.io/certificate-name": {},
-                "f:cert-manager.io/issuer-name": {},
-                "f:cert-manager.io/issuer-kind": {},
-                "f:cert-manager.io/issuer-group": {},
-				        "f:cert-manager.io/common-name": {},
-				        "f:cert-manager.io/alt-names":  {},
-				        "f:cert-manager.io/ip-sans": {},
-				        "f:cert-manager.io/uri-sans": {}
-							}
-						}}`),
-				}},
-			},
-			data:     secretsmanager.SecretData{Certificate: baseCertBundle.CertBytes},
-			expMatch: true,
-		},
-		"if managed fields matches template and base cert-manager annotations are present with certificate data but certificate data is nil, should return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-			},
-			secret: []metav1.ManagedFieldsEntry{
-				{Manager: fieldManager, FieldsV1: &metav1.FieldsV1{
-					Raw: []byte(`{"f:metadata": {
-							"f:annotations": {
-								"f:foo1": {},
-								"f:foo2": {},
-                "f:cert-manager.io/certificate-name": {},
-                "f:cert-manager.io/issuer-name": {},
-                "f:cert-manager.io/issuer-kind": {},
-                "f:cert-manager.io/issuer-group": {},
-				        "f:cert-manager.io/common-name": {},
-				        "f:cert-manager.io/alt-names":  {},
-				        "f:cert-manager.io/ip-sans": {},
-				        "f:cert-manager.io/uri-sans": {}
-							}
-						}}`),
-				}},
-			},
-			data:     secretsmanager.SecretData{Certificate: nil},
-			expMatch: false,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			c := &controller{fieldManager: fieldManager}
-
-			match, err := c.secretTemplateMatchesManagedFields(
-				&cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretTemplate: test.tmpl}},
-				&corev1.Secret{ObjectMeta: metav1.ObjectMeta{ManagedFields: test.secret}},
-				test.data,
-			)
-			assert.NoError(t, err)
-			assert.Equal(t, test.expMatch, match,
-				"Template=%v Secret=%v", test.tmpl, test.secret)
-		})
-	}
-}
-
-func Test_secretTemplateMatchesSecret(t *testing.T) {
-	tests := map[string]struct {
-		tmpl     *cmapi.CertificateSecretTemplate
-		secret   *corev1.Secret
-		expMatch bool
-	}{
-		"if SecretTemplate is nil, Secret Annotations and Labels are nil, return true": {
-			tmpl:     nil,
-			secret:   &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Annotations: nil, Labels: nil}},
-			expMatch: true,
-		},
-		"if SecretTemplate is nil, Secret Annotations are nil, Labels are non-nil, return true": {
-			tmpl:     nil,
-			secret:   &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Annotations: nil, Labels: map[string]string{"foo": "bar"}}},
-			expMatch: true,
-		},
-		"if SecretTemplate is nil, Secret Annotations are non-nil, Labels are nil, return true": {
-			tmpl:     nil,
-			secret:   &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{"foo": "bar"}, Labels: nil}},
-			expMatch: true,
-		},
-		"if SecretTemplate is nil, Secret Annotations and Labels are non-nil, return true": {
-			tmpl: nil,
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo": "bar"},
-				Labels:      map[string]string{"bar": "foo"},
-			}},
-			expMatch: true,
-		},
-		"if SecretTemplate is non-nil, Secret Annotations match but Labels are nil, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      nil,
-			}},
-			expMatch: false,
-		},
-		"if SecretTemplate is non-nil, Secret Labels match but Annotations are nil, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: nil,
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			}},
-			expMatch: false,
-		},
-		"if SecretTemplate is non-nil, Secret Labels match but Annotations don't match keys, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo2": "bar1", "foo1": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			}},
-			expMatch: false,
-		},
-		"if SecretTemplate is non-nil, Secret Annoations match but Labels don't match keys, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"def": "123", "abc": "456"},
-			}},
-			expMatch: false,
-		},
-		"if SecretTemplate is non-nil, Secret Labels match but Annotations don't match values, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo1": "bar2", "foo2": "bar1"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			}},
-			expMatch: false,
-		},
-		"if SecretTemplate is non-nil, Secret Annotations match but Labels don't match values, return false": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "456", "def": "123"},
-			}},
-			expMatch: false,
-		},
-		"if SecretTemplate is non-nil, Secret Annotations and Labels match, return true": {
-			tmpl: &cmapi.CertificateSecretTemplate{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{
-				Annotations: map[string]string{"foo1": "bar1", "foo2": "bar2"},
-				Labels:      map[string]string{"abc": "123", "def": "456"},
-			}},
-			expMatch: true,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			assert.Equal(t, test.expMatch,
-				secretTemplateMatchesSecret(&cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretTemplate: test.tmpl}}, test.secret),
-				"Template=%v Secret=%v", test.tmpl, test.secret,
-			)
-		})
-	}
-}
diff --git a/pkg/controller/certificates/issuing/temporary.go b/pkg/controller/certificates/issuing/temporary.go
index 3173039ca..f6f152765 100644
--- a/pkg/controller/certificates/issuing/temporary.go
+++ b/pkg/controller/certificates/issuing/temporary.go
@@ -23,18 +23,12 @@ import (
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/internal/secretsmanager"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies"
+	"github.com/jetstack/cert-manager/pkg/controller/certificates/issuing/internal"
 	utilpki "github.com/jetstack/cert-manager/pkg/util/pki"
 )
 
-var temporaryCertificatePolicyChain = policies.Chain{
-	policies.SecretDoesNotExist,
-	policies.SecretIsMissingData,
-	policies.SecretPublicKeysDiffer,
-}
-
 // ensureTemporaryCertificate will create a temporary certificate and store it
 // into the target Secret if:
 // - The temporary certificate annotation is present
@@ -60,7 +54,7 @@ func (c *controller) ensureTemporaryCertificate(ctx context.Context, crt *cmapi.
 	input := policies.Input{Secret: secret}
 	// If the target Secret exists with a signed certificate and matching private
 	// key, do not issue.
-	if _, _, invalid := temporaryCertificatePolicyChain.Evaluate(input); !invalid {
+	if _, _, invalid := policies.NewTemporaryCertificatePolicyChain().Evaluate(input); !invalid {
 		return false, nil
 	}
 
@@ -73,7 +67,7 @@ func (c *controller) ensureTemporaryCertificate(ctx context.Context, crt *cmapi.
 	if err != nil {
 		return false, err
 	}
-	secretData := secretsmanager.SecretData{
+	secretData := internal.SecretData{
 		Certificate: certData,
 		PrivateKey:  pkData,
 	}
diff --git a/pkg/controller/certificates/readiness/BUILD.bazel b/pkg/controller/certificates/readiness/BUILD.bazel
index 59b0bc64a..60c0145dc 100644
--- a/pkg/controller/certificates/readiness/BUILD.bazel
+++ b/pkg/controller/certificates/readiness/BUILD.bazel
@@ -6,6 +6,7 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/readiness",
     visibility = ["//visibility:public"],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/api/util:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
@@ -14,7 +15,6 @@ go_library(
         "//pkg/client/listers/certmanager/v1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/controller/certificates:go_default_library",
-        "//pkg/controller/certificates/trigger/policies:go_default_library",
         "//pkg/logs:go_default_library",
         "//pkg/util/pki:go_default_library",
         "//pkg/util/predicate:go_default_library",
@@ -28,7 +28,6 @@ go_library(
         "@io_k8s_client_go//listers/core/v1:go_default_library",
         "@io_k8s_client_go//tools/cache:go_default_library",
         "@io_k8s_client_go//util/workqueue:go_default_library",
-        "@io_k8s_utils//clock:go_default_library",
     ],
 )
 
@@ -51,13 +50,13 @@ go_test(
     srcs = ["readiness_controller_test.go"],
     embed = [":go_default_library"],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/controller/certificates:go_default_library",
-        "//pkg/controller/certificates/internal/test:go_default_library",
-        "//pkg/controller/certificates/trigger/policies:go_default_library",
         "//pkg/controller/test:go_default_library",
+        "//test/unit/crypto:go_default_library",
         "//test/unit/gen:go_default_library",
         "@io_k8s_api//core/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
diff --git a/pkg/controller/certificates/readiness/readiness_controller.go b/pkg/controller/certificates/readiness/readiness_controller.go
index 0f40be5f4..511687ca0 100644
--- a/pkg/controller/certificates/readiness/readiness_controller.go
+++ b/pkg/controller/certificates/readiness/readiness_controller.go
@@ -30,8 +30,8 @@ import (
 	corelisters "k8s.io/client-go/listers/core/v1"
 	"k8s.io/client-go/tools/cache"
 	"k8s.io/client-go/util/workqueue"
-	"k8s.io/utils/clock"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
@@ -40,7 +40,6 @@ import (
 	cmlisters "github.com/jetstack/cert-manager/pkg/client/listers/certmanager/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
 	"github.com/jetstack/cert-manager/pkg/controller/certificates"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 	"github.com/jetstack/cert-manager/pkg/util/pki"
 	"github.com/jetstack/cert-manager/pkg/util/predicate"
@@ -215,18 +214,6 @@ func policyEvaluator(chain policies.Chain, input policies.Input) cmapi.Certifica
 	}
 }
 
-// NewReadinessPolicyChain constructs an ordered chain of policies
-// that can be used to determine Certificate's Ready condition
-func NewReadinessPolicyChain(c clock.Clock) policies.Chain {
-	return policies.Chain{
-		policies.SecretDoesNotExist,
-		policies.SecretIsMissingData,
-		policies.SecretPublicKeysDiffer,
-		policies.CurrentCertificateRequestNotValidForSpec,
-		policies.CurrentCertificateHasExpired(c),
-	}
-}
-
 // controllerWrapper wraps the `controller` structure to make it implement
 // the controllerpkg.queueingController interface
 type controllerWrapper struct {
@@ -241,7 +228,7 @@ func (c *controllerWrapper) Register(ctx *controllerpkg.Context) (workqueue.Rate
 		ctx.CMClient,
 		ctx.KubeSharedInformerFactory,
 		ctx.SharedInformerFactory,
-		NewReadinessPolicyChain(ctx.Clock),
+		policies.NewReadinessPolicyChain(ctx.Clock),
 		certificates.RenewalTime,
 		policyEvaluator,
 	)
diff --git a/pkg/controller/certificates/readiness/readiness_controller_test.go b/pkg/controller/certificates/readiness/readiness_controller_test.go
index 14398cddc..44112e486 100644
--- a/pkg/controller/certificates/readiness/readiness_controller_test.go
+++ b/pkg/controller/certificates/readiness/readiness_controller_test.go
@@ -26,13 +26,13 @@ import (
 	coretesting "k8s.io/client-go/testing"
 	fakeclock "k8s.io/utils/clock/testing"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
 	"github.com/jetstack/cert-manager/pkg/controller/certificates"
-	internaltest "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies"
 	testpkg "github.com/jetstack/cert-manager/pkg/controller/test"
+	testcrypto "github.com/jetstack/cert-manager/test/unit/crypto"
 	"github.com/jetstack/cert-manager/test/unit/gen"
 )
 
@@ -55,7 +55,7 @@ func TestProcessItem(t *testing.T) {
 	now := time.Now().UTC()
 	metaNow := metav1.NewTime(now)
 	// private key to be used to generate X509 certificate
-	privKey := internaltest.MustCreatePEMPrivateKey(t)
+	privKey := testcrypto.MustCreatePEMPrivateKey(t)
 	cert := &cmapi.Certificate{
 		ObjectMeta: metav1.ObjectMeta{Namespace: "testns", Name: "test"},
 		Spec: cmapi.CertificateSpec{
@@ -253,7 +253,7 @@ func TestProcessItem(t *testing.T) {
 				mods := make([]gen.SecretModifier, 0)
 				// If the test scenario needs a secret with a valid X509 cert.
 				if test.notBefore != nil && test.notAfter != nil {
-					x509Bytes := internaltest.MustCreateCertWithNotBeforeAfter(t, privKey, cert, test.notBefore.Time, test.notAfter.Time)
+					x509Bytes := testcrypto.MustCreateCertWithNotBeforeAfter(t, privKey, cert, test.notBefore.Time, test.notAfter.Time)
 					mods = append(mods,
 						gen.SetSecretData(map[string][]byte{
 							"tls.crt": x509Bytes,
@@ -329,7 +329,7 @@ func TestProcessItem(t *testing.T) {
 // Test the evaluation of the ordered policy chain as a whole.
 func TestNewReadinessPolicyChain(t *testing.T) {
 	clock := &fakeclock.FakeClock{}
-	privKey := internaltest.MustCreatePEMPrivateKey(t)
+	privKey := testcrypto.MustCreatePEMPrivateKey(t)
 	tests := map[string]struct {
 		// policy inputs
 		cert   *cmapi.Certificate
@@ -395,7 +395,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 				map[string][]byte{
 					corev1.TLSPrivateKeyKey: privKey,
 					// generate a different private key
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, internaltest.MustCreatePEMPrivateKey(t),
+					corev1.TLSCertKey: testcrypto.MustCreateCert(t, testcrypto.MustCreatePEMPrivateKey(t),
 						gen.Certificate("something else", gen.SetCertificateCommonName("example.com"))),
 				})),
 			reason:         policies.InvalidKeyPair,
@@ -418,7 +418,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 				gen.SetSecretData(
 					map[string][]byte{
 						corev1.TLSPrivateKeyKey: privKey,
-						corev1.TLSCertKey: internaltest.MustCreateCert(t, privKey,
+						corev1.TLSCertKey: testcrypto.MustCreateCert(t, privKey,
 							gen.Certificate("something else", gen.SetCertificateCommonName("old.example.com"))),
 					},
 				),
@@ -432,7 +432,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 					},
 				),
 				gen.SetCertificateRequestCSR(
-					internaltest.MustGenerateCSRImpl(t, privKey,
+					testcrypto.MustGenerateCSRImpl(t, privKey,
 						gen.Certificate("somethingelse",
 							gen.SetCertificateCommonName("old.example.com"))))),
 			reason:         policies.RequestChanged,
@@ -456,7 +456,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 				gen.SetSecretData(
 					map[string][]byte{
 						corev1.TLSPrivateKeyKey: privKey,
-						corev1.TLSCertKey: internaltest.MustCreateCertWithNotBeforeAfter(t, privKey,
+						corev1.TLSCertKey: testcrypto.MustCreateCertWithNotBeforeAfter(t, privKey,
 							gen.Certificate("something", gen.SetCertificateCommonName("new.example.com")),
 							clock.Now().Add(-3*time.Hour), clock.Now().Add(-1*time.Hour),
 						),
@@ -490,7 +490,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 				gen.SetSecretData(
 					map[string][]byte{
 						corev1.TLSPrivateKeyKey: privKey,
-						corev1.TLSCertKey: internaltest.MustCreateCertWithNotBeforeAfter(t, privKey,
+						corev1.TLSCertKey: testcrypto.MustCreateCertWithNotBeforeAfter(t, privKey,
 							&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "new.example.com"}},
 							clock.Now(), clock.Now().Add(time.Hour*3),
 						),
@@ -504,7 +504,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 						Group: "group.example.com",
 					},
 				),
-				gen.SetCertificateRequestCSR(internaltest.MustGenerateCSRImpl(t, privKey,
+				gen.SetCertificateRequestCSR(testcrypto.MustGenerateCSRImpl(t, privKey,
 					gen.Certificate("something",
 						gen.SetCertificateCommonName("new.example.com")))),
 			),
@@ -512,7 +512,7 @@ func TestNewReadinessPolicyChain(t *testing.T) {
 			message: "",
 		},
 	}
-	policyChain := NewReadinessPolicyChain(clock)
+	policyChain := policies.NewReadinessPolicyChain(clock)
 	for name, test := range tests {
 		t.Run(name, func(t *testing.T) {
 			reason, message, violationFound := policyChain.Evaluate(policies.Input{
diff --git a/pkg/controller/certificates/trigger/BUILD.bazel b/pkg/controller/certificates/trigger/BUILD.bazel
index 431bb1719..044dd965f 100644
--- a/pkg/controller/certificates/trigger/BUILD.bazel
+++ b/pkg/controller/certificates/trigger/BUILD.bazel
@@ -6,6 +6,7 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/trigger",
     visibility = ["//visibility:public"],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/api/util:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
@@ -14,7 +15,6 @@ go_library(
         "//pkg/client/listers/certmanager/v1:go_default_library",
         "//pkg/controller:go_default_library",
         "//pkg/controller/certificates:go_default_library",
-        "//pkg/controller/certificates/trigger/policies:go_default_library",
         "//pkg/logs:go_default_library",
         "//pkg/scheduler:go_default_library",
         "//pkg/util/predicate:go_default_library",
@@ -41,10 +41,7 @@ filegroup(
 
 filegroup(
     name = "all-srcs",
-    srcs = [
-        ":package-srcs",
-        "//pkg/controller/certificates/trigger/policies:all-srcs",
-    ],
+    srcs = [":package-srcs"],
     tags = ["automanaged"],
     visibility = ["//visibility:public"],
 )
@@ -54,11 +51,11 @@ go_test(
     srcs = ["trigger_controller_test.go"],
     embed = [":go_default_library"],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/controller:go_default_library",
-        "//pkg/controller/certificates/internal/test:go_default_library",
-        "//pkg/controller/certificates/trigger/policies:go_default_library",
         "//pkg/controller/test:go_default_library",
+        "//test/unit/crypto:go_default_library",
         "//test/unit/gen:go_default_library",
         "@com_github_go_logr_logr//testing:go_default_library",
         "@com_github_stretchr_testify//assert:go_default_library",
diff --git a/pkg/controller/certificates/trigger/policies/policies_test.go b/pkg/controller/certificates/trigger/policies/policies_test.go
deleted file mode 100644
index cb6925a39..000000000
--- a/pkg/controller/certificates/trigger/policies/policies_test.go
+++ /dev/null
@@ -1,508 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package policies
-
-import (
-	"testing"
-	"time"
-
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	fakeclock "k8s.io/utils/clock/testing"
-
-	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
-	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
-	internaltest "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test"
-)
-
-// Runs a full set of tests against the 'policy chain' once it is composed
-// together.
-// These tests account for the ordering of the policy chain, and are in place
-// to ensure we do not break behaviour when introducing a new policy or
-// modifying existing code.
-func TestDefaultPolicyChain(t *testing.T) {
-	clock := &fakeclock.FakeClock{}
-	staticFixedPrivateKey := internaltest.MustCreatePEMPrivateKey(t)
-	tests := map[string]struct {
-		// policy inputs
-		certificate *cmapi.Certificate
-		request     *cmapi.CertificateRequest
-		secret      *corev1.Secret
-
-		// expected outputs
-		reason, message string
-		reissue         bool
-	}{
-		"trigger issuance if Secret is missing": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			reason:      DoesNotExist,
-			message:     "Issuing certificate as Secret does not exist",
-			reissue:     true,
-		},
-		"trigger issuance as Secret does not contain any data": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret:      &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"}},
-			reason:      MissingData,
-			message:     "Issuing certificate as Secret does not contain any data",
-			reissue:     true,
-		},
-		"trigger issuance as Secret is missing private key": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
-				Data: map[string][]byte{corev1.TLSCertKey: []byte("test")},
-			},
-			reason:  MissingData,
-			message: "Issuing certificate as Secret does not contain a private key",
-			reissue: true,
-		},
-		"trigger issuance as Secret is missing certificate": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
-				Data: map[string][]byte{corev1.TLSPrivateKeyKey: []byte("test")},
-			},
-			reason:  MissingData,
-			message: "Issuing certificate as Secret does not contain a certificate",
-			reissue: true,
-		},
-		"trigger issuance as Secret contains corrupt private key and certificate data": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: []byte("test"),
-					corev1.TLSCertKey:       []byte("test"),
-				},
-			},
-			reason:  InvalidKeyPair,
-			message: "Issuing certificate as Secret contains an invalid key-pair: tls: failed to find any PEM data in certificate input",
-			reissue: true,
-		},
-		"trigger issuance as Secret contains corrupt certificate data": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: internaltest.MustCreatePEMPrivateKey(t),
-					corev1.TLSCertKey:       []byte("test"),
-				},
-			},
-			reason:  InvalidKeyPair,
-			message: "Issuing certificate as Secret contains an invalid key-pair: tls: failed to find any PEM data in certificate input",
-			reissue: true,
-		},
-		"trigger issuance as Secret contains corrupt private key data": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: []byte("invalid"),
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, internaltest.MustCreatePEMPrivateKey(t),
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-					),
-				},
-			},
-			reason:  InvalidKeyPair,
-			message: "Issuing certificate as Secret contains an invalid key-pair: tls: failed to find any PEM data in key input",
-			reissue: true,
-		},
-		"trigger issuance as Secret contains a non-matching key-pair": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{SecretName: "something"}},
-			secret: &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: "something"},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: internaltest.MustCreatePEMPrivateKey(t),
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, internaltest.MustCreatePEMPrivateKey(t),
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-					),
-				},
-			},
-			reason:  InvalidKeyPair,
-			message: "Issuing certificate as Secret contains an invalid key-pair: tls: private key does not match public key",
-			reissue: true,
-		},
-		"trigger issuance as Secret has old/incorrect 'issuer name' annotation": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				SecretName: "something",
-				IssuerRef: cmmeta.ObjectReference{
-					Name: "testissuer",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey: "oldissuer",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-					),
-				},
-			},
-			reason:  IncorrectIssuer,
-			message: "Issuing certificate as Secret was previously issued by Issuer.cert-manager.io/oldissuer",
-			reissue: true,
-		},
-		"trigger issuance as Secret has old/incorrect 'issuer kind' annotation": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				SecretName: "something",
-				IssuerRef: cmmeta.ObjectReference{
-					Name: "testissuer",
-					Kind: "NewIssuerKind",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey: "testissuer",
-						cmapi.IssuerKindAnnotationKey: "OldIssuerKind",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-					),
-				},
-			},
-			reason:  IncorrectIssuer,
-			message: "Issuing certificate as Secret was previously issued by OldIssuerKind.cert-manager.io/testissuer",
-			reissue: true,
-		},
-		"trigger issuance as Secret has old/incorrect 'issuer group' annotation": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				SecretName: "something",
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "old.example.com",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "new.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-					),
-				},
-			},
-			reason:  IncorrectIssuer,
-			message: "Issuing certificate as Secret was previously issued by IssuerKind.new.example.com/testissuer",
-			reissue: true,
-		},
-		// we only have a basic test here for this as unit tests for the
-		// `certificates.RequestMatchesSpec` function cover all other cases.
-		"trigger issuance when CertificateRequest does not match certificate spec": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				CommonName: "new.example.com",
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "group.example.com",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						// It does not matter what certificate data is stored in the Secret
-						// as the CertificateRequest will be used to determine whether a
-						// re-issuance is required.
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "does-not-matter.example.com"}},
-					),
-				},
-			},
-			request: &cmapi.CertificateRequest{Spec: cmapi.CertificateRequestSpec{
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "group.example.com",
-				},
-				Request: internaltest.MustGenerateCSRImpl(t, staticFixedPrivateKey, &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-					CommonName: "old.example.com",
-				}}),
-			}},
-			reason:  RequestChanged,
-			message: "Fields on existing CertificateRequest resource not up to date: [spec.commonName]",
-			reissue: true,
-		},
-		"do nothing if CertificateRequest matches spec": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				CommonName: "example.com",
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "group.example.com",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						// It does not matter what certificate data is stored in the Secret
-						// as the CertificateRequest will be used to determine whether a
-						// re-issuance is required.
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "does-not-matter.example.com"}},
-					),
-				},
-			},
-			request: &cmapi.CertificateRequest{Spec: cmapi.CertificateRequestSpec{
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "group.example.com",
-				},
-				Request: internaltest.MustGenerateCSRImpl(t, staticFixedPrivateKey, &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-					CommonName: "example.com",
-				}}),
-			}},
-		},
-		"compare signed x509 certificate in Secret with spec if CertificateRequest does not exist": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				CommonName: "new.example.com",
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "group.example.com",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "old.example.com"}},
-					),
-				},
-			},
-			reason:  SecretMismatch,
-			message: "Existing issued Secret is not up to date for spec: [spec.commonName]",
-			reissue: true,
-		},
-		"do nothing if signed x509 certificate in Secret matches spec (when request does not exist)": {
-			certificate: &cmapi.Certificate{Spec: cmapi.CertificateSpec{
-				CommonName: "example.com",
-				IssuerRef: cmmeta.ObjectReference{
-					Name:  "testissuer",
-					Kind:  "IssuerKind",
-					Group: "group.example.com",
-				},
-			}},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCert(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-					),
-				},
-			},
-		},
-		"trigger renewal if renewalTime is right now": {
-			certificate: &cmapi.Certificate{
-				Spec: cmapi.CertificateSpec{
-					CommonName: "example.com",
-					IssuerRef: cmmeta.ObjectReference{
-						Name:  "testissuer",
-						Kind:  "IssuerKind",
-						Group: "group.example.com",
-					},
-					RenewBefore: &metav1.Duration{Duration: time.Minute * 5},
-				},
-				Status: cmapi.CertificateStatus{
-					RenewalTime: &metav1.Time{Time: clock.Now()},
-				},
-			},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-						clock.Now().Add(time.Minute*-30),
-						// expires in 1 minute time
-						clock.Now().Add(time.Minute*1),
-					),
-				},
-			},
-			reason:  Renewing,
-			message: "Renewing certificate as renewal was scheduled at 0001-01-01 00:00:00 +0000 UTC",
-			reissue: true,
-		},
-		"trigger renewal if renewalTime is in the past": {
-			certificate: &cmapi.Certificate{
-				Spec: cmapi.CertificateSpec{
-					CommonName: "example.com",
-					IssuerRef: cmmeta.ObjectReference{
-						Name:  "testissuer",
-						Kind:  "IssuerKind",
-						Group: "group.example.com",
-					},
-					RenewBefore: &metav1.Duration{Duration: time.Minute * 5},
-				},
-				Status: cmapi.CertificateStatus{
-					RenewalTime: &metav1.Time{Time: clock.Now().Add(-1 * time.Minute)},
-				},
-			},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-						clock.Now().Add(time.Minute*-30),
-						// expires in 1 minute time
-						clock.Now().Add(time.Minute*1),
-					),
-				},
-			},
-			reason:  Renewing,
-			message: "Renewing certificate as renewal was scheduled at 0000-12-31 23:59:00 +0000 UTC",
-			reissue: true,
-		},
-		"does not trigger renewal if the x509 cert has been re-issued, but Certificate's renewal time has not been updated yet": {
-			certificate: &cmapi.Certificate{
-				Spec: cmapi.CertificateSpec{
-					CommonName: "example.com",
-					IssuerRef: cmmeta.ObjectReference{
-						Name:  "testissuer",
-						Kind:  "IssuerKind",
-						Group: "group.example.com",
-					},
-					RenewBefore: &metav1.Duration{Duration: time.Minute * 1},
-				},
-				Status: cmapi.CertificateStatus{
-					RenewalTime: &metav1.Time{Time: clock.Now()},
-				},
-			},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-						clock.Now(),
-						// expires in 30 minutes time
-						clock.Now().Add(time.Minute*30),
-					),
-				},
-			},
-		},
-		"does not trigger renewal if renewal time is in 1 minute": {
-			certificate: &cmapi.Certificate{
-				Spec: cmapi.CertificateSpec{
-					CommonName: "example.com",
-					IssuerRef: cmmeta.ObjectReference{
-						Name:  "testissuer",
-						Kind:  "IssuerKind",
-						Group: "group.example.com",
-					},
-					RenewBefore: &metav1.Duration{Duration: time.Minute * 1},
-				},
-				Status: cmapi.CertificateStatus{
-					RenewalTime: &metav1.Time{Time: clock.Now().Add(time.Minute)},
-				},
-			},
-			secret: &corev1.Secret{
-				ObjectMeta: metav1.ObjectMeta{Name: "something",
-					Annotations: map[string]string{
-						cmapi.IssuerNameAnnotationKey:  "testissuer",
-						cmapi.IssuerKindAnnotationKey:  "IssuerKind",
-						cmapi.IssuerGroupAnnotationKey: "group.example.com",
-					},
-				},
-				Data: map[string][]byte{
-					corev1.TLSPrivateKeyKey: staticFixedPrivateKey,
-					corev1.TLSCertKey: internaltest.MustCreateCertWithNotBeforeAfter(t, staticFixedPrivateKey,
-						&cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "example.com"}},
-						clock.Now().Add(time.Minute*-30),
-						// expires in 5 minutes time
-						clock.Now().Add(time.Minute*5),
-					),
-				},
-			},
-		},
-	}
-	policyChain := NewTriggerPolicyChain(clock)
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			reason, message, reissue := policyChain.Evaluate(Input{
-				Certificate:            test.certificate,
-				CurrentRevisionRequest: test.request,
-				Secret:                 test.secret,
-			})
-
-			if test.reason != reason {
-				t.Errorf("unexpected 'reason' exp=%s, got=%s", test.reason, reason)
-			}
-			if test.message != message {
-				t.Errorf("unexpected 'message' exp=%s, got=%s", test.message, message)
-			}
-			if test.reissue != reissue {
-				t.Errorf("unexpected 'reissue' exp=%v, got=%v", test.reissue, reissue)
-			}
-		})
-	}
-}
diff --git a/pkg/controller/certificates/trigger/trigger_controller.go b/pkg/controller/certificates/trigger/trigger_controller.go
index d25177624..3093c1d6e 100644
--- a/pkg/controller/certificates/trigger/trigger_controller.go
+++ b/pkg/controller/certificates/trigger/trigger_controller.go
@@ -32,6 +32,7 @@ import (
 	"k8s.io/client-go/util/workqueue"
 	"k8s.io/utils/clock"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
@@ -40,7 +41,6 @@ import (
 	cmlisters "github.com/jetstack/cert-manager/pkg/client/listers/certmanager/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
 	"github.com/jetstack/cert-manager/pkg/controller/certificates"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 	"github.com/jetstack/cert-manager/pkg/scheduler"
 	"github.com/jetstack/cert-manager/pkg/util/predicate"
diff --git a/pkg/controller/certificates/trigger/trigger_controller_test.go b/pkg/controller/certificates/trigger/trigger_controller_test.go
index c51e79239..30ce1602f 100644
--- a/pkg/controller/certificates/trigger/trigger_controller_test.go
+++ b/pkg/controller/certificates/trigger/trigger_controller_test.go
@@ -28,11 +28,11 @@ import (
 	coretesting "k8s.io/client-go/testing"
 	fakeclock "k8s.io/utils/clock/testing"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
-	internaltest "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies"
 	testpkg "github.com/jetstack/cert-manager/pkg/controller/test"
+	testcrypto "github.com/jetstack/cert-manager/test/unit/crypto"
 	"github.com/jetstack/cert-manager/test/unit/gen"
 )
 
@@ -42,7 +42,7 @@ func Test_controller_ProcessItem(t *testing.T) {
 
 	// We don't need to full bundle, just a simple CertificateRequest.
 	createCertificateRequestOrPanic := func(crt *cmapi.Certificate) *cmapi.CertificateRequest {
-		return internaltest.MustCreateCryptoBundle(t, crt, fixedClock).CertificateRequest
+		return testcrypto.MustCreateCryptoBundle(t, crt, fixedClock).CertificateRequest
 	}
 
 	tests := map[string]struct {
@@ -324,7 +324,7 @@ func Test_shouldBackoffReissuingOnFailure(t *testing.T) {
 
 	// We don't need to full bundle, just a simple CertificateRequest.
 	createCertificateRequestOrPanic := func(crt *cmapi.Certificate) *cmapi.CertificateRequest {
-		return internaltest.MustCreateCryptoBundle(t, crt, clock).CertificateRequest
+		return testcrypto.MustCreateCryptoBundle(t, crt, clock).CertificateRequest
 	}
 
 	tests := map[string]struct {
diff --git a/test/integration/certificates/BUILD.bazel b/test/integration/certificates/BUILD.bazel
index 5fdc55d75..e40df42f3 100644
--- a/test/integration/certificates/BUILD.bazel
+++ b/test/integration/certificates/BUILD.bazel
@@ -9,6 +9,7 @@ go_test(
         "trigger_controller_test.go",
     ],
     deps = [
+        "//internal/controller/certificates/policies:go_default_library",
         "//pkg/api/util:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/apis/meta/v1:go_default_library",
@@ -18,7 +19,6 @@ go_test(
         "//pkg/controller/certificates/metrics:go_default_library",
         "//pkg/controller/certificates/revisionmanager:go_default_library",
         "//pkg/controller/certificates/trigger:go_default_library",
-        "//pkg/controller/certificates/trigger/policies:go_default_library",
         "//pkg/logs:go_default_library",
         "//pkg/metrics:go_default_library",
         "//pkg/util/pki:go_default_library",
diff --git a/test/integration/certificates/trigger_controller_test.go b/test/integration/certificates/trigger_controller_test.go
index f63a63d9f..985b93b54 100644
--- a/test/integration/certificates/trigger_controller_test.go
+++ b/test/integration/certificates/trigger_controller_test.go
@@ -28,13 +28,13 @@ import (
 	"k8s.io/utils/clock"
 	fakeclock "k8s.io/utils/clock/testing"
 
+	"github.com/jetstack/cert-manager/internal/controller/certificates/policies"
 	apiutil "github.com/jetstack/cert-manager/pkg/api/util"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
 	cmclient "github.com/jetstack/cert-manager/pkg/client/clientset/versioned"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
 	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger"
-	"github.com/jetstack/cert-manager/pkg/controller/certificates/trigger/policies"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 	"github.com/jetstack/cert-manager/pkg/metrics"
 	"github.com/jetstack/cert-manager/pkg/util/pki"
diff --git a/pkg/controller/certificates/internal/test/BUILD.bazel b/test/unit/crypto/BUILD.bazel
similarity index 81%
rename from pkg/controller/certificates/internal/test/BUILD.bazel
rename to test/unit/crypto/BUILD.bazel
index 75c0a1acd..60b76c3d3 100644
--- a/pkg/controller/certificates/internal/test/BUILD.bazel
+++ b/test/unit/crypto/BUILD.bazel
@@ -2,9 +2,9 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library")
 
 go_library(
     name = "go_default_library",
-    srcs = ["test.go"],
-    importpath = "github.com/jetstack/cert-manager/pkg/controller/certificates/internal/test",
-    visibility = ["//pkg/controller/certificates:__subpackages__"],
+    srcs = ["crypto.go"],
+    importpath = "github.com/jetstack/cert-manager/test/unit/crypto",
+    visibility = ["//visibility:public"],
     deps = [
         "//pkg/api/util:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
diff --git a/pkg/controller/certificates/internal/test/test.go b/test/unit/crypto/crypto.go
similarity index 99%
rename from pkg/controller/certificates/internal/test/test.go
rename to test/unit/crypto/crypto.go
index 6b0af1d0a..20b129bf8 100644
--- a/pkg/controller/certificates/internal/test/test.go
+++ b/test/unit/crypto/crypto.go
@@ -14,7 +14,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */
 
-package test
+package crypto
 
 import (
 	"crypto"

commit b12d78d36443ea70a8b614c4b87db4423b2bb35a (from 5d565665756997f83acd05590aaaf4f5cddf7b68)
Merge: 952a4502e 5d5656657
Author: jetstack-bot <32282838+jetstack-bot@users.noreply.github.com>
Date:   Thu Jan 27 12:45:40 2022 +0000

    Merge pull request #4746 from JoshVanL/controller-readiness-certificates-spec-match
    
    Certificates controller policies refactor

diff --git a/.github/PULL_REQUEST_TEMPLATE.md b/.github/PULL_REQUEST_TEMPLATE.md
index f9d464f7d..fd5d3caef 100644
--- a/.github/PULL_REQUEST_TEMPLATE.md
+++ b/.github/PULL_REQUEST_TEMPLATE.md
@@ -1,20 +1,43 @@
-<!--  Thanks for sending a pull request!  Here are some tips for you:
-1. If this is your first time, read our contributor guidelines https://git.k8s.io/community/contributors/guide#your-first-contribution and developer guide https://git.k8s.io/community/contributors/devel/development.md#development-guide
-2. If you want *faster* PR reviews, read how: https://git.k8s.io/community/contributors/guide/pull-requests.md#best-practices-for-faster-reviews
-3. Follow the instructions for writing a release note: https://git.k8s.io/community/contributors/guide/release-notes.md
-4. If the PR is unfinished, see how to mark it: https://git.k8s.io/community/contributors/guide/pull-requests.md#marking-unfinished-pull-requests
+<!--
+
+Thanks for opening a pull request! Here are some tips to get everything merged smoothly:
+
+1. Read our contributor guidelines: https://cert-manager.io/docs/contributing/
+
+2. Make sure your commits are signed off: https://cert-manager.io/docs/contributing/sign-off/
+
+3. If the PR is unfinished, raise it as a draft or prefix the title with "WIP:" so it's clear to everyone.
+
+4. Be sure to allow edits from maintainers so it's easier for us to help: https://help.github.com/en/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork
+
+-->
+
+### Pull Request Motivation
+
+<!-- Explain the motivation behind this PR. If there's a related issue or PR, link to it here! -->
+
+### Kind
+
+<!--
+
+Pick a kind which best describes your PR from the following list:
+
+	<cleanup | bug | feature | documentation | design | flake>
+
+If you're unsure which is best or if you're not sure what we mean by "kind",
+just ignore this section and a maintainer will fill it in for you!
 -->
 
-**What this PR does / why we need it**:
+### Release Note
 
-**Which issue this PR fixes** *(optional, in `fixes #<issue number>(, fixes #<issue_number>, ...)` format, will close that issue when PR gets merged)*: fixes #
+<!--
 
-**Special notes for your reviewer**:
+Should we mention this PR in release notes? If so, replace "NONE" with a line of text explaining what changed!
+
+For more details, see: https://git.k8s.io/community/contributors/guide/release-notes.md
 
-**Release note**:
-<!--  Steps to write your release note:
-1. Use the release-note-* labels to set the release note state (if you have access)
-2. Enter your extended release note in the below block; leaving it blank means using the PR title as the release note. If no release note is required, just write `NONE`.
 -->
+
 ```release-note
+NONE
 ```
diff --git a/README.md b/README.md
index 484147b99..19927dd23 100644
--- a/README.md
+++ b/README.md
@@ -34,7 +34,7 @@ Issues and PRs towards the documentation should be filed in the [website repo](h
 For the common use-case of automatically issuing TLS certificates to
 Ingress resources, aka a [kube-lego](https://github.com/jetstack/kube-lego)
 replacement, see the [cert-manager nginx ingress quick start
-guide](https://cert-manager.io/docs/tutorials/acme/ingress/).
+guide](https://cert-manager.io/docs/tutorials/acme/nginx-ingress/).
 
 See [Installation](https://cert-manager.io/docs/installation/)
 within the [documentation](https://cert-manager.io/docs)
diff --git a/cmd/ctl/pkg/install/install.go b/cmd/ctl/pkg/install/install.go
index 6ccbb449d..ed074a00e 100644
--- a/cmd/ctl/pkg/install/install.go
+++ b/cmd/ctl/pkg/install/install.go
@@ -116,7 +116,17 @@ func NewCmdInstall(ctx context.Context, ioStreams genericclioptions.IOStreams) *
 	}
 
 	settings.AddFlags(cmd.Flags())
+
+	// The Helm cli.New function does not provide an easy way to
+	// override the default of the namespace flag.
+	// See https://github.com/helm/helm/issues/9790
+	//
+	// Here we set the default value shown in the usage message.
 	cmd.Flag("namespace").DefValue = defaultCertManagerNamespace
+	// Here we set the default value.
+	// The returned error is ignored because
+	// pflag.stringValue.Set always returns a nil.
+	cmd.Flag("namespace").Value.Set(defaultCertManagerNamespace)
 
 	addInstallUninstallFlags(cmd.Flags(), &options.client.Timeout, &options.Wait)
 
diff --git a/cmd/webhook/app/BUILD.bazel b/cmd/webhook/app/BUILD.bazel
index bb78b9ec1..fa8d2c119 100644
--- a/cmd/webhook/app/BUILD.bazel
+++ b/cmd/webhook/app/BUILD.bazel
@@ -9,20 +9,13 @@ go_library(
         "//cmd/util:go_default_library",
         "//cmd/webhook/app/options:go_default_library",
         "//internal/apis/config/webhook:go_default_library",
+        "//internal/webhook:go_default_library",
         "//pkg/logs:go_default_library",
         "//pkg/util:go_default_library",
         "//pkg/util/feature:go_default_library",
-        "//pkg/webhook:go_default_library",
-        "//pkg/webhook/authority:go_default_library",
         "//pkg/webhook/configfile:go_default_library",
-        "//pkg/webhook/handlers:go_default_library",
-        "//pkg/webhook/server:go_default_library",
-        "//pkg/webhook/server/tls:go_default_library",
-        "@com_github_go_logr_logr//:go_default_library",
         "@com_github_spf13_cobra//:go_default_library",
         "@com_github_spf13_pflag//:go_default_library",
-        "@io_k8s_client_go//kubernetes:go_default_library",
-        "@io_k8s_client_go//tools/clientcmd:go_default_library",
         "@io_k8s_component_base//cli/flag:go_default_library",
     ],
 )
diff --git a/cmd/webhook/app/testing/BUILD.bazel b/cmd/webhook/app/testing/BUILD.bazel
index 52c67e689..4becacd83 100644
--- a/cmd/webhook/app/testing/BUILD.bazel
+++ b/cmd/webhook/app/testing/BUILD.bazel
@@ -6,8 +6,8 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/cmd/webhook/app/testing",
     visibility = ["//visibility:public"],
     deps = [
-        "//cmd/webhook/app:go_default_library",
         "//cmd/webhook/app/options:go_default_library",
+        "//internal/webhook:go_default_library",
         "//pkg/util/pki:go_default_library",
         "//pkg/webhook/server:go_default_library",
         "@com_github_go_logr_logr//testing:go_default_library",
diff --git a/cmd/webhook/app/testing/testwebhook.go b/cmd/webhook/app/testing/testwebhook.go
index 26cc1ca78..d409605e9 100644
--- a/cmd/webhook/app/testing/testwebhook.go
+++ b/cmd/webhook/app/testing/testwebhook.go
@@ -36,8 +36,8 @@ import (
 	"k8s.io/apimachinery/pkg/util/wait"
 	"k8s.io/utils/pointer"
 
-	"github.com/jetstack/cert-manager/cmd/webhook/app"
 	"github.com/jetstack/cert-manager/cmd/webhook/app/options"
+	"github.com/jetstack/cert-manager/internal/webhook"
 	"github.com/jetstack/cert-manager/pkg/util/pki"
 	"github.com/jetstack/cert-manager/pkg/webhook/server"
 )
@@ -56,7 +56,7 @@ type ServerOptions struct {
 	CAPEM []byte
 }
 
-func StartWebhookServer(t *testing.T, ctx context.Context, args []string, argumentsForNewServerWithOptions ...app.ServerOption) (ServerOptions, StopFunc) {
+func StartWebhookServer(t *testing.T, ctx context.Context, args []string, argumentsForNewServerWithOptions ...func(*server.Server)) (ServerOptions, StopFunc) {
 	log := logtesting.NewTestLogger(t)
 
 	fs := pflag.NewFlagSet("testset", pflag.ExitOnError)
@@ -99,7 +99,7 @@ func StartWebhookServer(t *testing.T, ctx context.Context, args []string, argume
 	webhookConfig.HealthzPort = pointer.Int(0)
 
 	errCh := make(chan error)
-	srv, err := app.NewServerWithOptions(log, *webhookFlags, *webhookConfig, argumentsForNewServerWithOptions...)
+	srv, err := webhook.NewCertManagerWebhookServer(log, *webhookFlags, *webhookConfig, argumentsForNewServerWithOptions...)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/cmd/webhook/app/webhook.go b/cmd/webhook/app/webhook.go
index b62bdeddf..80e1ae86c 100644
--- a/cmd/webhook/app/webhook.go
+++ b/cmd/webhook/app/webhook.go
@@ -22,104 +22,26 @@ import (
 	"os"
 	"path/filepath"
 
-	"github.com/go-logr/logr"
 	"github.com/spf13/cobra"
 	"github.com/spf13/pflag"
-	"k8s.io/client-go/kubernetes"
-	"k8s.io/client-go/tools/clientcmd"
 	cliflag "k8s.io/component-base/cli/flag"
 
 	cmdutil "github.com/jetstack/cert-manager/cmd/util"
 	"github.com/jetstack/cert-manager/cmd/webhook/app/options"
 	config "github.com/jetstack/cert-manager/internal/apis/config/webhook"
+	cmwebhook "github.com/jetstack/cert-manager/internal/webhook"
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 	"github.com/jetstack/cert-manager/pkg/util"
 	utilfeature "github.com/jetstack/cert-manager/pkg/util/feature"
-	"github.com/jetstack/cert-manager/pkg/webhook"
-	"github.com/jetstack/cert-manager/pkg/webhook/authority"
 	"github.com/jetstack/cert-manager/pkg/webhook/configfile"
-	"github.com/jetstack/cert-manager/pkg/webhook/handlers"
-	"github.com/jetstack/cert-manager/pkg/webhook/server"
-	"github.com/jetstack/cert-manager/pkg/webhook/server/tls"
 )
 
-var validationHook handlers.ValidatingAdmissionHook = handlers.NewRegistryBackedValidator(logf.Log, webhook.Scheme, webhook.ValidationRegistry)
-var mutationHook handlers.MutatingAdmissionHook = handlers.NewRegistryBackedMutator(logf.Log, webhook.Scheme, webhook.MutationRegistry)
-var conversionHook handlers.ConversionHook = handlers.NewSchemeBackedConverter(logf.Log, webhook.Scheme)
-
-type ServerOption func(*server.Server)
-
-// WithConversionHandler allows you to override the handler for the `/convert`
-// endpoint in tests.
-func WithConversionHandler(handler handlers.ConversionHook) ServerOption {
-	return func(s *server.Server) {
-		s.ConversionWebhook = handler
-	}
-}
-
-func NewServerWithOptions(log logr.Logger, _ options.WebhookFlags, opts config.WebhookConfiguration, optionFunctions ...ServerOption) (*server.Server, error) {
-	restcfg, err := clientcmd.BuildConfigFromFlags(opts.APIServerHost, opts.KubeConfig)
-	if err != nil {
-		return nil, err
-	}
-
-	cl, err := kubernetes.NewForConfig(restcfg)
-	if err != nil {
-		return nil, fmt.Errorf("error creating kubernetes client: %s", err)
-	}
-	validationHook.InitPlugins(cl)
-
-	var source tls.CertificateSource
-	switch {
-	case opts.TLSConfig.FilesystemConfigProvided():
-		log.V(logf.InfoLevel).Info("using TLS certificate from local filesystem", "private_key_path", opts.TLSConfig.Filesystem.KeyFile, "certificate", opts.TLSConfig.Filesystem.CertFile)
-		source = &tls.FileCertificateSource{
-			CertPath: opts.TLSConfig.Filesystem.CertFile,
-			KeyPath:  opts.TLSConfig.Filesystem.KeyFile,
-		}
-	case opts.TLSConfig.DynamicConfigProvided():
-		restcfg, err := clientcmd.BuildConfigFromFlags("", opts.KubeConfig)
-		if err != nil {
-			return nil, err
-		}
-
-		log.V(logf.InfoLevel).Info("using dynamic certificate generating using CA stored in Secret resource", "secret_namespace", opts.TLSConfig.Dynamic.SecretNamespace, "secret_name", opts.TLSConfig.Dynamic.SecretName)
-		source = &tls.DynamicSource{
-			DNSNames: opts.TLSConfig.Dynamic.DNSNames,
-			Authority: &authority.DynamicAuthority{
-				SecretNamespace: opts.TLSConfig.Dynamic.SecretNamespace,
-				SecretName:      opts.TLSConfig.Dynamic.SecretName,
-				RESTConfig:      restcfg,
-			},
-		}
-	default:
-		log.V(logf.WarnLevel).Info("serving insecurely as tls certificate data not provided")
-	}
-
-	s := &server.Server{
-		ListenAddr:        fmt.Sprintf(":%d", *opts.SecurePort),
-		HealthzAddr:       fmt.Sprintf(":%d", *opts.HealthzPort),
-		EnablePprof:       opts.EnablePprof,
-		PprofAddr:         opts.PprofAddress,
-		CertificateSource: source,
-		CipherSuites:      opts.TLSConfig.CipherSuites,
-		MinTLSVersion:     opts.TLSConfig.MinTLSVersion,
-		ValidationWebhook: validationHook,
-		MutationWebhook:   mutationHook,
-		ConversionWebhook: conversionHook,
-	}
-	for _, f := range optionFunctions {
-		f(s)
-	}
-	return s, nil
-}
-
 const componentWebhook = "webhook"
 
 func NewServerCommand(stopCh <-chan struct{}) *cobra.Command {
 	ctx := cmdutil.ContextWithStopCh(context.Background(), stopCh)
 	log := logf.Log
-	ctx = logf.NewContext(ctx, log, "webhook")
+	ctx = logf.NewContext(ctx, log, componentWebhook)
 
 	cleanFlagSet := pflag.NewFlagSet(componentWebhook, pflag.ContinueOnError)
 	// Replaces all instances of `_` in flag names with `-`
@@ -195,7 +117,7 @@ func NewServerCommand(stopCh <-chan struct{}) *cobra.Command {
 				}
 			}
 
-			srv, err := NewServerWithOptions(log, *webhookFlags, *webhookConfig)
+			srv, err := cmwebhook.NewCertManagerWebhookServer(log, *webhookFlags, *webhookConfig)
 			if err != nil {
 				log.Error(err, "Failed initialising server")
 				os.Exit(1)
diff --git a/deploy/charts/cert-manager/templates/service.yaml b/deploy/charts/cert-manager/templates/service.yaml
index 033f293e7..8ad24ca2d 100644
--- a/deploy/charts/cert-manager/templates/service.yaml
+++ b/deploy/charts/cert-manager/templates/service.yaml
@@ -17,10 +17,6 @@ metadata:
     {{- with .Values.serviceLabels }}
     {{- toYaml . | nindent 4 }}
     {{- end }}
-  {{- with .Values.serviceAnnotations }}
-  annotations:
-    {{- toYaml . | nindent 4 }}
-  {{- end }}
 spec:
   type: ClusterIP
   ports:
diff --git a/deploy/charts/cert-manager/templates/webhook-service.yaml b/deploy/charts/cert-manager/templates/webhook-service.yaml
index e197daff3..ed0278ada 100644
--- a/deploy/charts/cert-manager/templates/webhook-service.yaml
+++ b/deploy/charts/cert-manager/templates/webhook-service.yaml
@@ -16,10 +16,6 @@ metadata:
     {{- with .Values.webhook.serviceLabels }}
     {{- toYaml . | nindent 4 }}
     {{- end }}
-  {{- with .Values.webhook.serviceAnnotations }}
-  annotations:
-    {{- toYaml . | nindent 4 }}
-  {{- end }}
 spec:
   type: {{ .Values.webhook.serviceType }}
   {{- with .Values.webhook.loadBalancerIP }}
diff --git a/deploy/charts/cert-manager/values.yaml b/deploy/charts/cert-manager/values.yaml
index 5f46f7793..2603de02d 100644
--- a/deploy/charts/cert-manager/values.yaml
+++ b/deploy/charts/cert-manager/values.yaml
@@ -144,9 +144,6 @@ podLabels: {}
 # Optional additional labels to add to the controller Service
 # serviceLabels: {}
 
-# Optional additional annotations to add to the controller service
-# serviceAnnotations: {}
-
 # Optional DNS settings, useful if you have a public and private DNS zone for
 # the same domain on Route 53. What follows is an example of ensuring
 # cert-manager can access an ingress or DNS TXT records at all times.
@@ -260,9 +257,6 @@ webhook:
   # Optional additional annotations to add to the webhook ValidatingWebhookConfiguration
   # validatingWebhookConfigurationAnnotations: {}
 
-  # Optional additional annotations to add to the webhook service
-  # serviceAnnotations: {}
-
   # Additional command line flags to pass to cert-manager webhook binary.
   # To see all available flags run docker run quay.io/jetstack/cert-manager-webhook:<version> --help
   extraArgs: []
diff --git a/devel/cluster/create-kind.sh b/devel/cluster/create-kind.sh
index 1b86aceff..cb70d96ca 100755
--- a/devel/cluster/create-kind.sh
+++ b/devel/cluster/create-kind.sh
@@ -80,4 +80,4 @@ fixed_coredns_config=$(
 )
 echo "Patched CoreDNS config:"
 echo "${fixed_coredns_config}"
-kubectl create configmap -oyaml coredns --dry-run --from-literal=Corefile="${fixed_coredns_config}" | kubectl apply --namespace kube-system -f -
+kubectl create configmap -oyaml coredns --dry-run=client --from-literal=Corefile="${fixed_coredns_config}" | kubectl apply --namespace kube-system -f -
diff --git a/go.mod b/go.mod
index ac541eb91..d73265eec 100644
--- a/go.mod
+++ b/go.mod
@@ -73,7 +73,8 @@ require (
 	github.com/Masterminds/semver/v3 v3.1.1 // indirect
 	github.com/Masterminds/sprig/v3 v3.2.2 // indirect
 	github.com/Masterminds/squirrel v1.5.0 // indirect
-	github.com/Microsoft/go-winio v0.5.0 // indirect
+	github.com/Microsoft/go-winio v0.5.1 // indirect
+	github.com/Microsoft/hcsshim v0.9.2 // indirect
 	github.com/NYTimes/gziphandler v1.1.1 // indirect
 	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
 	github.com/PuerkitoBio/purell v1.1.1 // indirect
@@ -84,8 +85,9 @@ require (
 	github.com/cenkalti/backoff/v3 v3.0.0 // indirect
 	github.com/cespare/xxhash/v2 v2.1.1 // indirect
 	github.com/chai2010/gettext-go v0.0.0-20160711120539-c6fed771bfd5 // indirect
-	github.com/containerd/containerd v1.5.8 // indirect
-	github.com/containerd/continuity v0.2.0 // indirect
+	github.com/containerd/cgroups v1.0.2 // indirect
+	github.com/containerd/containerd v1.5.9 // indirect
+	github.com/containerd/continuity v0.2.2 // indirect
 	github.com/coreos/go-semver v0.3.0 // indirect
 	github.com/coreos/go-systemd/v22 v22.3.2 // indirect
 	github.com/cpuguy83/go-md2man/v2 v2.0.1 // indirect
@@ -143,7 +145,7 @@ require (
 	github.com/jmoiron/sqlx v1.3.1 // indirect
 	github.com/josharian/intern v1.0.0 // indirect
 	github.com/json-iterator/go v1.1.12 // indirect
-	github.com/klauspost/compress v1.13.6 // indirect
+	github.com/klauspost/compress v1.14.1 // indirect
 	github.com/kr/text v0.2.0 // indirect
 	github.com/lann/builder v0.0.0-20180802200727-47ae307949d0 // indirect
 	github.com/lann/ps v0.0.0-20150810152359-62de8c46ede0 // indirect
@@ -168,8 +170,7 @@ require (
 	github.com/nxadm/tail v1.4.8 // indirect
 	github.com/opencontainers/go-digest v1.0.0 // indirect
 	github.com/opencontainers/image-spec v1.0.2 // indirect
-	github.com/opencontainers/runc v1.0.3 // indirect
-	github.com/opencontainers/selinux v1.9.1 // indirect
+	github.com/opencontainers/runc v1.1.0 // indirect
 	github.com/patrickmn/go-cache v2.1.0+incompatible // indirect
 	github.com/peterbourgon/diskv v2.0.1+incompatible // indirect
 	github.com/pierrec/lz4 v2.5.2+incompatible // indirect
@@ -210,15 +211,15 @@ require (
 	go.uber.org/multierr v1.6.0 // indirect
 	go.uber.org/zap v1.19.1 // indirect
 	golang.org/x/mod v0.4.2 // indirect
-	golang.org/x/sys v0.0.0-20211029165221-6e7872819dc8 // indirect
+	golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e // indirect
 	golang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b // indirect
 	golang.org/x/text v0.3.7 // indirect
 	golang.org/x/time v0.0.0-20210723032227-1f47c861a9ac // indirect
 	golang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff // indirect
 	golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect
 	google.golang.org/appengine v1.6.7 // indirect
-	google.golang.org/genproto v0.0.0-20211005153810-c76a74d43a8e // indirect
-	google.golang.org/grpc v1.41.0 // indirect
+	google.golang.org/genproto v0.0.0-20220118154757-00ab72f36ad5 // indirect
+	google.golang.org/grpc v1.43.0 // indirect
 	google.golang.org/protobuf v1.27.1 // indirect
 	gopkg.in/gorp.v1 v1.7.2 // indirect
 	gopkg.in/inf.v0 v0.9.1 // indirect
diff --git a/go.sum b/go.sum
index 9c2089b9e..daa1e84ea 100644
--- a/go.sum
+++ b/go.sum
@@ -115,8 +115,8 @@ github.com/Microsoft/go-winio v0.4.16/go.mod h1:XB6nPKklQyQ7GC9LdcBEcBl8PF76WugX
 github.com/Microsoft/go-winio v0.4.17-0.20210211115548-6eac466e5fa3/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
 github.com/Microsoft/go-winio v0.4.17-0.20210324224401-5516f17a5958/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
 github.com/Microsoft/go-winio v0.4.17/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
-github.com/Microsoft/go-winio v0.5.0 h1:Elr9Wn+sGKPlkaBvwu4mTrxtmOp3F3yV9qhaHbXGjwU=
-github.com/Microsoft/go-winio v0.5.0/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
+github.com/Microsoft/go-winio v0.5.1 h1:aPJp2QD7OOrhO5tQXqQoGSJc+DjDtWTGLOmNyAm6FgY=
+github.com/Microsoft/go-winio v0.5.1/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=
 github.com/Microsoft/hcsshim v0.8.6/go.mod h1:Op3hHsoHPAvb6lceZHDtd9OkTew38wNoXnJs8iY7rUg=
 github.com/Microsoft/hcsshim v0.8.7-0.20190325164909-8abdbb8205e4/go.mod h1:Op3hHsoHPAvb6lceZHDtd9OkTew38wNoXnJs8iY7rUg=
 github.com/Microsoft/hcsshim v0.8.7/go.mod h1:OHd7sQqRFrYd3RmSgbgji+ctCwkbq2wbEYNSzOYtcBQ=
@@ -125,8 +125,9 @@ github.com/Microsoft/hcsshim v0.8.14/go.mod h1:NtVKoYxQuTLx6gEq0L96c9Ju4JbRJ4nY2
 github.com/Microsoft/hcsshim v0.8.15/go.mod h1:x38A4YbHbdxJtc0sF6oIz+RG0npwSCAvn69iY6URG00=
 github.com/Microsoft/hcsshim v0.8.16/go.mod h1:o5/SZqmR7x9JNKsW3pu+nqHm0MF8vbA+VxGOoXdC600=
 github.com/Microsoft/hcsshim v0.8.21/go.mod h1:+w2gRZ5ReXQhFOrvSQeNfhrYB/dg3oDwTOcER2fw4I4=
-github.com/Microsoft/hcsshim v0.8.23 h1:47MSwtKGXet80aIn+7h4YI6fwPmwIghAnsx2aOUrG2M=
 github.com/Microsoft/hcsshim v0.8.23/go.mod h1:4zegtUJth7lAvFyc6cH2gGQ5B3OFQim01nnU2M8jKDg=
+github.com/Microsoft/hcsshim v0.9.2 h1:wB06W5aYFfUB3IvootYAY2WnOmIdgPGfqSI6tufQNnY=
+github.com/Microsoft/hcsshim v0.9.2/go.mod h1:7pLA8lDk46WKDWlVsENo92gC0XFa8rbKfyFRBqxEbCc=
 github.com/Microsoft/hcsshim/test v0.0.0-20201218223536-d3e5debf77da/go.mod h1:5hlzMzRKMLyo42nCZ9oml8AdTlq/0cvIaBv6tK1RehU=
 github.com/Microsoft/hcsshim/test v0.0.0-20210227013316-43a75bb4edd3/go.mod h1:mw7qgWloBUl75W/gVH3cQszUg1+gUITj7D6NY7ywVnY=
 github.com/NYTimes/gziphandler v0.0.0-20170623195520-56545f4a5d46/go.mod h1:3wb06e3pkSAbeQ52E9H9iFoQsEEwGN64994WTCIhntQ=
@@ -218,6 +219,7 @@ github.com/chai2010/gettext-go v0.0.0-20160711120539-c6fed771bfd5 h1:7aWHqerlJ41
 github.com/chai2010/gettext-go v0.0.0-20160711120539-c6fed771bfd5/go.mod h1:/iP1qXHoty45bqomnu2LM+VVyAEdWN+vtSHGlQgyxbw=
 github.com/checkpoint-restore/go-criu/v4 v4.1.0/go.mod h1:xUQBLp4RLc5zJtWY++yjOoMoB5lihDt7fai+75m+rGw=
 github.com/checkpoint-restore/go-criu/v5 v5.0.0/go.mod h1:cfwC0EG7HMUenopBsUf9d89JlCLQIfgVcNsNN0t6T2M=
+github.com/checkpoint-restore/go-criu/v5 v5.3.0/go.mod h1:E/eQpaFtUKGOOSEBZgmKAcn+zUUwWxqcaKZlF54wK8E=
 github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
 github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
 github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
@@ -226,6 +228,7 @@ github.com/cilium/ebpf v0.0.0-20200702112145-1c8d4c9ef775/go.mod h1:7cR51M8ViRLI
 github.com/cilium/ebpf v0.2.0/go.mod h1:To2CFviqOWL/M0gIMsvSMlqe7em/l1ALkX1PyjrX2Qs=
 github.com/cilium/ebpf v0.4.0/go.mod h1:4tRaxcgiL706VnOzHOdBlY8IEAIdxINsQBcU4xJJXRs=
 github.com/cilium/ebpf v0.6.2/go.mod h1:4tRaxcgiL706VnOzHOdBlY8IEAIdxINsQBcU4xJJXRs=
+github.com/cilium/ebpf v0.7.0/go.mod h1:/oI2+1shJiTGAMgl6/RgJr36Eo1jzrRcAWbcXO2usCA=
 github.com/circonus-labs/circonus-gometrics v2.3.1+incompatible/go.mod h1:nmEj6Dob7S7YxXgwXpfOuvO54S+tGdZdw9fuRZt25Ag=
 github.com/circonus-labs/circonusllhist v0.1.3/go.mod h1:kMXHVDlOchFAehlya5ePtbp5jckzBHf4XRpQvBOLI+I=
 github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
@@ -234,8 +237,11 @@ github.com/cloudflare/cloudflare-go v0.20.0/go.mod h1:sPWL/lIC6biLEdyGZwBQ1rGQKF
 github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
 github.com/cncf/udpa/go v0.0.0-20200629203442-efcf912fb354/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
 github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
+github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
 github.com/cncf/xds/go v0.0.0-20210312221358-fbca930ec8ed/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
 github.com/cncf/xds/go v0.0.0-20210805033703-aa0b78936158/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
+github.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
+github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
 github.com/cockroachdb/datadriven v0.0.0-20190809214429-80d97fb3cbaa/go.mod h1:zn76sxSg3SzpJ0PPJaLDCu+Bu0Lg3sKTORVIj19EIF8=
 github.com/cockroachdb/datadriven v0.0.0-20200714090401-bf6692d28da5/go.mod h1:h6jFvWxBdQXxjopDMZyH2UVceIRfR84bdzbkoKrsWNo=
 github.com/cockroachdb/errors v1.2.4/go.mod h1:rQD95gz6FARkaKkQXUksEje/d9a6wBJoCr5oaCLELYA=
@@ -253,13 +259,15 @@ github.com/containerd/cgroups v0.0.0-20200531161412-0dbf7f05ba59/go.mod h1:pA0z1
 github.com/containerd/cgroups v0.0.0-20200710171044-318312a37340/go.mod h1:s5q4SojHctfxANBDvMeIaIovkq29IP48TKAxnhYRxvo=
 github.com/containerd/cgroups v0.0.0-20200824123100-0b889c03f102/go.mod h1:s5q4SojHctfxANBDvMeIaIovkq29IP48TKAxnhYRxvo=
 github.com/containerd/cgroups v0.0.0-20210114181951-8a68de567b68/go.mod h1:ZJeTFisyysqgcCdecO57Dj79RfL0LNeGiFUqLYQRYLE=
-github.com/containerd/cgroups v1.0.1 h1:iJnMvco9XGvKUvNQkv88bE4uJXxRQH18efbKo9w5vHQ=
 github.com/containerd/cgroups v1.0.1/go.mod h1:0SJrPIenamHDcZhEcJMNBB85rHcUsw4f25ZfBiPYRkU=
+github.com/containerd/cgroups v1.0.2 h1:mZBclaSgNDfPWtfhj2xJY28LZ9nYIgzB0pwSURPl6JM=
+github.com/containerd/cgroups v1.0.2/go.mod h1:qpbpJ1jmlqsR9f2IyaLPsdkCdnt0rbDVqIDlhuu5tRY=
 github.com/containerd/console v0.0.0-20180822173158-c12b1e7919c1/go.mod h1:Tj/on1eG8kiEhd0+fhSDzsPAFESxzBBvdyEgyryXffw=
 github.com/containerd/console v0.0.0-20181022165439-0650fd9eeb50/go.mod h1:Tj/on1eG8kiEhd0+fhSDzsPAFESxzBBvdyEgyryXffw=
 github.com/containerd/console v0.0.0-20191206165004-02ecf6a7291e/go.mod h1:8Pf4gM6VEbTNRIT26AyyU7hxdQU3MvAvxVI0sc00XBE=
 github.com/containerd/console v1.0.1/go.mod h1:XUsP6YE/mKtz6bxc+I8UiKKTP04qjQL4qcS3XoQ5xkw=
 github.com/containerd/console v1.0.2/go.mod h1:ytZPjGgY2oeTkAONYafi2kSj0aYggsf8acV1PGKCbzQ=
+github.com/containerd/console v1.0.3/go.mod h1:7LqA/THxQ86k76b8c/EMSiaJ3h1eZkMkXar0TQ1gf3U=
 github.com/containerd/containerd v1.2.10/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=
 github.com/containerd/containerd v1.3.0-beta.2.0.20190828155532-0293cbd26c69/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=
 github.com/containerd/containerd v1.3.0/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=
@@ -277,8 +285,8 @@ github.com/containerd/containerd v1.5.0-rc.0/go.mod h1:V/IXoMqNGgBlabz3tHD2TWDoT
 github.com/containerd/containerd v1.5.1/go.mod h1:0DOxVqwDy2iZvrZp2JUx/E+hS0UNTVn7dJnIOwtYR4g=
 github.com/containerd/containerd v1.5.2/go.mod h1:0DOxVqwDy2iZvrZp2JUx/E+hS0UNTVn7dJnIOwtYR4g=
 github.com/containerd/containerd v1.5.7/go.mod h1:gyvv6+ugqY25TiXxcZC3L5yOeYgEw0QMhscqVp1AR9c=
-github.com/containerd/containerd v1.5.8 h1:NmkCC1/QxyZFBny8JogwLpOy2f+VEbO/f6bV2Mqtwuw=
-github.com/containerd/containerd v1.5.8/go.mod h1:YdFSv5bTFLpG2HIYmfqDpSYYTDX+mc5qtSuYx1YUb/s=
+github.com/containerd/containerd v1.5.9 h1:rs6Xg1gtIxaeyG+Smsb/0xaSDu1VgFhOCKBXxMxbsF4=
+github.com/containerd/containerd v1.5.9/go.mod h1:fvQqCfadDGga5HZyn3j4+dx56qj2I9YwBrlSdalvJYQ=
 github.com/containerd/continuity v0.0.0-20190426062206-aaeac12a7ffc/go.mod h1:GL3xCUCBDV3CZiTSEKksMWbLE66hEyuu9qyDOOqM47Y=
 github.com/containerd/continuity v0.0.0-20190815185530-f2a389ac0a02/go.mod h1:GL3xCUCBDV3CZiTSEKksMWbLE66hEyuu9qyDOOqM47Y=
 github.com/containerd/continuity v0.0.0-20191127005431-f65d91d395eb/go.mod h1:GL3xCUCBDV3CZiTSEKksMWbLE66hEyuu9qyDOOqM47Y=
@@ -287,8 +295,8 @@ github.com/containerd/continuity v0.0.0-20200710164510-efbc4488d8fe/go.mod h1:cE
 github.com/containerd/continuity v0.0.0-20201208142359-180525291bb7/go.mod h1:kR3BEg7bDFaEddKm54WSmrol1fKWDU1nKYkgrcgZT7Y=
 github.com/containerd/continuity v0.0.0-20210208174643-50096c924a4e/go.mod h1:EXlVlkqNba9rJe3j7w3Xa924itAMLgZH4UD/Q4PExuQ=
 github.com/containerd/continuity v0.1.0/go.mod h1:ICJu0PwR54nI0yPEnJ6jcS+J7CZAUXrLh8lPo2knzsM=
-github.com/containerd/continuity v0.2.0 h1:j/9Wnn+hrEWjLvHuIxUU1YI5JjEjVlT2AA68cse9rwY=
-github.com/containerd/continuity v0.2.0/go.mod h1:wCYX+dRqZdImhGucXOqTQn05AhX6EUDaGEMUzTFFpLg=
+github.com/containerd/continuity v0.2.2 h1:QSqfxcn8c+12slxwu00AtzXrsami0MJb/MQs9lOLHLA=
+github.com/containerd/continuity v0.2.2/go.mod h1:pWygW9u7LtS1o4N/Tn0FoCFDIXZ7rxcMX7HX1Dmibvk=
 github.com/containerd/fifo v0.0.0-20180307165137-3d5202aec260/go.mod h1:ODA38xgv3Kuk8dQz2ZQXpnv/UZZUHUCL7pnLehbXgQI=
 github.com/containerd/fifo v0.0.0-20190226154929-a9fb20d87448/go.mod h1:ODA38xgv3Kuk8dQz2ZQXpnv/UZZUHUCL7pnLehbXgQI=
 github.com/containerd/fifo v0.0.0-20200410184934-f15a3290365b/go.mod h1:jPQ2IAeZRCYxpS/Cm1495vGFww6ecHmMk1YJH2Q5ln0=
@@ -309,6 +317,7 @@ github.com/containerd/imgcrypt v1.1.1/go.mod h1:xpLnwiQmEUJPvQoAapeb2SNCxz7Xr6PJ
 github.com/containerd/nri v0.0.0-20201007170849-eb1350a75164/go.mod h1:+2wGSDGFYfE5+So4M5syatU0N0f0LbWpuqyMi4/BE8c=
 github.com/containerd/nri v0.0.0-20210316161719-dbaa18c31c14/go.mod h1:lmxnXF6oMkbqs39FiCt1s0R2HSMhcLel9vNL3m4AaeY=
 github.com/containerd/nri v0.1.0/go.mod h1:lmxnXF6oMkbqs39FiCt1s0R2HSMhcLel9vNL3m4AaeY=
+github.com/containerd/stargz-snapshotter/estargz v0.4.1/go.mod h1:x7Q9dg9QYb4+ELgxmo4gBUeJB0tl5dqH1Sdz0nJU1QM=
 github.com/containerd/ttrpc v0.0.0-20190828154514-0e0f228740de/go.mod h1:PvCDdDGpgqzQIzDW1TphrGLssLDZp2GuS+X5DkEJB8o=
 github.com/containerd/ttrpc v0.0.0-20190828172938-92c8520ef9f8/go.mod h1:PvCDdDGpgqzQIzDW1TphrGLssLDZp2GuS+X5DkEJB8o=
 github.com/containerd/ttrpc v0.0.0-20191028202541-4f1b8fe65a5c/go.mod h1:LPm1u0xBw8r8NOKoOdNMeVHSawSsltak+Ihv+etqsE8=
@@ -386,6 +395,7 @@ github.com/digitalocean/godo v1.65.0/go.mod h1:p7dOjjtSBqCTUksqtA5Fd3uaKs9kyTq2x
 github.com/distribution/distribution/v3 v3.0.0-20210804104954-38ab4c606ee3 h1:rEK0juuU5idazw//KzUcL3yYwUU3DIe2OnfJwjDBqno=
 github.com/distribution/distribution/v3 v3.0.0-20210804104954-38ab4c606ee3/go.mod h1:gt38b7cvVKazi5XkHvINNytZXgTEntyhtyM3HQz46Nk=
 github.com/dnaeon/go-vcr v1.0.1/go.mod h1:aBB1+wY4s93YsC3HHjMBMrwTj2R9FHDzUr9KyGc8n1E=
+github.com/docker/cli v0.0.0-20191017083524-a8ff7f821017/go.mod h1:JLrzqnKDaYBop7H2jaqPtU4hHvMKP+vjCwu2uszcLI8=
 github.com/docker/cli v20.10.7+incompatible h1:pv/3NqibQKphWZiAskMzdz8w0PRbtTaEB+f6NwdU7Is=
 github.com/docker/cli v20.10.7+incompatible/go.mod h1:JLrzqnKDaYBop7H2jaqPtU4hHvMKP+vjCwu2uszcLI8=
 github.com/docker/distribution v0.0.0-20190905152932-14b96e55d84c/go.mod h1:0+TTO4EOBfRPhZXAeF1Vu+W3hHZ8eLp8PgKVZlcvtFY=
@@ -393,6 +403,7 @@ github.com/docker/distribution v2.7.1-0.20190205005809-0d3efadf0154+incompatible
 github.com/docker/distribution v2.7.1+incompatible h1:a5mlkVzth6W5A4fOsS3D2EO5BUmsJpcB+cRlLU7cSug=
 github.com/docker/distribution v2.7.1+incompatible/go.mod h1:J2gT2udsDAN96Uj4KfcMRqY0/ypR+oyYUYmja8H+y+w=
 github.com/docker/docker v0.7.3-0.20190327010347-be7ac8be2ae0/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
+github.com/docker/docker v1.4.2-0.20190924003213-a8608b5b67c7/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
 github.com/docker/docker v1.4.2-0.20200319182547-c7ad2b866182/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
 github.com/docker/docker v17.12.0-ce-rc1.0.20200618181300-9dc6525e6118+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
 github.com/docker/docker v17.12.1-ce+incompatible h1:JF3ixBk1BbHBmKGimGdei9/2mFcc2rKOReZ+nketjOI=
@@ -568,6 +579,7 @@ github.com/godbus/dbus v0.0.0-20180201030542-885f9cc04c9c/go.mod h1:/YcGZj5zSblf
 github.com/godbus/dbus v0.0.0-20190422162347-ade71ed3457e/go.mod h1:bBOAhwG1umN6/6ZUMtDFBMQR8jRg9O75tm9K00oMsK4=
 github.com/godbus/dbus/v5 v5.0.3/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
 github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
+github.com/godbus/dbus/v5 v5.0.6/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
 github.com/godror/godror v0.24.2/go.mod h1:wZv/9vPiUib6tkoDl+AZ/QLf5YZgMravZ7jxH2eQWAE=
 github.com/gofrs/flock v0.8.0/go.mod h1:F1TvTiK9OcQqauNUHlbJvyl9Qa1QvF/gOUDKA14jxHU=
 github.com/gogo/googleapis v1.2.0/go.mod h1:Njal3psf3qN6dwBtQfUmBZh2ybovJ0tlu3o/AC7HYjU=
@@ -642,6 +654,7 @@ github.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/
 github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
 github.com/google/go-cmp v0.5.6 h1:BKbKCqvP6I+rmFHt06ZmyQtvB8xAkWdhFyr0ZUNZcxQ=
 github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
+github.com/google/go-containerregistry v0.5.1/go.mod h1:Ct15B4yir3PLOP5jsy0GNeYVaIZs/MK/Jz5any1wFW0=
 github.com/google/go-querystring v1.0.0 h1:Xkwi/a1rcvNg1PPYe5vI8GbeBY/jrVuDX5ASuANWTrk=
 github.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=
 github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
@@ -691,6 +704,7 @@ github.com/gorilla/handlers v0.0.0-20150720190736-60c7bfde3e33/go.mod h1:Qkdc/uu
 github.com/gorilla/handlers v1.5.1 h1:9lRY6j8DEeeBT10CvO9hGW0gmky0BprnvDI5vfhUHH4=
 github.com/gorilla/handlers v1.5.1/go.mod h1:t8XrUpc4KVXb7HGyJ4/cEnwQiaxrX/hz1Zv/4g96P1Q=
 github.com/gorilla/mux v1.7.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
+github.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
 github.com/gorilla/mux v1.7.4/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
 github.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvkdNIeFDP5koI=
 github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
@@ -801,6 +815,7 @@ github.com/jmespath/go-jmespath/internal/testify v1.5.1 h1:shLQSRRSCCPj3f2gpwzGw
 github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
 github.com/jmoiron/sqlx v1.3.1 h1:aLN7YINNZ7cYOPK3QC83dbM6KT0NMqVMw961TqrejlE=
 github.com/jmoiron/sqlx v1.3.1/go.mod h1:2BljVx/86SuTyjE+aPYlHCTNvZrnJXghYGpNiXLBMCQ=
+github.com/joefitzgerald/rainbow-reporter v0.1.0/go.mod h1:481CNgqmVHQZzdIbN52CupLJyoVwB10FQ/IQlF1pdL8=
 github.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=
 github.com/jonboulle/clockwork v0.2.2 h1:UOGuzwb1PwsrDAObMuhUnj0p5ULPj8V/xJ7Kx9qUBdQ=
 github.com/jonboulle/clockwork v0.2.2/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=
@@ -829,8 +844,8 @@ github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI
 github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
 github.com/klauspost/compress v1.11.3/go.mod h1:aoV0uJVorq1K+umq18yTdKaF57EivdYsUV+/s2qKfXs=
 github.com/klauspost/compress v1.11.13/go.mod h1:aoV0uJVorq1K+umq18yTdKaF57EivdYsUV+/s2qKfXs=
-github.com/klauspost/compress v1.13.6 h1:P76CopJELS0TiO2mebmnzgWaajssP/EszplttgQxcgc=
-github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
+github.com/klauspost/compress v1.14.1 h1:hLQYb23E8/fO+1u53d02A97a8UnsddcvYzq4ERRU4ds=
+github.com/klauspost/compress v1.14.1/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
 github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
 github.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
 github.com/konsorten/go-windows-terminal-sequences v1.0.3/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
@@ -856,6 +871,7 @@ github.com/lib/pq v1.10.0 h1:Zx5DJFEYQXio93kgXnQ09fXNiUKsqv4OUEu2UtGcB1E=
 github.com/lib/pq v1.10.0/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
 github.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de h1:9TO3cAIGXtEhnIaL+V+BEER86oLrvS+kWobKpbJuye0=
 github.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de/go.mod h1:zAbeS9B/r2mtpb6U+EI2rYA5OAXxsYw6wTamcNW+zcE=
+github.com/linuxkit/virtsock v0.0.0-20201010232012-f8cee7dfc7a3/go.mod h1:3r6x7q95whyfWQpmGZTu3gk3v2YkMi05HEzl7Tf7YEo=
 github.com/lithammer/dedent v1.1.0/go.mod h1:jrXYCQtgg0nJiN+StA2KgR7w6CiQNv9Fd/Z9BP0jIOc=
 github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
@@ -893,12 +909,14 @@ github.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m
 github.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=
 github.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
 github.com/mattn/go-shellwords v1.0.3/go.mod h1:3xCvwCdWdlDJUrvuMn7Wuy9eWs4pE8vqg+NOMyg4B2o=
+github.com/mattn/go-shellwords v1.0.6/go.mod h1:3xCvwCdWdlDJUrvuMn7Wuy9eWs4pE8vqg+NOMyg4B2o=
 github.com/mattn/go-shellwords v1.0.11/go.mod h1:EZzvwXDESEeg03EKmM+RmDnNOPKG4lLtQsUlTZDWQ8Y=
 github.com/mattn/go-sqlite3 v1.14.6 h1:dNPt6NO46WmLVt2DLNpwczCmdV5boIZ6g/tlDrlRUbg=
 github.com/mattn/go-sqlite3 v1.14.6/go.mod h1:NyWgC/yNuGj7Q9rpYnZvas74GogHl5/Z4A/KQRfk6bU=
 github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
 github.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 h1:I0XW9+e1XWDxdcEniV4rQAIOPUGDq67JSCiRCgGCZLI=
 github.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=
+github.com/maxbrunsfeld/counterfeiter/v6 v6.2.2/go.mod h1:eD9eIE7cdwcMi9rYluz88Jz2VyhSmden33/aXg4oVIY=
 github.com/miekg/dns v1.0.14/go.mod h1:W1PPwlIAgtquWBMBEV9nkV9Cazfe8ScdGz/Lj7v3Nrg=
 github.com/miekg/dns v1.1.34 h1:SgTzfkN+oLoIHF1bgUP+C71mzuDl3AhLApHzCCIAMWM=
 github.com/miekg/dns v1.1.34/go.mod h1:KNUDUusw/aVsxyTYZM1oqvCicbwhgbNgztCETuNZ7xM=
@@ -932,8 +950,9 @@ github.com/moby/locker v1.0.1/go.mod h1:S7SDdo5zpBK84bzzVlKr2V0hz+7x9hWbYC/kq7oQ
 github.com/moby/spdystream v0.2.0 h1:cjW1zVyyoiM0T7b6UoySUFqzXMoqRckQtXwGPiBhOM8=
 github.com/moby/spdystream v0.2.0/go.mod h1:f7i0iNDQJ059oMTcWxx8MA/zKFIuD/lY+0GqbN2Wy8c=
 github.com/moby/sys/mountinfo v0.4.0/go.mod h1:rEr8tzG/lsIZHBtN/JjGG+LMYx9eXgW2JI+6q0qou+A=
-github.com/moby/sys/mountinfo v0.4.1 h1:1O+1cHA1aujwEwwVMa2Xm2l+gIpUHyd3+D+d7LZh1kM=
 github.com/moby/sys/mountinfo v0.4.1/go.mod h1:rEr8tzG/lsIZHBtN/JjGG+LMYx9eXgW2JI+6q0qou+A=
+github.com/moby/sys/mountinfo v0.5.0 h1:2Ks8/r6lopsxWi9m58nlwjaeSzUX9iiL1vj5qB/9ObI=
+github.com/moby/sys/mountinfo v0.5.0/go.mod h1:3bMD3Rg+zkqx8MRYPi7Pyb0Ie97QEBmdxbhnCLlSvSU=
 github.com/moby/sys/symlink v0.1.0/go.mod h1:GGDODQmbFOjFsXvfLVn3+ZRxkch54RkSiGqsZeMYowQ=
 github.com/moby/term v0.0.0-20200312100748-672ec06f55cd/go.mod h1:DdlQx2hp0Ss5/fLikoLlEeIYiATotOjgB//nb973jeo=
 github.com/moby/term v0.0.0-20210610120745-9d4ed1856297 h1:yH0SvLzcbZxcJXho2yh7CqdENGMQe73Cw3woZBpPli0=
@@ -971,9 +990,11 @@ github.com/olekukonko/tablewriter v0.0.5/go.mod h1:hPp6KlRPjbx+hW8ykQs1w3UBbZlj6
 github.com/onsi/ginkgo v0.0.0-20151202141238-7f8ab55aaf3b/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v0.0.0-20170829012221-11459a886d9c/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
+github.com/onsi/ginkgo v1.8.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v1.10.1/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v1.10.3/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
 github.com/onsi/ginkgo v1.11.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
+github.com/onsi/ginkgo v1.12.0/go.mod h1:oUhWkIvk5aDxtKvDDuw8gItl8pKl42LzjC9KZE0HfGg=
 github.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=
 github.com/onsi/ginkgo v1.14.0/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=
 github.com/onsi/ginkgo v1.14.1/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=
@@ -982,8 +1003,10 @@ github.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=
 github.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=
 github.com/onsi/gomega v0.0.0-20151007035656-2152b45fa28a/go.mod h1:C1qb7wdrVGGVU+Z6iS04AVkA3Q65CEZX59MT0QO5uiA=
 github.com/onsi/gomega v0.0.0-20170829124025-dcabb60a477c/go.mod h1:C1qb7wdrVGGVU+Z6iS04AVkA3Q65CEZX59MT0QO5uiA=
+github.com/onsi/gomega v1.5.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=
 github.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=
 github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
+github.com/onsi/gomega v1.9.0/go.mod h1:Ho0h+IUsWyvy1OpqCwxlQ/21gkhVunqlU8fDGcoTdcA=
 github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
 github.com/onsi/gomega v1.10.2/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
 github.com/onsi/gomega v1.10.3/go.mod h1:V9xEwhxec5O8UDM77eCW8vLymOMltsqPVYWrpDsH8xc=
@@ -1006,8 +1029,8 @@ github.com/opencontainers/runc v1.0.0-rc8.0.20190926000215-3e425f80a8c9/go.mod h
 github.com/opencontainers/runc v1.0.0-rc9/go.mod h1:qT5XzbpPznkRYVz/mWwUaVBUv2rmF59PVA73FjuZG0U=
 github.com/opencontainers/runc v1.0.0-rc93/go.mod h1:3NOsor4w32B2tC0Zbl8Knk4Wg84SM2ImC1fxBuqJ/H0=
 github.com/opencontainers/runc v1.0.2/go.mod h1:aTaHFFwQXuA71CiyxOdFFIorAoemI04suvGRQFzWTD0=
-github.com/opencontainers/runc v1.0.3 h1:1hbqejyQWCJBvtKAfdO0b1FmaEf2z/bxnjqbARass5k=
-github.com/opencontainers/runc v1.0.3/go.mod h1:aTaHFFwQXuA71CiyxOdFFIorAoemI04suvGRQFzWTD0=
+github.com/opencontainers/runc v1.1.0 h1:O9+X96OcDjkmmZyfaG996kV7yq8HsoU2h1XRRQcefG8=
+github.com/opencontainers/runc v1.1.0/go.mod h1:Tj1hFw6eFWp/o33uxGf5yF2BX5yz2Z6iptFpuvbbKqc=
 github.com/opencontainers/runtime-spec v0.1.2-0.20190507144316-5b71a03e2700/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=
 github.com/opencontainers/runtime-spec v1.0.1/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=
 github.com/opencontainers/runtime-spec v1.0.2-0.20190207185410-29686dbc5559/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=
@@ -1018,8 +1041,8 @@ github.com/opencontainers/runtime-tools v0.0.0-20181011054405-1d69bd0f9c39/go.mo
 github.com/opencontainers/selinux v1.6.0/go.mod h1:VVGKuOLlE7v4PJyT6h7mNWvq1rzqiriPsEqVhc+svHE=
 github.com/opencontainers/selinux v1.8.0/go.mod h1:RScLhm78qiWa2gbVCcGkC7tCGdgk3ogry1nUQF8Evvo=
 github.com/opencontainers/selinux v1.8.2/go.mod h1:MUIHuUEvKB1wtJjQdOyYRgOnLD2xAPP8dBsCoU0KuF8=
-github.com/opencontainers/selinux v1.9.1 h1:b4VPEF3O5JLZgdTDBmGepaaIbAo0GqoF6EBRq5f/g3Y=
-github.com/opencontainers/selinux v1.9.1/go.mod h1:2i0OySw99QjzBBQByd1Gr9gSjvuho1lHsJxIJ3gGbJI=
+github.com/opencontainers/selinux v1.10.0 h1:rAiKF8hTcgLI3w0DHm6i0ylVVcOrlgR1kK99DRLDhyU=
+github.com/opencontainers/selinux v1.10.0/go.mod h1:2i0OySw99QjzBBQByd1Gr9gSjvuho1lHsJxIJ3gGbJI=
 github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=
 github.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
 github.com/pascaldekloe/goe v0.1.0/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
@@ -1109,8 +1132,10 @@ github.com/ryanuber/go-glob v1.0.0 h1:iQh3xXAumdQ+4Ufa5b25cRpC5TYKlno6hsv6Cb3pkB
 github.com/ryanuber/go-glob v1.0.0/go.mod h1:807d1WSdnB0XRJzKNil9Om6lcp/3a0v4qIHxIXzX/Yc=
 github.com/safchain/ethtool v0.0.0-20190326074333-42ed695e3de8/go.mod h1:Z0q5wiBQGYcxhMZ6gUqHn6pYNLypFAvaL3UvgZLR0U4=
 github.com/satori/go.uuid v1.2.0/go.mod h1:dA0hQrYB0VpLJoorglMZABFdXlWrHn1NEOzdhQKdks0=
+github.com/sclevine/spec v1.2.0/go.mod h1:W4J29eT/Kzv7/b9IWLB055Z+qvVC9vt0Arko24q7p+U=
 github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=
 github.com/seccomp/libseccomp-golang v0.9.1/go.mod h1:GbW5+tmTXfcxTToHLXlScSlAvWlF4P2Ca7zGrPiEpWo=
+github.com/seccomp/libseccomp-golang v0.9.2-0.20210429002308-3879420cc921/go.mod h1:JA8cRccbGaA1s33RQf7Y1+q9gHmZX1yB/z9WDN1C6fg=
 github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=
 github.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
 github.com/sergi/go-diff v1.2.0 h1:XU+rvMAioB0UC3q1MFrIQy4Vo5/4VsRDQQXHsEya6xQ=
@@ -1442,6 +1467,7 @@ golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7w
 golang.org/x/sys v0.0.0-20190606203320-7fc4e5ec1444/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190616124812-15dcb6c0061f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20190626221950-04f50cda93cb/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190801041406-cbf593c0f2f3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190812073006-9eafafc0a87e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
@@ -1517,8 +1543,12 @@ golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBc
 golang.org/x/sys v0.0.0-20210806184541-e5e7981a1069/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210831042530-f4d43177bf5e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.0.0-20211029165221-6e7872819dc8 h1:M69LAlWZCshgp0QSzyDcSsSIejIEeuaCVpmwcKwyLMk=
+golang.org/x/sys v0.0.0-20210906170528-6f6e22806c34/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20211025201205-69cdffdb9359/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20211029165221-6e7872819dc8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20211116061358-0a5406a5449c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e h1:fLOSk5Q00efkSvAm+4xcoXD+RRmLmmulPn5I3Y9F2EM=
+golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/term v0.0.0-20201117132131-f5c789dd3221/go.mod h1:Nr5EML6q2oocZ2LXRh80K7BxOlk5/8JxuGnuhpl+muw=
 golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
 golang.org/x/term v0.0.0-20210220032956-6a3ed077a48d/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
@@ -1565,6 +1595,7 @@ golang.org/x/tools v0.0.0-20190617190820-da514acc4774/go.mod h1:/rFqwRUd4F7ZHNgw
 golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
 golang.org/x/tools v0.0.0-20190624222133-a101b041ded4/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
 golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
+golang.org/x/tools v0.0.0-20190706070813-72ffa07ba3db/go.mod h1:jcCCGcm9btYwXyDqrUWc6MKQKKGJCWEQ3AfLSRIbEuI=
 golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20190920225731-5eefd052ad72/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
@@ -1604,6 +1635,7 @@ golang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc
 golang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
 golang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
 golang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=
+golang.org/x/tools v0.0.0-20200916195026-c9a70fc28ce3/go.mod h1:z6u4i615ZeAfBE4XtMziQW1fSVJXACjjbWkB/mvPzlU=
 golang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
 golang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
 golang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
@@ -1693,6 +1725,7 @@ google.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfG
 google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
 google.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=
 google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
+google.golang.org/genproto v0.0.0-20200527145253-8367513e4ece/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
 google.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
 google.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
 google.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
@@ -1720,8 +1753,8 @@ google.golang.org/genproto v0.0.0-20210716133855-ce7ef5c701ea/go.mod h1:AxrInvYm
 google.golang.org/genproto v0.0.0-20210728212813-7823e685a01f/go.mod h1:ob2IJxKrgPT52GcgX759i1sleT07tiKowYBGbczaW48=
 google.golang.org/genproto v0.0.0-20210805201207-89edb61ffb67/go.mod h1:ob2IJxKrgPT52GcgX759i1sleT07tiKowYBGbczaW48=
 google.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=
-google.golang.org/genproto v0.0.0-20211005153810-c76a74d43a8e h1:Im71rbA1N3CbIag/PumYhQcNR8bLNmuOtRIyOnnLsT8=
-google.golang.org/genproto v0.0.0-20211005153810-c76a74d43a8e/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
+google.golang.org/genproto v0.0.0-20220118154757-00ab72f36ad5 h1:zzNejm+EgrbLfDZ6lu9Uud2IVvHySPl8vQzf04laR5Q=
+google.golang.org/genproto v0.0.0-20220118154757-00ab72f36ad5/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
 google.golang.org/grpc v0.0.0-20160317175043-d3ddb4469d5a/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=
 google.golang.org/grpc v1.14.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=
 google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
@@ -1753,8 +1786,8 @@ google.golang.org/grpc v1.38.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQ
 google.golang.org/grpc v1.39.0/go.mod h1:PImNr+rS9TWYb2O4/emRugxiyHZ5JyHW5F+RPnDzfrE=
 google.golang.org/grpc v1.39.1/go.mod h1:PImNr+rS9TWYb2O4/emRugxiyHZ5JyHW5F+RPnDzfrE=
 google.golang.org/grpc v1.40.0/go.mod h1:ogyxbiOoUXAkP+4+xa6PZSE9DZgIHtSpzjDTB9KAK34=
-google.golang.org/grpc v1.41.0 h1:f+PlOh7QV4iIJkPrx5NQ7qaNGFQ3OTse67yaDHfju4E=
-google.golang.org/grpc v1.41.0/go.mod h1:U3l9uK9J0sini8mHphKoXyaqDA/8VyGnDee1zzIUK6k=
+google.golang.org/grpc v1.43.0 h1:Eeu7bZtDZ2DpRCsLhUlcrLnvYaMK1Gz86a+hMVvELmM=
+google.golang.org/grpc v1.43.0/go.mod h1:k+4IHHFw41K8+bbowsex27ge2rCb65oeWqe4jJ590SU=
 google.golang.org/grpc/cmd/protoc-gen-go-grpc v1.1.0/go.mod h1:6Kw0yEErY5E/yWrBtf03jp27GLLJujG4z/JK95pnjjw=
 google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
 google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
@@ -1885,6 +1918,7 @@ k8s.io/client-go v0.23.0/go.mod h1:hrDnpnK1mSr65lHHcUuIZIXDgEbzc7/683c6hyG4jTA=
 k8s.io/client-go v0.23.1 h1:Ma4Fhf/p07Nmj9yAB1H7UwbFHEBrSPg8lviR24U2GiQ=
 k8s.io/client-go v0.23.1/go.mod h1:6QSI8fEuqD4zgFK0xbdwfB/PthBsIxCJMa3s17WlcO0=
 k8s.io/code-generator v0.18.0/go.mod h1:+UHX5rSbxmR8kzS+FAv7um6dtYrZokQvjHpDSYRVkTc=
+k8s.io/code-generator v0.19.7/go.mod h1:lwEq3YnLYb/7uVXLorOJfxg+cUu2oihFhHZ0n9NIla0=
 k8s.io/code-generator v0.20.1/go.mod h1:UsqdF+VX4PU2g46NC2JRs4gc+IfrctnwHb76RNbWHJg=
 k8s.io/code-generator v0.20.2/go.mod h1:UsqdF+VX4PU2g46NC2JRs4gc+IfrctnwHb76RNbWHJg=
 k8s.io/code-generator v0.21.0/go.mod h1:hUlps5+9QaTrKx+jiM4rmq7YmH8wPOIko64uZCHDh6Q=
@@ -1926,6 +1960,7 @@ k8s.io/klog/v2 v2.30.0/go.mod h1:y1WjHnz7Dj687irZUWR/WLkLc5N1YHtjLdmgWjndZn0=
 k8s.io/kube-aggregator v0.23.1 h1:w05VLh3ji05gYQglMKKrwafgqjgIxZoBusxdSWS9d/4=
 k8s.io/kube-aggregator v0.23.1/go.mod h1:1SPZXYD/je2gKxxLBkYyG3yFxSCUWI5QTyjqP2ZxRDI=
 k8s.io/kube-openapi v0.0.0-20200121204235-bf4fb3bd569c/go.mod h1:GRQhZsXIAJ1xR0C9bd8UpWHZ5plfAS9fzPjJuQ6JL3E=
+k8s.io/kube-openapi v0.0.0-20200805222855-6aeccd4b50c6/go.mod h1:UuqjUnNftUyPE5H64/qeyjQoUZhGpeFDVdxjTeEVN2o=
 k8s.io/kube-openapi v0.0.0-20201113171705-d219536bb9fd/go.mod h1:WOJ3KddDSol4tAGcJo0Tvi+dK12EcqSLqcWsryKMpfM=
 k8s.io/kube-openapi v0.0.0-20210305001622-591a79e4bda7/go.mod h1:wXW5VT87nVfh/iLV8FpR2uDvrFyomxbtb1KivDbvPTE=
 k8s.io/kube-openapi v0.0.0-20210421082810-95288971da7e/go.mod h1:vHXdDvt9+2spS2Rx9ql3I8tycm3H9FDfdUoIuKCefvw=
@@ -1981,6 +2016,7 @@ sigs.k8s.io/kustomize/kyaml v0.13.0 h1:9c+ETyNfSrVhxvphs+K2dzT3dh5oVPPEqPOE/cUpS
 sigs.k8s.io/kustomize/kyaml v0.13.0/go.mod h1:FTJxEZ86ScK184NpGSAQcfEqee0nul8oLCK30D47m4E=
 sigs.k8s.io/structured-merge-diff/v3 v3.0.0-20200116222232-67a7b8c61874/go.mod h1:PlARxl6Hbt/+BC80dRLi1qAmnMqwqDg62YvvVkZjemw=
 sigs.k8s.io/structured-merge-diff/v3 v3.0.0/go.mod h1:PlARxl6Hbt/+BC80dRLi1qAmnMqwqDg62YvvVkZjemw=
+sigs.k8s.io/structured-merge-diff/v4 v4.0.1/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
 sigs.k8s.io/structured-merge-diff/v4 v4.0.2/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
 sigs.k8s.io/structured-merge-diff/v4 v4.0.3/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
 sigs.k8s.io/structured-merge-diff/v4 v4.1.0/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=
diff --git a/hack/build/repos.bzl b/hack/build/repos.bzl
index 082c3dbc9..48a47ebdb 100644
--- a/hack/build/repos.bzl
+++ b/hack/build/repos.bzl
@@ -465,8 +465,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/checkpoint-restore/go-criu/v5",
-        sum = "h1:TW8f/UvntYoVDMN1K2HlT82qH1rb0sOjpGw3m6Ym+i4=",
-        version = "v5.0.0",
+        sum = "h1:wpFFOoomK3389ue2lAb0Boag6XPht5QYpipxmSNL4d8=",
+        version = "v5.3.0",
     )
 
     go_repository(
@@ -501,8 +501,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/cilium/ebpf",
-        sum = "h1:iHsfF/t4aW4heW2YKfeHrVPGdtYTL4C4KocpM8KTSnI=",
-        version = "v0.6.2",
+        sum = "h1:1k/q3ATgxSXRdrmPfH8d7YK0GfqVsEKZAX9dQZvs56k=",
+        version = "v0.7.0",
     )
 
     go_repository(
@@ -546,8 +546,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/cncf/udpa/go",
-        sum = "h1:cqQfy1jclcSy/FwLjemeg3SR1yaINm74aQyupQ0Bl8M=",
-        version = "v0.0.0-20201120205902-5459f2c99403",
+        sum = "h1:hzAQntlaYRkVSFEfj9OTWlVV1H155FMD8BTKktLv0QI=",
+        version = "v0.0.0-20210930031921-04548b0d99d4",
     )
 
     go_repository(
@@ -555,8 +555,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/cncf/xds/go",
-        sum = "h1:CevA8fI91PAnP8vpnXuB8ZYAZ5wqY86nAbxfgK8tWO4=",
-        version = "v0.0.0-20210805033703-aa0b78936158",
+        sum = "h1:zH8ljVhhq7yC0MIeUL/IviMtY8hx2mK8cN9wEYb8ggw=",
+        version = "v0.0.0-20211011173535-cb28da3451f1",
     )
 
     go_repository(
@@ -608,8 +608,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/containerd/cgroups",
-        sum = "h1:iJnMvco9XGvKUvNQkv88bE4uJXxRQH18efbKo9w5vHQ=",
-        version = "v1.0.1",
+        sum = "h1:mZBclaSgNDfPWtfhj2xJY28LZ9nYIgzB0pwSURPl6JM=",
+        version = "v1.0.2",
     )
 
     go_repository(
@@ -617,8 +617,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/containerd/console",
-        sum = "h1:Pi6D+aZXM+oUw1czuKgH5IJ+y0jhYcwBJfx5/Ghn9dE=",
-        version = "v1.0.2",
+        sum = "h1:lIr7SlA5PxZyMV30bDW0MGbiOPXwc63yRuCP0ARubLw=",
+        version = "v1.0.3",
     )
 
     go_repository(
@@ -626,8 +626,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/containerd/containerd",
-        sum = "h1:NmkCC1/QxyZFBny8JogwLpOy2f+VEbO/f6bV2Mqtwuw=",
-        version = "v1.5.8",
+        sum = "h1:rs6Xg1gtIxaeyG+Smsb/0xaSDu1VgFhOCKBXxMxbsF4=",
+        version = "v1.5.9",
     )
 
     go_repository(
@@ -635,8 +635,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/containerd/continuity",
-        sum = "h1:j/9Wnn+hrEWjLvHuIxUU1YI5JjEjVlT2AA68cse9rwY=",
-        version = "v0.2.0",
+        sum = "h1:QSqfxcn8c+12slxwu00AtzXrsami0MJb/MQs9lOLHLA=",
+        version = "v0.2.2",
     )
 
     go_repository(
@@ -680,6 +680,14 @@ def go_repositories():
         sum = "h1:6QioHRlThlKh2RkRTR4kIT3PKAcrLo3gIWnjkM4dQmQ=",
         version = "v0.1.0",
     )
+    go_repository(
+        name = "com_github_containerd_stargz_snapshotter_estargz",
+        build_file_generation = "on",
+        build_file_proto_mode = "disable",
+        importpath = "github.com/containerd/stargz-snapshotter/estargz",
+        sum = "h1:5e7heayhB7CcgdTkqfZqrNaNv15gABwr3Q2jBTbLlt4=",
+        version = "v0.4.1",
+    )
 
     go_repository(
         name = "com_github_containerd_ttrpc",
@@ -1555,8 +1563,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/godbus/dbus/v5",
-        sum = "h1:9349emZab16e7zQvpmsbtjc18ykshndd8y2PG3sgJbA=",
-        version = "v5.0.4",
+        sum = "h1:mkgN1ofwASrYnJ5W6U/BxG15eXXXjirgZc7CLqkcaro=",
+        version = "v5.0.6",
     )
 
     go_repository(
@@ -1699,6 +1707,14 @@ def go_repositories():
         sum = "h1:BKbKCqvP6I+rmFHt06ZmyQtvB8xAkWdhFyr0ZUNZcxQ=",
         version = "v0.5.6",
     )
+    go_repository(
+        name = "com_github_google_go_containerregistry",
+        build_file_generation = "on",
+        build_file_proto_mode = "disable",
+        importpath = "github.com/google/go-containerregistry",
+        sum = "h1:/+mFTs4AlwsJ/mJe8NDtKb7BxLtbZFpcn8vDsneEkwQ=",
+        version = "v0.5.1",
+    )
 
     go_repository(
         name = "com_github_google_go_querystring",
@@ -2234,6 +2250,14 @@ def go_repositories():
         sum = "h1:aLN7YINNZ7cYOPK3QC83dbM6KT0NMqVMw961TqrejlE=",
         version = "v1.3.1",
     )
+    go_repository(
+        name = "com_github_joefitzgerald_rainbow_reporter",
+        build_file_generation = "on",
+        build_file_proto_mode = "disable",
+        importpath = "github.com/joefitzgerald/rainbow-reporter",
+        sum = "h1:AuMG652zjdzI0YCCnXAqATtRBpGXMcAnrajcaTrSeuo=",
+        version = "v0.1.0",
+    )
 
     go_repository(
         name = "com_github_jonboulle_clockwork",
@@ -2328,8 +2352,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/klauspost/compress",
-        sum = "h1:P76CopJELS0TiO2mebmnzgWaajssP/EszplttgQxcgc=",
-        version = "v1.13.6",
+        sum = "h1:hLQYb23E8/fO+1u53d02A97a8UnsddcvYzq4ERRU4ds=",
+        version = "v1.14.1",
     )
 
     go_repository(
@@ -2429,6 +2453,14 @@ def go_repositories():
         sum = "h1:9TO3cAIGXtEhnIaL+V+BEER86oLrvS+kWobKpbJuye0=",
         version = "v0.0.0-20181228230101-89fcab3d43de",
     )
+    go_repository(
+        name = "com_github_linuxkit_virtsock",
+        build_file_generation = "on",
+        build_file_proto_mode = "disable",
+        importpath = "github.com/linuxkit/virtsock",
+        sum = "h1:jUp75lepDg0phMUJBCmvaeFDldD2N3S1lBuPwUTszio=",
+        version = "v0.0.0-20201010232012-f8cee7dfc7a3",
+    )
 
     go_repository(
         name = "com_github_lithammer_dedent",
@@ -2622,14 +2654,22 @@ def go_repositories():
         sum = "h1:I0XW9+e1XWDxdcEniV4rQAIOPUGDq67JSCiRCgGCZLI=",
         version = "v1.0.2-0.20181231171920-c182affec369",
     )
+    go_repository(
+        name = "com_github_maxbrunsfeld_counterfeiter_v6",
+        build_file_generation = "on",
+        build_file_proto_mode = "disable",
+        importpath = "github.com/maxbrunsfeld/counterfeiter/v6",
+        sum = "h1:g+4J5sZg6osfvEfkRZxJ1em0VT95/UOZgi/l7zi1/oE=",
+        version = "v6.2.2",
+    )
 
     go_repository(
         name = "com_github_microsoft_go_winio",
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/Microsoft/go-winio",
-        sum = "h1:Elr9Wn+sGKPlkaBvwu4mTrxtmOp3F3yV9qhaHbXGjwU=",
-        version = "v0.5.0",
+        sum = "h1:aPJp2QD7OOrhO5tQXqQoGSJc+DjDtWTGLOmNyAm6FgY=",
+        version = "v0.5.1",
     )
 
     go_repository(
@@ -2637,8 +2677,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/Microsoft/hcsshim",
-        sum = "h1:47MSwtKGXet80aIn+7h4YI6fwPmwIghAnsx2aOUrG2M=",
-        version = "v0.8.23",
+        sum = "h1:wB06W5aYFfUB3IvootYAY2WnOmIdgPGfqSI6tufQNnY=",
+        version = "v0.9.2",
     )
     go_repository(
         name = "com_github_microsoft_hcsshim_test",
@@ -2785,8 +2825,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/moby/sys/mountinfo",
-        sum = "h1:1O+1cHA1aujwEwwVMa2Xm2l+gIpUHyd3+D+d7LZh1kM=",
-        version = "v0.4.1",
+        sum = "h1:2Ks8/r6lopsxWi9m58nlwjaeSzUX9iiL1vj5qB/9ObI=",
+        version = "v0.5.0",
     )
     go_repository(
         name = "com_github_moby_sys_symlink",
@@ -3016,8 +3056,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/opencontainers/runc",
-        sum = "h1:1hbqejyQWCJBvtKAfdO0b1FmaEf2z/bxnjqbARass5k=",
-        version = "v1.0.3",
+        sum = "h1:O9+X96OcDjkmmZyfaG996kV7yq8HsoU2h1XRRQcefG8=",
+        version = "v1.1.0",
     )
 
     go_repository(
@@ -3041,8 +3081,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/opencontainers/selinux",
-        sum = "h1:b4VPEF3O5JLZgdTDBmGepaaIbAo0GqoF6EBRq5f/g3Y=",
-        version = "v1.9.1",
+        sum = "h1:rAiKF8hTcgLI3w0DHm6i0ylVVcOrlgR1kK99DRLDhyU=",
+        version = "v1.10.0",
     )
 
     go_repository(
@@ -3313,6 +3353,14 @@ def go_repositories():
         sum = "h1:0uYX9dsZ2yD7q2RtLRtPSdGDWzjeM3TbMJP9utgA0ww=",
         version = "v1.2.0",
     )
+    go_repository(
+        name = "com_github_sclevine_spec",
+        build_file_generation = "on",
+        build_file_proto_mode = "disable",
+        importpath = "github.com/sclevine/spec",
+        sum = "h1:1Jwdf9jSfDl9NVmt8ndHqbTZ7XCCPbh1jI3hkDBHVYA=",
+        version = "v1.2.0",
+    )
 
     go_repository(
         name = "com_github_sean_seed",
@@ -3327,8 +3375,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "github.com/seccomp/libseccomp-golang",
-        sum = "h1:NJjM5DNFOs0s3kYE1WUOr6G8V97sdt46rlXTMfXGWBo=",
-        version = "v0.9.1",
+        sum = "h1:58EBmR2dMNL2n/FnbQewK3D14nXr0V9CObDSvMJLq+Y=",
+        version = "v0.9.2-0.20210429002308-3879420cc921",
     )
 
     go_repository(
@@ -4525,8 +4573,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "google.golang.org/genproto",
-        sum = "h1:Im71rbA1N3CbIag/PumYhQcNR8bLNmuOtRIyOnnLsT8=",
-        version = "v0.0.0-20211005153810-c76a74d43a8e",
+        sum = "h1:zzNejm+EgrbLfDZ6lu9Uud2IVvHySPl8vQzf04laR5Q=",
+        version = "v0.0.0-20220118154757-00ab72f36ad5",
     )
 
     go_repository(
@@ -4534,8 +4582,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "google.golang.org/grpc",
-        sum = "h1:f+PlOh7QV4iIJkPrx5NQ7qaNGFQ3OTse67yaDHfju4E=",
-        version = "v1.41.0",
+        sum = "h1:Eeu7bZtDZ2DpRCsLhUlcrLnvYaMK1Gz86a+hMVvELmM=",
+        version = "v1.43.0",
     )
 
     go_repository(
@@ -4643,8 +4691,8 @@ def go_repositories():
         build_file_generation = "on",
         build_file_proto_mode = "disable",
         importpath = "golang.org/x/sys",
-        sum = "h1:M69LAlWZCshgp0QSzyDcSsSIejIEeuaCVpmwcKwyLMk=",
-        version = "v0.0.0-20211029165221-6e7872819dc8",
+        sum = "h1:fLOSk5Q00efkSvAm+4xcoXD+RRmLmmulPn5I3Y9F2EM=",
+        version = "v0.0.0-20211216021012-1d35b9e2eb4e",
     )
 
     go_repository(
diff --git a/hack/update-codegen.sh b/hack/update-codegen.sh
index 689912637..a59900f68 100755
--- a/hack/update-codegen.sh
+++ b/hack/update-codegen.sh
@@ -142,7 +142,8 @@ gen-deepcopy() {
     --input-dirs "$joined" \
     --output-file-base zz_generated.deepcopy \
     --trim-path-prefix="$module_name" \
-    --bounding-dirs "${module_name}"
+    --bounding-dirs "${module_name}" \
+    --output-base ./
 }
 
 gen-clientsets() {
@@ -156,7 +157,8 @@ gen-clientsets() {
     --input-base "" \
     --input "$joined" \
     --trim-path-prefix="$module_name" \
-    --output-package "${client_package}"/clientset
+    --output-package "${client_package}"/clientset \
+    --output-base ./
 }
 
 gen-listers() {
@@ -168,7 +170,8 @@ gen-listers() {
     --go-header-file hack/boilerplate/boilerplate.generatego.txt \
     --input-dirs "$joined" \
     --trim-path-prefix="$module_name" \
-    --output-package "${client_package}"/listers
+    --output-package "${client_package}"/listers \
+    --output-base ./
 }
 
 gen-informers() {
@@ -182,7 +185,8 @@ gen-informers() {
     --versioned-clientset-package "${client_package}"/clientset/versioned \
     --listers-package "${client_package}"/listers \
     --trim-path-prefix="$module_name" \
-    --output-package "${client_package}"/informers
+    --output-package "${client_package}"/informers \
+    --output-base ./
 }
 
 gen-defaulters() {
@@ -195,7 +199,8 @@ gen-defaulters() {
     --go-header-file hack/boilerplate/boilerplate.generatego.txt \
     --input-dirs "$joined" \
     --trim-path-prefix="$module_name" \
-    -O zz_generated.defaults
+    -O zz_generated.defaults \
+    --output-base ./
 }
 
 gen-conversions() {
@@ -216,7 +221,8 @@ gen-conversions() {
       --extra-dirs $( IFS=$','; echo "${CONVERSION_PKGS[*]}" ) \
       --input-dirs $( IFS=$','; echo "${CONVERSION_PKGS[*]}" ) \
       --trim-path-prefix="$module_name" \
-      -O zz_generated.conversion
+      -O zz_generated.conversion \
+      --output-base ./
 }
 
 runfiles="$(pwd)"
diff --git a/internal/BUILD.bazel b/internal/BUILD.bazel
index df0415233..e3fd2d84e 100644
--- a/internal/BUILD.bazel
+++ b/internal/BUILD.bazel
@@ -9,8 +9,6 @@ filegroup(
     name = "all-srcs",
     srcs = [
         ":package-srcs",
-        "//internal/api/mutation:all-srcs",
-        "//internal/api/validation:all-srcs",
         "//internal/apis/acme:all-srcs",
         "//internal/apis/certmanager:all-srcs",
         "//internal/apis/config/webhook:all-srcs",
@@ -18,9 +16,10 @@ filegroup(
         "//internal/controller/certificates:all-srcs",
         "//internal/controller/feature:all-srcs",
         "//internal/ingress:all-srcs",
+        "//internal/plugin:all-srcs",
         "//internal/test/paths:all-srcs",
         "//internal/vault:all-srcs",
-        "//internal/webhook/feature:all-srcs",
+        "//internal/webhook:all-srcs",
     ],
     tags = ["automanaged"],
     visibility = ["//visibility:public"],
diff --git a/internal/api/mutation/registry.go b/internal/api/mutation/registry.go
deleted file mode 100644
index 97bd50db0..000000000
--- a/internal/api/mutation/registry.go
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Package mutation allows a caller to automatically register, lookup and call
-// API mutation functions.
-// It is similar to runtime.Scheme and is designed to make writing and
-// consuming API mutation functions easier.
-// This registry also handles adding scheme defaults, even if no mutation
-// functions are defined for that type. Any type where defaulting is desired
-// should be registered.
-// Functions are designed to update the incoming object, or new object, which
-// will then have a patch generated and returned to the master Mutation.
-package mutation
-
-import (
-	"bytes"
-	"encoding/json"
-	"fmt"
-	"sort"
-
-	"gomodules.xyz/jsonpatch/v2"
-	admissionv1 "k8s.io/api/admission/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/runtime/serializer"
-	apijson "k8s.io/apimachinery/pkg/runtime/serializer/json"
-)
-
-// Registry is used to store and lookup references to mutation functions for
-// given Kubernetes API types. API types will be converted into internal API
-// versions during mutation, then converted back to the target version when
-// generating the patch.
-type Registry struct {
-	codec  runtime.Codec
-	scheme *runtime.Scheme
-
-	mutateRegister       map[schema.GroupVersionKind]MutateFunc
-	mutateUpdateRegister map[schema.GroupVersionKind]MutateUpdateFunc
-}
-
-type MutateFunc func(req *admissionv1.AdmissionRequest, obj runtime.Object)
-type MutateUpdateFunc func(req *admissionv1.AdmissionRequest, old, new runtime.Object)
-
-// NewRegistry creates a new empty registry, backed by the provided Scheme.
-func NewRegistry(scheme *runtime.Scheme) *Registry {
-	factory := serializer.NewCodecFactory(scheme)
-	serializer := apijson.NewSerializerWithOptions(apijson.DefaultMetaFactory, scheme, scheme, apijson.SerializerOptions{})
-	encoder := factory.WithoutConversion().EncoderForVersion(serializer, nil)
-	decoder := factory.UniversalDeserializer()
-	return &Registry{
-		codec:                runtime.NewCodec(encoder, decoder),
-		scheme:               scheme,
-		mutateRegister:       make(map[schema.GroupVersionKind]MutateFunc),
-		mutateUpdateRegister: make(map[schema.GroupVersionKind]MutateUpdateFunc),
-	}
-}
-
-// AddMutateFunc will add a new mutation function to the register. The function
-// will be run whenever a Mutate is called with a CREATE operation, and API
-// type whose internal version is registered. Registered types MUST be that of the
-// internal version of the target resource kind.
-func (r *Registry) AddMutateFunc(obj runtime.Object, fn MutateFunc) error {
-	gvks, _, err := r.scheme.ObjectKinds(obj)
-	if err != nil {
-		return err
-	}
-
-	for _, gvk := range gvks {
-		r.appendMutate(gvk, fn)
-	}
-
-	return nil
-}
-
-// AddMutateFunc will add a new mutation function to the register. The function
-// will be run whenever a Mutate is called with an UPDATE operation, and API
-// type whose internal version is registered. Registered types MUST be that of the
-// internal version of the target resource kind.
-func (r *Registry) AddMutateUpdateFunc(obj runtime.Object, fn MutateUpdateFunc) error {
-	gvks, _, err := r.scheme.ObjectKinds(obj)
-	if err != nil {
-		return err
-	}
-
-	for _, gvk := range gvks {
-		r.appendMutateUpdate(gvk, fn)
-	}
-
-	return nil
-}
-
-// Mutate will run all mutation functions registed on CREATE and UPDATE
-// operations over the internal type of the given resource.
-// The object is converted to its internal version before either a CREATE or
-// UPDATE mutation is applied to the object. The object is then converted to
-// the requested version, and defaults applied for that schema.
-// A JSON patch is then generated for the target resource version.
-// Defaulting is always applied against the given resource, regardless of
-// whether any mutation functions are defined.
-func (r *Registry) Mutate(req *admissionv1.AdmissionRequest) ([]byte, error) {
-	// Create GroupVersionKind where the Version is set to internal.
-	gvk := schema.GroupVersionKind{
-		Group: req.RequestKind.Group,
-		// Set version to internal API version
-		Version: runtime.APIVersionInternal,
-		Kind:    req.RequestKind.Kind,
-	}
-
-	// Convert the incoming resource to the internal type
-	internal, err := r.convert(req.Object.Raw, gvk)
-	if err != nil {
-		return nil, fmt.Errorf("failed to convert object: %s", err)
-	}
-
-	switch req.Operation {
-	case admissionv1.Create:
-		// Attempt to retrieve the registered CREATE mutating functions, and apply
-		// to the internal type.
-		mutate := r.mutateRegister[gvk]
-		if mutate == nil {
-			break
-		}
-
-		mutate(req, internal)
-
-	case admissionv1.Update:
-		// Attempt to retrieve the registered UPDATE mutating functions, and apply
-		// to the internal type.
-
-		// decode the old raw object data
-		oldInternal, err := r.convert(req.OldObject.Raw, gvk)
-		if err != nil {
-			return nil, fmt.Errorf("failed to decode old admission object: %s", err)
-		}
-
-		mutate := r.mutateUpdateRegister[gvk]
-		if mutate == nil {
-			break
-		}
-
-		// Pass both the old and new internal types to mutate
-		mutate(req, oldInternal, internal)
-
-	default:
-		// If not under a CREATE or UPDATE operation, exit early
-		return nil, nil
-	}
-
-	// Convert the mutated internal object into the target resource version.
-	target, err := r.scheme.New(schema.GroupVersionKind{
-		Group:   req.RequestKind.Group,
-		Version: req.RequestKind.Version,
-		Kind:    req.RequestKind.Kind,
-	})
-	if err != nil {
-		return nil, err
-	}
-	if err := r.scheme.Convert(internal, target, nil); err != nil {
-		return nil, err
-	}
-
-	// Apply defaults to the target resource.
-	r.scheme.Default(target)
-
-	// Generate a JSON patch based on the incoming resource and the mutated object.
-	return r.createMutatePatch(req, target)
-}
-
-// convert converts a raw resource byte slice to an internal versioned resource, based on the given GroupKind.
-func (r *Registry) convert(rawObj []byte, gvk schema.GroupVersionKind) (runtime.Object, error) {
-	gvk.Version = runtime.APIVersionInternal
-	obj, _, err := r.codec.Decode(rawObj, nil, nil)
-	if err != nil {
-		return nil, fmt.Errorf("failed to decode admission object: %s", err)
-	}
-
-	targetObj, err := r.scheme.New(gvk)
-	if err != nil {
-		return nil, err
-	}
-
-	if err := r.scheme.Convert(obj, targetObj, nil); err != nil {
-		return nil, err
-	}
-
-	return targetObj, nil
-}
-
-// createMutatePatch will generate a JSON patch based upon the given original
-// raw object, and the mutated typed object.
-func (r *Registry) createMutatePatch(req *admissionv1.AdmissionRequest, obj runtime.Object) ([]byte, error) {
-	var buf bytes.Buffer
-	if err := r.codec.Encode(obj, &buf); err != nil {
-		return nil, fmt.Errorf("failed to encode object after mutation: %s", err)
-	}
-
-	ops, err := jsonpatch.CreatePatch(req.Object.Raw, buf.Bytes())
-	if err != nil {
-		return nil, fmt.Errorf("failed to set mutation patch: %s", err)
-	}
-
-	sortOps(ops)
-
-	patch, err := json.Marshal(ops)
-	if err != nil {
-		return nil, fmt.Errorf("failed to generate json patch: %s", err)
-	}
-
-	return patch, nil
-}
-
-func sortOps(ops []jsonpatch.JsonPatchOperation) {
-	sort.Slice(ops, func(i, j int) bool {
-		return ops[i].Path < ops[j].Path
-	})
-}
-
-func (r *Registry) appendMutate(gvk schema.GroupVersionKind, fn MutateFunc) {
-	existing, ok := r.mutateRegister[gvk]
-	if !ok {
-		r.mutateRegister[gvk] = fn
-		return
-	}
-
-	r.mutateRegister[gvk] = func(aspec *admissionv1.AdmissionRequest, obj runtime.Object) {
-		existing(aspec, obj)
-		fn(aspec, obj)
-	}
-}
-
-func (r *Registry) appendMutateUpdate(gvk schema.GroupVersionKind, fn MutateUpdateFunc) {
-	existing, ok := r.mutateUpdateRegister[gvk]
-	if !ok {
-		r.mutateUpdateRegister[gvk] = fn
-		return
-	}
-
-	r.mutateUpdateRegister[gvk] = func(aspec *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) {
-		existing(aspec, oldObj, newObj)
-		fn(aspec, oldObj, newObj)
-	}
-}
diff --git a/internal/api/mutation/registry_test.go b/internal/api/mutation/registry_test.go
deleted file mode 100644
index 2aceb4e78..000000000
--- a/internal/api/mutation/registry_test.go
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package mutation_test
-
-import (
-	"bytes"
-	"encoding/json"
-	"testing"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-
-	"github.com/jetstack/cert-manager/internal/api/mutation"
-	cminternal "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	"github.com/jetstack/cert-manager/pkg/apis/certmanager"
-	"github.com/jetstack/cert-manager/pkg/webhook"
-	"github.com/jetstack/cert-manager/test/unit/gen"
-)
-
-var (
-	// use the webhook's Scheme during test fixtures as it has all internal and
-	// external cert-manager kinds registered
-	scheme = webhook.Scheme
-)
-
-func TestMutate(t *testing.T) {
-	crGVK := &metav1.GroupVersionKind{
-		Group:   certmanager.GroupName,
-		Version: "v1",
-		Kind:    "CertificateRequest",
-	}
-
-	testCR := gen.CertificateRequest("test-cr",
-		gen.SetCertificateRequestTypeMeta(metav1.TypeMeta{
-			Kind:       "CertificateRequest",
-			APIVersion: "cert-manager.io/v1",
-		}),
-	)
-	testCRBytes, err := json.Marshal(testCR)
-	if err != nil {
-		t.Fatal(err)
-	}
-
-	testNotRegistered := gen.CertificateRequest("test-cr",
-		gen.SetCertificateRequestTypeMeta(metav1.TypeMeta{
-			Kind:       "NotRegistered",
-			APIVersion: "not-registered.io/v1",
-		}),
-	)
-	testNotRegisteredBytes, err := json.Marshal(testNotRegistered)
-	if err != nil {
-		t.Fatal(err)
-	}
-
-	type mutationsEntry struct {
-		obj runtime.Object
-		fn  func(t *testing.T) mutation.MutateFunc
-	}
-	type mutationUpdatesEntry struct {
-		obj runtime.Object
-		fn  func(t *testing.T) mutation.MutateUpdateFunc
-	}
-	tests := map[string]struct {
-		mutations       []mutationsEntry
-		mutationUpdates []mutationUpdatesEntry
-		req             *admissionv1.AdmissionRequest
-
-		expErr   bool
-		expPatch []byte
-	}{
-		"exit early if operation is not UPDATE or CREATE": {
-			mutations:       nil,
-			mutationUpdates: nil,
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Delete,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: nil,
-		},
-		"if no functions registered, expect only default patch on CREATE": {
-			mutations:       nil,
-			mutationUpdates: nil,
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte("[]"),
-		},
-		"if no functions registered, expect only default patch on UPDATE": {
-			mutations:       nil,
-			mutationUpdates: nil,
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Update,
-				OldObject: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte("[]"),
-		},
-		"if kind presented for mutation hasn't been registered for CREATE, error": {
-			mutations:       nil,
-			mutationUpdates: nil,
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: testNotRegisteredBytes,
-				},
-			},
-			expErr:   true,
-			expPatch: nil,
-		},
-		"if kind presented for mutation hasn't been registered for UPDATE, error": {
-			mutations:       nil,
-			mutationUpdates: nil,
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Update,
-				OldObject: runtime.RawExtension{
-					Raw: testNotRegisteredBytes,
-				},
-				Object: runtime.RawExtension{
-					Raw: testNotRegisteredBytes,
-				},
-			},
-			expErr:   true,
-			expPatch: nil,
-		},
-		"if update mutation function registered for different kind, ignore": {
-			mutations: []mutationsEntry{
-				{
-					obj: new(cminternal.Certificate),
-					fn: func(t *testing.T) mutation.MutateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _ runtime.Object) {
-							t.Error("unexpected call")
-						}
-					},
-				},
-			},
-			mutationUpdates: nil,
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte("[]"),
-		},
-		"if create mutation function registered for different kind, ignore": {
-			mutations: nil,
-			mutationUpdates: []mutationUpdatesEntry{
-				{
-					obj: new(cminternal.Certificate),
-					fn: func(t *testing.T) mutation.MutateUpdateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) {
-							t.Error("unexpected call")
-						}
-					},
-				},
-			},
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte("[]"),
-		},
-		"if create mutation function registered for kind, run mutation": {
-			mutations: []mutationsEntry{
-				{
-					obj: new(cminternal.CertificateRequest),
-					fn: func(t *testing.T) mutation.MutateFunc {
-						return func(_ *admissionv1.AdmissionRequest, obj runtime.Object) {
-							cr := obj.(*cminternal.CertificateRequest)
-							cr.Spec.Request = []byte("mutation called")
-						}
-					},
-				},
-			},
-			mutationUpdates: []mutationUpdatesEntry{
-				{
-					obj: new(cminternal.Certificate),
-					fn: func(t *testing.T) mutation.MutateUpdateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) {
-							t.Error("unexpected call")
-						}
-					},
-				},
-			},
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte(`[{"op":"replace","path":"/spec/request","value":"bXV0YXRpb24gY2FsbGVk"}]`),
-		},
-		"if update mutation function registered for kind, run mutation": {
-			mutations: []mutationsEntry{
-				{
-					obj: new(cminternal.Certificate),
-					fn: func(t *testing.T) mutation.MutateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _ runtime.Object) {
-							t.Error("unexpected call")
-						}
-					},
-				},
-			},
-			mutationUpdates: []mutationUpdatesEntry{
-				{
-					obj: new(cminternal.CertificateRequest),
-					fn: func(t *testing.T) mutation.MutateUpdateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _, obj runtime.Object) {
-							cr := obj.(*cminternal.CertificateRequest)
-							cr.Spec.Request = []byte("mutation called")
-						}
-					},
-				},
-			},
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Update,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-				OldObject: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte(`[{"op":"replace","path":"/spec/request","value":"bXV0YXRpb24gY2FsbGVk"}]`),
-		},
-		"if multiple create mutation functions registered for kind, run mutation": {
-			mutations: []mutationsEntry{
-				{
-					obj: new(cminternal.CertificateRequest),
-					fn: func(t *testing.T) mutation.MutateFunc {
-						return func(_ *admissionv1.AdmissionRequest, obj runtime.Object) {
-							cr := obj.(*cminternal.CertificateRequest)
-							cr.Spec.Request = []byte("mutation called")
-						}
-					},
-				},
-				{
-					obj: new(cminternal.CertificateRequest),
-					fn: func(t *testing.T) mutation.MutateFunc {
-						return func(_ *admissionv1.AdmissionRequest, obj runtime.Object) {
-							cr := obj.(*cminternal.CertificateRequest)
-							if cr.Annotations == nil {
-								cr.Annotations = make(map[string]string)
-							}
-							cr.Annotations["second-mutation"] = "called"
-						}
-					},
-				},
-			},
-			mutationUpdates: []mutationUpdatesEntry{
-				{
-					obj: new(cminternal.Certificate),
-					fn: func(t *testing.T) mutation.MutateUpdateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) {
-							t.Error("unexpected call")
-						}
-					},
-				},
-			},
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte(`[{"op":"add","path":"/metadata/annotations","value":{"second-mutation":"called"}},{"op":"replace","path":"/spec/request","value":"bXV0YXRpb24gY2FsbGVk"}]`),
-		},
-		"if multiple update mutation function registered for kind, run mutation": {
-			mutations: []mutationsEntry{
-				{
-					obj: new(cminternal.Certificate),
-					fn: func(t *testing.T) mutation.MutateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _ runtime.Object) {
-							t.Error("unexpected call")
-						}
-					},
-				},
-			},
-			mutationUpdates: []mutationUpdatesEntry{
-				{
-					obj: new(cminternal.CertificateRequest),
-					fn: func(t *testing.T) mutation.MutateUpdateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _, obj runtime.Object) {
-							cr := obj.(*cminternal.CertificateRequest)
-							cr.Spec.Request = []byte("mutation called")
-						}
-					},
-				},
-				{
-					obj: new(cminternal.CertificateRequest),
-					fn: func(t *testing.T) mutation.MutateUpdateFunc {
-						return func(_ *admissionv1.AdmissionRequest, _, obj runtime.Object) {
-							cr := obj.(*cminternal.CertificateRequest)
-							if cr.Annotations == nil {
-								cr.Annotations = make(map[string]string)
-							}
-							cr.Annotations["second-mutation"] = "called"
-						}
-					},
-				},
-			},
-			req: &admissionv1.AdmissionRequest{
-				RequestKind: crGVK.DeepCopy(),
-				Operation:   admissionv1.Update,
-				Object: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-				OldObject: runtime.RawExtension{
-					Raw: testCRBytes,
-				},
-			},
-			expErr:   false,
-			expPatch: []byte(`[{"op":"add","path":"/metadata/annotations","value":{"second-mutation":"called"}},{"op":"replace","path":"/spec/request","value":"bXV0YXRpb24gY2FsbGVk"}]`),
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			reg := mutation.NewRegistry(scheme)
-
-			// Add mutation functions to registry
-			for _, m := range test.mutations {
-				if err := reg.AddMutateFunc(m.obj, m.fn(t)); err != nil {
-					t.Errorf("reg.AddMutateFunc failed %v", err)
-				}
-			}
-			for _, m := range test.mutationUpdates {
-				if err := reg.AddMutateUpdateFunc(m.obj, m.fn(t)); err != nil {
-					t.Errorf("reg.AddMutateUpdateFunc failed: %v", err)
-				}
-			}
-
-			patch, err := reg.Mutate(test.req)
-			if test.expErr != (err != nil) {
-				t.Errorf("unexpected error, exp=%t got=%v",
-					test.expErr, err)
-			}
-
-			if !bytes.Equal(test.expPatch, patch) {
-				t.Errorf("unexpected patch, exp=%s got=%s",
-					test.expPatch, patch)
-			}
-		})
-	}
-}
diff --git a/internal/api/validation/registry.go b/internal/api/validation/registry.go
deleted file mode 100644
index 6c5e297a5..000000000
--- a/internal/api/validation/registry.go
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Package validation allows a caller to automatically register, lookup and
-// call API validation functions.
-// It is similar to runtime.Scheme and is designed to make writing and
-// consuming API validation functions easier.
-package validation
-
-import (
-	admissionv1 "k8s.io/api/admission/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-)
-
-// Registry is used to store and lookup references to validation functions for
-// given Kubernetes API types.
-type Registry struct {
-	scheme                 *runtime.Scheme
-	validateRegister       map[schema.GroupVersionKind]ValidateFunc
-	validateUpdateRegister map[schema.GroupVersionKind]ValidateUpdateFunc
-}
-
-// ValidateFunc is a function type that implements validation for an admission
-// request associated with a creation of an object of a particular type.
-type ValidateFunc func(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, WarningList)
-
-// ValidateUpdateFunc is a function type that implements validation for an
-// admission request associated with update of an object of a particular type.
-type ValidateUpdateFunc func(req *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, WarningList)
-
-// NewRegistry creates a new empty registry, backed by the provided Scheme.
-func NewRegistry(scheme *runtime.Scheme) *Registry {
-	return &Registry{
-		scheme:                 scheme,
-		validateRegister:       make(map[schema.GroupVersionKind]ValidateFunc),
-		validateUpdateRegister: make(map[schema.GroupVersionKind]ValidateUpdateFunc),
-	}
-}
-
-// AddValidateFunc will add a new validation function to the register.
-// The function will be run whenever Validate is called with a requestVersion
-// set to any recognised GroupVersionKinds for this object.
-// If obj is part of an internal API version, the validation function will be
-// called on all calls to Validate regardless of version.
-// If obj cannot be recognised using the registry's scheme, an error will be
-// returned.
-func (r *Registry) AddValidateFunc(obj runtime.Object, fn ValidateFunc) error {
-	gvks, _, err := r.scheme.ObjectKinds(obj)
-	if err != nil {
-		return err
-	}
-
-	for _, gvk := range gvks {
-		r.appendValidate(gvk, fn)
-	}
-
-	return nil
-}
-
-// AddValidateUpdateFunc will add a new validation function to the register.
-// The function will be run whenever ValidateUpdate is called with a
-// requestVersion set to any recognised GroupVersionKinds for this object.
-// If obj is part of an internal API version, the validation function will be
-// called on all calls to Validate regardless of version.
-// If obj cannot be recognised using the registry's scheme, an error will be
-// returned.
-func (r *Registry) AddValidateUpdateFunc(obj runtime.Object, fn ValidateUpdateFunc) error {
-	gvks, _, err := r.scheme.ObjectKinds(obj)
-	if err != nil {
-		return err
-	}
-
-	for _, gvk := range gvks {
-		r.appendValidateUpdate(gvk, fn)
-	}
-
-	return nil
-}
-
-// Validate will run all validation functions registered for the given object.
-// If the passed obj is *not* of the same version as the provided
-// requestVersion, the registry will attempt to convert the object before
-// calling the validation functions.
-// Any validation functions registered for the objects internal API version
-// will be run against the object regardless of version.
-func (r *Registry) Validate(req *admissionv1.AdmissionRequest, obj runtime.Object, requestVersion schema.GroupVersionKind) (field.ErrorList, WarningList) {
-	versioned, internal := r.lookupValidateFuncs(requestVersion)
-	if versioned == nil && internal == nil {
-		return nil, nil
-	}
-
-	targetObj, internalObj, err := r.convert(obj, requestVersion)
-	if err != nil {
-		return internalError(err), nil
-	}
-
-	el := field.ErrorList{}
-	warnings := WarningList{}
-	if versioned != nil {
-		e, w := versioned(req, targetObj)
-		el, warnings = append(el, e...), append(warnings, w...)
-	}
-	if internal != nil {
-		e, w := internal(req, internalObj)
-		el, warnings = append(el, e...), append(warnings, w...)
-	}
-
-	return el, warnings
-}
-
-// ValidateUpdate will run all update validation functions registered for the
-// given object.
-// If the passed objects are *not* of the same version as the provided
-// requestVersion, the registry will attempt to convert the objects before
-// calling the validation functions.
-// Any validation functions registered for the objects internal API version
-// will be run against the object regardless of version.
-func (r *Registry) ValidateUpdate(req *admissionv1.AdmissionRequest, oldObj, obj runtime.Object, requestVersion schema.GroupVersionKind) (field.ErrorList, []string) {
-	versioned, internal := r.lookupValidateUpdateFuncs(requestVersion)
-	if versioned == nil && internal == nil {
-		return nil, nil
-	}
-
-	targetOldObj, internalOldObj, err := r.convert(oldObj, requestVersion)
-	if err != nil {
-		return internalError(err), nil
-	}
-
-	targetObj, internalObj, err := r.convert(obj, requestVersion)
-	if err != nil {
-		return internalError(err), nil
-	}
-
-	el := field.ErrorList{}
-	warnings := WarningList{}
-	if versioned != nil {
-		e, w := versioned(req, targetOldObj, targetObj)
-		el, warnings = append(el, e...), append(warnings, w...)
-	}
-	if internal != nil {
-		e, w := internal(req, internalOldObj, internalObj)
-		el, warnings = append(el, e...), append(warnings, w...)
-	}
-
-	return el, warnings
-}
-
-func (r *Registry) lookupValidateFuncs(gvk schema.GroupVersionKind) (versioned ValidateFunc, internal ValidateFunc) {
-	versioned = r.validateRegister[gvk]
-	gvk.Version = runtime.APIVersionInternal
-	internal = r.validateRegister[gvk]
-	return versioned, internal
-}
-
-func (r *Registry) lookupValidateUpdateFuncs(gvk schema.GroupVersionKind) (versioned ValidateUpdateFunc, internal ValidateUpdateFunc) {
-	versioned = r.validateUpdateRegister[gvk]
-	gvk.Version = runtime.APIVersionInternal
-	internal = r.validateUpdateRegister[gvk]
-	return versioned, internal
-}
-
-func (r *Registry) appendValidate(gvk schema.GroupVersionKind, fn ValidateFunc) {
-	existing, ok := r.validateRegister[gvk]
-	if !ok {
-		r.validateRegister[gvk] = fn
-		return
-	}
-
-	// If a ValidateFunc for GVK already exists, build a new ValidateFunc that
-	// will return both the results of the new and old ValidateFunc.
-	r.validateRegister[gvk] = func(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, WarningList) {
-		e, w := existing(req, obj)
-		newE, newW := fn(req, obj)
-		return append(e, newE...), append(w, newW...)
-	}
-}
-
-func (r *Registry) appendValidateUpdate(gvk schema.GroupVersionKind, fn ValidateUpdateFunc) {
-	existing, ok := r.validateUpdateRegister[gvk]
-	if !ok {
-		r.validateUpdateRegister[gvk] = fn
-		return
-	}
-
-	// If a ValidateUpdateFunc for GVK already exists, build a new
-	// ValidateUpdateFunc that will return both the results of the new and old
-	// ValidateUpdateFunc.
-	r.validateUpdateRegister[gvk] = func(req *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, WarningList) {
-		e, w := existing(req, oldObj, obj)
-		newE, newW := fn(req, oldObj, obj)
-		return append(e, newE...), append(w, newW...)
-	}
-}
-
-// convert will convert the given obj into the requestVersion as well as
-// returning the internal representation of the object.
-func (r *Registry) convert(obj runtime.Object, requestVersion schema.GroupVersionKind) (targetObj, internalObj runtime.Object, err error) {
-	// create a new object in the desired version
-	targetObj, err = r.scheme.New(requestVersion)
-	if err != nil {
-		return nil, nil, err
-	}
-	// create a new object in the 'internal' version
-	internalVersion := requestVersion
-	internalVersion.Version = runtime.APIVersionInternal
-	internalObj, err = r.scheme.New(internalVersion)
-	if err != nil {
-		return nil, nil, err
-	}
-
-	// convert the obj into the internalVersion first
-	if err := r.scheme.Convert(obj, internalObj, nil); err != nil {
-		return nil, nil, err
-	}
-
-	// convert the internalObj into the requestVersion
-	if err := r.scheme.Convert(internalObj, targetObj, nil); err != nil {
-		return nil, nil, err
-	}
-
-	return targetObj, internalObj, nil
-}
-
-func internalError(err error) field.ErrorList {
-	return field.ErrorList{field.InternalError(nil, err)}
-}
diff --git a/internal/api/validation/registry_test.go b/internal/api/validation/registry_test.go
deleted file mode 100644
index 9ae1fd4da..000000000
--- a/internal/api/validation/registry_test.go
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation_test
-
-import (
-	"fmt"
-	"reflect"
-	"testing"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	corev1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmapiinternal "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
-	"github.com/jetstack/cert-manager/pkg/webhook"
-)
-
-var (
-	// use the webhook's Scheme during test fixtures as it has all internal and
-	// external cert-manager kinds registered
-	scheme = webhook.Scheme
-)
-
-func TestValidateType(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	called := false
-	utilruntime.Must(reg.AddValidateFunc(&cmapi.Certificate{}, func(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		called = true
-		return nil, nil
-	}))
-	errs, warnings := reg.Validate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("expected no warnings but got: %+v", warnings)
-	}
-	if !called {
-		t.Errorf("expected registered validation function to run but it did not")
-	}
-}
-
-func TestValidateTypeMultiple(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	called1 := false
-	called2 := false
-	calledInternal := false
-	utilruntime.Must(reg.AddValidateFunc(&cmapi.Certificate{}, func(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		called1 = true
-		return nil, nil
-	}))
-	utilruntime.Must(reg.AddValidateFunc(&cmapi.Certificate{}, func(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		called2 = true
-		return nil, nil
-	}))
-	utilruntime.Must(reg.AddValidateFunc(&cmapiinternal.Certificate{}, func(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		calledInternal = true
-		return nil, nil
-	}))
-	errs, warnings := reg.Validate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("expected to not get any warnings but got %+v", warnings)
-	}
-	if !called1 || !called2 {
-		t.Errorf("expected registered validation function to run but it did not")
-	}
-	if !calledInternal {
-		t.Errorf("expected registered internal validation function to run against external type but it did not")
-	}
-}
-
-func TestValidateUpdateTypeMultiple(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	called1 := false
-	called2 := false
-	calledInternal := false
-	utilruntime.Must(reg.AddValidateUpdateFunc(&cmapi.Certificate{}, func(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) (field.ErrorList, validation.WarningList) {
-		called1 = true
-		return nil, nil
-	}))
-	utilruntime.Must(reg.AddValidateUpdateFunc(&cmapi.Certificate{}, func(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) (field.ErrorList, validation.WarningList) {
-		called2 = true
-		return nil, nil
-	}))
-	utilruntime.Must(reg.AddValidateUpdateFunc(&cmapiinternal.Certificate{}, func(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) (field.ErrorList, validation.WarningList) {
-		calledInternal = true
-		return nil, nil
-	}))
-	errs, warnings := reg.ValidateUpdate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("expected to not get any warnings but got: %v", warnings)
-	}
-	if !called1 || !called2 {
-		t.Errorf("expected registered validation function to run but it did not")
-	}
-	if !calledInternal {
-		t.Errorf("expected registered internal validation function to run against external type but it did not")
-	}
-}
-
-func TestValidateUpdateType(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	called := false
-	utilruntime.Must(reg.AddValidateUpdateFunc(&cmapi.Certificate{}, func(_ *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		called = true
-		return nil, nil
-	}))
-	errs, warnings := reg.ValidateUpdate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("expected to not get any warnings but got %+v", warnings)
-	}
-	if !called {
-		t.Errorf("expected registered validation function to run but it did not")
-	}
-}
-
-func TestValidateTypeReturnsErrorsAndWarnings(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	called := false
-	expectedErr := field.InternalError(nil, fmt.Errorf("failed"))
-	expectedWarnings := validation.WarningList{"test warning"}
-	utilruntime.Must(reg.AddValidateFunc(&cmapi.Certificate{}, func(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		called = true
-		return field.ErrorList{expectedErr}, expectedWarnings
-	}))
-	errs, warnings := reg.Validate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) != 1 {
-		t.Error("expected to get an error but got none")
-	} else if err := errs[0]; err.Error() != expectedErr.Error() {
-		t.Errorf("expected error to be %q but got %q", expectedErr.Error(), err.Error())
-	}
-	if !reflect.DeepEqual(warnings, expectedWarnings) {
-		t.Errorf("expected warnings %+#v got %+#v", expectedWarnings, warnings)
-	}
-	if !called {
-		t.Errorf("expected registered validation function to run but it did not")
-	}
-}
-
-func TestValidateInternalType(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	called := false
-	utilruntime.Must(reg.AddValidateFunc(&cmapiinternal.Certificate{}, func(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		called = true
-		return nil, nil
-	}))
-	errs, warnings := reg.Validate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("expected to not get any warnings but got %+v", warnings)
-	}
-	if !called {
-		t.Errorf("expected registered internal validation function to run for external type but it did not")
-	}
-}
-
-func TestValidateNoErrorNoneRegistered(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	errs, warnings := reg.Validate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("expected to not get any warnings but got: %+v", warnings)
-	}
-}
-
-func TestValidateUpdateNoErrorNoneRegistered(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	errs, warnings := reg.ValidateUpdate(&admissionv1.AdmissionRequest{}, &cmapi.Certificate{}, &cmapi.Certificate{}, cmapi.SchemeGroupVersion.WithKind("Certificate"))
-	if len(errs) > 0 {
-		t.Errorf("expected to not get an error but got: %v", errs.ToAggregate())
-	}
-	if len(warnings) > 0 {
-		t.Errorf("exptected to not get any warnings but got: %+v", warnings)
-	}
-}
-
-func TestValidateUnrecognisedType(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	err := reg.AddValidateFunc(&corev1.Pod{}, func(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		return nil, nil
-	})
-	if err == nil {
-		t.Errorf("expected to get an error but did not")
-	}
-}
-
-func TestValidateUpdateUnrecognisedType(t *testing.T) {
-	reg := validation.NewRegistry(scheme)
-	err := reg.AddValidateUpdateFunc(&corev1.Pod{}, func(_ *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-		return nil, nil
-	})
-	if err == nil {
-		t.Errorf("expected to get an error but did not")
-	}
-}
diff --git a/internal/api/validation/warning.go b/internal/api/validation/warning.go
deleted file mode 100644
index 46c673465..000000000
--- a/internal/api/validation/warning.go
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation
-
-// WarningList is a list of warnings that will be returned by the validating webhook.
-// See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#webhook-request-and-response
-type WarningList []string
diff --git a/internal/apis/acme/install/BUILD.bazel b/internal/apis/acme/install/BUILD.bazel
index 2f065fb2e..d8486e5bc 100644
--- a/internal/apis/acme/install/BUILD.bazel
+++ b/internal/apis/acme/install/BUILD.bazel
@@ -6,13 +6,11 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/internal/apis/acme/install",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//internal/apis/acme:go_default_library",
         "//internal/apis/acme/v1:go_default_library",
         "//internal/apis/acme/v1alpha2:go_default_library",
         "//internal/apis/acme/v1alpha3:go_default_library",
         "//internal/apis/acme/v1beta1:go_default_library",
-        "//internal/apis/acme/validation:go_default_library",
         "//internal/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/util/runtime:go_default_library",
diff --git a/internal/apis/acme/install/install.go b/internal/apis/acme/install/install.go
index 45dfdb842..27825e38e 100644
--- a/internal/apis/acme/install/install.go
+++ b/internal/apis/acme/install/install.go
@@ -22,13 +22,11 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	"github.com/jetstack/cert-manager/internal/apis/acme"
 	cmapi "github.com/jetstack/cert-manager/internal/apis/acme/v1"
 	"github.com/jetstack/cert-manager/internal/apis/acme/v1alpha2"
 	"github.com/jetstack/cert-manager/internal/apis/acme/v1alpha3"
 	"github.com/jetstack/cert-manager/internal/apis/acme/v1beta1"
-	acmevalidation "github.com/jetstack/cert-manager/internal/apis/acme/validation"
 	cmmetav1 "github.com/jetstack/cert-manager/internal/apis/meta/v1"
 )
 
@@ -41,9 +39,3 @@ func Install(scheme *runtime.Scheme) {
 	utilruntime.Must(cmapi.AddToScheme(scheme))
 	utilruntime.Must(cmmetav1.AddToScheme(scheme))
 }
-
-// InstallValidation registers validation functions for the API group with a
-// validation registry
-func InstallValidation(registry *validation.Registry) {
-	utilruntime.Must(acmevalidation.AddToValidationRegistry(registry))
-}
diff --git a/internal/apis/acme/validation/BUILD.bazel b/internal/apis/acme/validation/BUILD.bazel
index b590e5624..8c29ec119 100644
--- a/internal/apis/acme/validation/BUILD.bazel
+++ b/internal/apis/acme/validation/BUILD.bazel
@@ -4,23 +4,14 @@ go_library(
     name = "go_default_library",
     srcs = [
         "challenge.go",
-        "deprecation.go",
         "order.go",
-        "register.go",
     ],
     importpath = "github.com/jetstack/cert-manager/internal/apis/acme/validation",
     visibility = ["//:__subpackages__"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//internal/apis/acme:go_default_library",
-        "//internal/apis/acme/v1alpha2:go_default_library",
-        "//internal/apis/acme/v1alpha3:go_default_library",
-        "//internal/apis/acme/v1beta1:go_default_library",
-        "//pkg/apis/acme/v1:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
-        "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
     ],
 )
@@ -33,12 +24,7 @@ go_test(
     ],
     embed = [":go_default_library"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//internal/apis/acme:go_default_library",
-        "//internal/apis/acme/v1alpha2:go_default_library",
-        "//internal/apis/acme/v1alpha3:go_default_library",
-        "//internal/apis/acme/v1beta1:go_default_library",
-        "//pkg/apis/acme/v1:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
diff --git a/internal/apis/acme/validation/challenge.go b/internal/apis/acme/validation/challenge.go
index f3e924b3b..12754e0a3 100644
--- a/internal/apis/acme/validation/challenge.go
+++ b/internal/apis/acme/validation/challenge.go
@@ -23,11 +23,10 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
 )
 
-func ValidateChallengeUpdate(a *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateChallengeUpdate(a *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, []string) {
 	old, ok := oldObj.(*cmacme.Challenge)
 	new := newObj.(*cmacme.Challenge)
 	// if oldObj is not set, the Update operation is always valid.
@@ -39,11 +38,9 @@ func ValidateChallengeUpdate(a *admissionv1.AdmissionRequest, oldObj, newObj run
 	if !reflect.DeepEqual(old.Spec, new.Spec) {
 		el = append(el, field.Forbidden(field.NewPath("spec"), "challenge spec is immutable after creation"))
 	}
-	warnings := validateAPIVersion(a.RequestKind)
-	return el, warnings
+	return el, nil
 }
 
-func ValidateChallenge(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-	warnings := validateAPIVersion(a.RequestKind)
-	return nil, warnings
+func ValidateChallenge(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
+	return nil, nil
 }
diff --git a/internal/apis/acme/validation/challenge_test.go b/internal/apis/acme/validation/challenge_test.go
index 298736551..bc8015579 100644
--- a/internal/apis/acme/validation/challenge_test.go
+++ b/internal/apis/acme/validation/challenge_test.go
@@ -17,7 +17,6 @@ limitations under the License.
 package validation
 
 import (
-	"fmt"
 	"reflect"
 	"testing"
 
@@ -25,20 +24,10 @@ import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
-	cmacmev1alpha2 "github.com/jetstack/cert-manager/internal/apis/acme/v1alpha2"
-	cmacmev1alpha3 "github.com/jetstack/cert-manager/internal/apis/acme/v1alpha3"
-	cmacmev1beta1 "github.com/jetstack/cert-manager/internal/apis/acme/v1beta1"
-	cmacmev1 "github.com/jetstack/cert-manager/pkg/apis/acme/v1"
 )
 
 func TestValidateChallengeUpdate(t *testing.T) {
-	baseChal := &cmacme.Challenge{
-		Spec: cmacme.ChallengeSpec{
-			URL: "testurl",
-		},
-	}
 	someAdmissionRequest := &admissionv1.AdmissionRequest{
 		RequestKind: &metav1.GroupVersionKind{
 			Group:   "test",
@@ -51,7 +40,7 @@ func TestValidateChallengeUpdate(t *testing.T) {
 		old, new *cmacme.Challenge
 		a        *admissionv1.AdmissionRequest
 		errs     []*field.Error
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"allows setting challenge spec for the first time": {
 			new: &cmacme.Challenge{
@@ -90,66 +79,6 @@ func TestValidateChallengeUpdate(t *testing.T) {
 			},
 			a: someAdmissionRequest,
 		},
-		"challenge updated to v1alpha2 version": {
-			old: baseChal,
-			new: &cmacme.Challenge{
-				Spec: cmacme.ChallengeSpec{
-					URL: "testurl",
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Challenge"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha2.SchemeGroupVersion.String(),
-					"Challenge",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Challenge"),
-			},
-		},
-		"challenge updated to v1alpha3 version": {
-			old: baseChal,
-			new: &cmacme.Challenge{
-				Spec: cmacme.ChallengeSpec{
-					URL: "testurl",
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Challenge"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha3.SchemeGroupVersion.String(),
-					"Challenge",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Challenge"),
-			},
-		},
-		"challenge updated to v1beta1 version": {
-			old: baseChal,
-			new: &cmacme.Challenge{
-				Spec: cmacme.ChallengeSpec{
-					URL: "testurl",
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Challenge"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1beta1.SchemeGroupVersion.String(),
-					"Challenge",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Challenge"),
-			},
-		},
 	}
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
@@ -176,66 +105,8 @@ func TestValidateChallenge(t *testing.T) {
 		chal     *cmacme.Challenge
 		a        *admissionv1.AdmissionRequest
 		errs     []*field.Error
-		warnings validation.WarningList
-	}{
-		"challenge updated to v1alpha2 version": {
-			chal: &cmacme.Challenge{
-				Spec: cmacme.ChallengeSpec{
-					URL: "testurl",
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Challenge"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha2.SchemeGroupVersion.String(),
-					"Challenge",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Challenge"),
-			},
-		},
-		"challenge updated to v1alpha3 version": {
-			chal: &cmacme.Challenge{
-				Spec: cmacme.ChallengeSpec{
-					URL: "testurl",
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Challenge"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha3.SchemeGroupVersion.String(),
-					"Challenge",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Challenge"),
-			},
-		},
-		"challenge updated to v1beta1 version": {
-			chal: &cmacme.Challenge{
-				Spec: cmacme.ChallengeSpec{
-					URL: "testurl",
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Challenge"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1beta1.SchemeGroupVersion.String(),
-					"Challenge",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Challenge"),
-			},
-		},
-	}
+		warnings []string
+	}{}
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
 			errs, warnings := ValidateChallenge(s.a, s.chal)
diff --git a/internal/apis/acme/validation/deprecation.go b/internal/apis/acme/validation/deprecation.go
deleted file mode 100644
index 4a696c27b..000000000
--- a/internal/apis/acme/validation/deprecation.go
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation
-
-import (
-	"fmt"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmacmev1alpha2 "github.com/jetstack/cert-manager/internal/apis/acme/v1alpha2"
-	cmacmev1alpha3 "github.com/jetstack/cert-manager/internal/apis/acme/v1alpha3"
-	cmacmev1beta1 "github.com/jetstack/cert-manager/internal/apis/acme/v1beta1"
-	cmacme "github.com/jetstack/cert-manager/pkg/apis/acme/v1"
-)
-
-// This file holds temporary functionality for cert-manager v1.4 API deprecation.
-// It will be removed in cert-manager v1.6, when we remove the deprecated APIs.
-var (
-	deprecatedAPIs = map[string]schema.GroupVersion{
-		cmacmev1alpha2.SchemeGroupVersion.String(): cmacme.SchemeGroupVersion,
-		cmacmev1alpha3.SchemeGroupVersion.String(): cmacme.SchemeGroupVersion,
-		cmacmev1beta1.SchemeGroupVersion.String():  cmacme.SchemeGroupVersion,
-	}
-
-	deprecationMessageTemplate = "%s %s is deprecated in v1.4+, unavailable in v1.6+; use %v %s"
-)
-
-func validateAPIVersion(gvk *metav1.GroupVersionKind) validation.WarningList {
-	// There might be a smarter way to get GroupVersion
-	gv := fmt.Sprintf("%s/%s", gvk.Group, gvk.Version)
-	kind := gvk.Kind
-	if newV, ok := deprecatedAPIs[gv]; ok {
-		w := fmt.Sprintf(deprecationMessageTemplate, gv, kind, newV, kind)
-		return validation.WarningList{w}
-	}
-	return nil
-}
diff --git a/internal/apis/acme/validation/order.go b/internal/apis/acme/validation/order.go
index c32a8888e..320759694 100644
--- a/internal/apis/acme/validation/order.go
+++ b/internal/apis/acme/validation/order.go
@@ -23,11 +23,10 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
 )
 
-func ValidateOrderUpdate(a *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateOrderUpdate(a *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, []string) {
 	old, ok := oldObj.(*cmacme.Order)
 	new := newObj.(*cmacme.Order)
 	// if oldObj is not set, the Update operation is always valid.
@@ -38,13 +37,11 @@ func ValidateOrderUpdate(a *admissionv1.AdmissionRequest, oldObj, newObj runtime
 	el := field.ErrorList{}
 	el = append(el, ValidateOrderSpecUpdate(old.Spec, new.Spec, field.NewPath("spec"))...)
 	el = append(el, ValidateOrderStatusUpdate(old.Status, new.Status, field.NewPath("status"))...)
-	warnings := validateAPIVersion(a.RequestKind)
-	return el, warnings
+	return el, nil
 }
 
-func ValidateOrder(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-	warnings := validateAPIVersion(a.RequestKind)
-	return nil, warnings
+func ValidateOrder(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
+	return nil, nil
 }
 
 func ValidateOrderSpecUpdate(old, new cmacme.OrderSpec, fldPath *field.Path) field.ErrorList {
diff --git a/internal/apis/acme/validation/order_test.go b/internal/apis/acme/validation/order_test.go
index 5c18c1c09..838896fd2 100644
--- a/internal/apis/acme/validation/order_test.go
+++ b/internal/apis/acme/validation/order_test.go
@@ -17,22 +17,15 @@ limitations under the License.
 package validation
 
 import (
-	"fmt"
 	"reflect"
 	"testing"
 
 	admissionv1 "k8s.io/api/admission/v1"
-	"k8s.io/utils/pointer"
-
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
+	"k8s.io/utils/pointer"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
-	cmacmev1alpha2 "github.com/jetstack/cert-manager/internal/apis/acme/v1alpha2"
-	cmacmev1alpha3 "github.com/jetstack/cert-manager/internal/apis/acme/v1alpha3"
-	cmacmev1beta1 "github.com/jetstack/cert-manager/internal/apis/acme/v1beta1"
-	cmacmev1 "github.com/jetstack/cert-manager/pkg/apis/acme/v1"
 )
 
 type testValue string
@@ -61,7 +54,7 @@ func testImmutableOrderField(t *testing.T, fldPath *field.Path, setter func(*cma
 		expectedErrs := []*field.Error{
 			field.Forbidden(fldPath, "field is immutable once set"),
 		}
-		var expectedWarnings validation.WarningList
+		var expectedWarnings []string
 		old := &cmacme.Order{}
 		new := &cmacme.Order{}
 		setter(old, testValueOptionOne)
@@ -83,7 +76,7 @@ func testImmutableOrderField(t *testing.T, fldPath *field.Path, setter func(*cma
 	})
 	t.Run("should allow updates to "+fldPath.String()+" if not already set", func(t *testing.T) {
 		expectedErrs := []*field.Error{}
-		var expectedWarnings validation.WarningList
+		var expectedWarnings []string
 		old := &cmacme.Order{}
 		new := &cmacme.Order{}
 		setter(old, testValueNone)
@@ -223,17 +216,11 @@ func TestValidateOrderUpdate(t *testing.T) {
 		}
 	})
 
-	baseOrder := &cmacme.Order{
-		Spec: cmacme.OrderSpec{
-			Request: []byte("testing"),
-		},
-	}
-
 	scenarios := map[string]struct {
 		old, new *cmacme.Order
 		a        *admissionv1.AdmissionRequest
 		errs     []*field.Error
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"allows all updates if old is nil": {
 			new: &cmacme.Order{
@@ -243,66 +230,6 @@ func TestValidateOrderUpdate(t *testing.T) {
 			},
 			a: someAdmissionRequest,
 		},
-		"Order updated to v1alpha2 version": {
-			old: baseOrder,
-			new: &cmacme.Order{
-				Spec: cmacme.OrderSpec{
-					Request: []byte("testing"),
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Order"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha2.SchemeGroupVersion.String(),
-					"Order",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Order"),
-			},
-		},
-		"Order updated to v1alpha3 version": {
-			old: baseOrder,
-			new: &cmacme.Order{
-				Spec: cmacme.OrderSpec{
-					Request: []byte("testing"),
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Order"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha3.SchemeGroupVersion.String(),
-					"Order",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Order"),
-			},
-		},
-		"Order updated to v1beta1 version": {
-			old: baseOrder,
-			new: &cmacme.Order{
-				Spec: cmacme.OrderSpec{
-					Request: []byte("testing"),
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Order"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1beta1.SchemeGroupVersion.String(),
-					"Order",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Order"),
-			},
-		},
 	}
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
@@ -329,66 +256,8 @@ func TestValidateOrder(t *testing.T) {
 		order    *cmacme.Order
 		a        *admissionv1.AdmissionRequest
 		errs     []*field.Error
-		warnings validation.WarningList
-	}{
-		"Order updated to v1alpha2 version": {
-			order: &cmacme.Order{
-				Spec: cmacme.OrderSpec{
-					Request: []byte("testing"),
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Order"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha2.SchemeGroupVersion.String(),
-					"Order",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Order"),
-			},
-		},
-		"Order updated to v1alpha3 version": {
-			order: &cmacme.Order{
-				Spec: cmacme.OrderSpec{
-					Request: []byte("testing"),
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Order"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1alpha3.SchemeGroupVersion.String(),
-					"Order",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Order"),
-			},
-		},
-		"Order updated to v1beta1 version": {
-			order: &cmacme.Order{
-				Spec: cmacme.OrderSpec{
-					Request: []byte("testing"),
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "acme.cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Order"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmacmev1beta1.SchemeGroupVersion.String(),
-					"Order",
-					cmacmev1.SchemeGroupVersion.String(),
-					"Order"),
-			},
-		},
-	}
+		warnings []string
+	}{}
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
 			errs, warnings := ValidateOrder(s.a, s.order)
diff --git a/internal/apis/acme/validation/register.go b/internal/apis/acme/validation/register.go
deleted file mode 100644
index 685db98d2..000000000
--- a/internal/apis/acme/validation/register.go
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation
-
-import (
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
-)
-
-func AddToValidationRegistry(reg *validation.Registry) error {
-	if err := reg.AddValidateUpdateFunc(&cmacme.Challenge{}, ValidateChallengeUpdate); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&cmacme.Order{}, ValidateOrderUpdate); err != nil {
-		return err
-	}
-	return nil
-}
diff --git a/internal/apis/certmanager/BUILD.bazel b/internal/apis/certmanager/BUILD.bazel
index c63ad0e3e..6698c8dc1 100644
--- a/internal/apis/certmanager/BUILD.bazel
+++ b/internal/apis/certmanager/BUILD.bazel
@@ -36,7 +36,6 @@ filegroup(
     srcs = [
         ":package-srcs",
         "//internal/apis/certmanager/fuzzer:all-srcs",
-        "//internal/apis/certmanager/identity:all-srcs",
         "//internal/apis/certmanager/install:all-srcs",
         "//internal/apis/certmanager/v1:all-srcs",
         "//internal/apis/certmanager/v1alpha2:all-srcs",
diff --git a/internal/apis/certmanager/identity/BUILD.bazel b/internal/apis/certmanager/identity/BUILD.bazel
deleted file mode 100644
index 1499d4717..000000000
--- a/internal/apis/certmanager/identity/BUILD.bazel
+++ /dev/null
@@ -1,31 +0,0 @@
-load("@io_bazel_rules_go//go:def.bzl", "go_library")
-
-go_library(
-    name = "go_default_library",
-    srcs = ["identity.go"],
-    importpath = "github.com/jetstack/cert-manager/internal/apis/certmanager/identity",
-    visibility = ["//:__subpackages__"],
-    deps = [
-        "//internal/api/mutation:go_default_library",
-        "//internal/api/validation:go_default_library",
-        "//internal/apis/certmanager:go_default_library",
-        "//internal/apis/certmanager/identity/certificaterequests:go_default_library",
-    ],
-)
-
-filegroup(
-    name = "package-srcs",
-    srcs = glob(["**"]),
-    tags = ["automanaged"],
-    visibility = ["//visibility:private"],
-)
-
-filegroup(
-    name = "all-srcs",
-    srcs = [
-        ":package-srcs",
-        "//internal/apis/certmanager/identity/certificaterequests:all-srcs",
-    ],
-    tags = ["automanaged"],
-    visibility = ["//visibility:public"],
-)
diff --git a/internal/apis/certmanager/identity/certificaterequests/certificaterequests.go b/internal/apis/certmanager/identity/certificaterequests/certificaterequests.go
deleted file mode 100644
index 8fd08c908..000000000
--- a/internal/apis/certmanager/identity/certificaterequests/certificaterequests.go
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-// Package certificaterequests populates and enforces identity on
-// CertificateRequest resources.
-package certificaterequests
-
-import (
-	"reflect"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	authenticationv1 "k8s.io/api/authentication/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	"github.com/jetstack/cert-manager/pkg/util"
-)
-
-func ValidateCreate(req *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
-	cr := obj.(*cmapi.CertificateRequest)
-	fldPath := field.NewPath("spec")
-
-	var el field.ErrorList
-	if cr.Spec.UID != req.UserInfo.UID {
-		el = append(el, field.Forbidden(fldPath.Child("uid"), "uid identity must be that of the requester"))
-	}
-	if cr.Spec.Username != req.UserInfo.Username {
-		el = append(el, field.Forbidden(fldPath.Child("username"), "username identity must be that of the requester"))
-	}
-	if !util.EqualUnsorted(cr.Spec.Groups, req.UserInfo.Groups) {
-		el = append(el, field.Forbidden(fldPath.Child("groups"), "groups identity must be that of the requester"))
-	}
-	if !extrasMatch(cr.Spec.Extra, req.UserInfo.Extra) {
-		el = append(el, field.Forbidden(fldPath.Child("extra"), "extra identity must be that of the requester"))
-	}
-
-	return el, nil
-}
-
-func extrasMatch(crExtra map[string][]string, reqExtra map[string]authenticationv1.ExtraValue) bool {
-	if len(crExtra) != len(reqExtra) {
-		return false
-	}
-
-	for k, v := range crExtra {
-		reqv, ok := reqExtra[k]
-		if !ok {
-			return false
-		}
-
-		if !util.EqualUnsorted(v, reqv) {
-			return false
-		}
-	}
-
-	return true
-}
-
-func ValidateUpdate(_ *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, validation.WarningList) {
-	oldCR, newCR := oldObj.(*cmapi.CertificateRequest), newObj.(*cmapi.CertificateRequest)
-	fldPath := field.NewPath("spec")
-
-	var el field.ErrorList
-	if oldCR.Spec.UID != newCR.Spec.UID {
-		el = append(el, field.Forbidden(fldPath.Child("uid"), "uid identity cannot be changed once set"))
-	}
-	if oldCR.Spec.Username != newCR.Spec.Username {
-		el = append(el, field.Forbidden(fldPath.Child("username"), "username identity cannot be changed once set"))
-	}
-	if !util.EqualUnsorted(oldCR.Spec.Groups, newCR.Spec.Groups) {
-		el = append(el, field.Forbidden(fldPath.Child("groups"), "groups identity cannot be changed once set"))
-	}
-	if !reflect.DeepEqual(oldCR.Spec.Extra, newCR.Spec.Extra) {
-		el = append(el, field.Forbidden(fldPath.Child("extra"), "extra identity cannot be changed once set"))
-	}
-
-	return el, nil
-}
-
-func MutateCreate(req *admissionv1.AdmissionRequest, obj runtime.Object) {
-	cr := obj.(*cmapi.CertificateRequest)
-	userInfo := req.DeepCopy().UserInfo
-
-	cr.Spec.UID = userInfo.UID
-	cr.Spec.Username = userInfo.Username
-	cr.Spec.Groups = userInfo.Groups
-	cr.Spec.Extra = make(map[string][]string)
-	for k, v := range userInfo.Extra {
-		cr.Spec.Extra[k] = v
-	}
-}
-
-func MutateUpdate(_ *admissionv1.AdmissionRequest, _, _ runtime.Object) {
-}
diff --git a/internal/apis/certmanager/identity/certificaterequests/certificaterequests_test.go b/internal/apis/certmanager/identity/certificaterequests/certificaterequests_test.go
deleted file mode 100644
index b393ee3be..000000000
--- a/internal/apis/certmanager/identity/certificaterequests/certificaterequests_test.go
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
-Copyright 2021 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package certificaterequests
-
-import (
-	"reflect"
-	"testing"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	authenticationv1 "k8s.io/api/authentication/v1"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-)
-
-func TestValidateCreate(t *testing.T) {
-	fldPath := field.NewPath("spec")
-
-	tests := map[string]struct {
-		req   *admissionv1.AdmissionRequest
-		cr    *cmapi.CertificateRequest
-		wantE field.ErrorList
-		wantW validation.WarningList
-	}{
-		"if identity fields don't match that of requester, should fail": {
-			req: &admissionv1.AdmissionRequest{
-				UserInfo: authenticationv1.UserInfo{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string]authenticationv1.ExtraValue{
-						"1": []string{"abc", "efg"},
-						"2": []string{"efg", "abc"},
-					},
-				},
-			},
-			cr: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "efg",
-					Username: "user-2",
-					Groups:   []string{"group-3", "group-4"},
-					Extra: map[string][]string{
-						"1": {"123", "456"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-			wantE: field.ErrorList{
-				field.Forbidden(fldPath.Child("uid"), "uid identity must be that of the requester"),
-				field.Forbidden(fldPath.Child("username"), "username identity must be that of the requester"),
-				field.Forbidden(fldPath.Child("groups"), "groups identity must be that of the requester"),
-				field.Forbidden(fldPath.Child("extra"), "extra identity must be that of the requester"),
-			},
-		},
-		"if identity fields match that of requester, should pass": {
-			req: &admissionv1.AdmissionRequest{
-				UserInfo: authenticationv1.UserInfo{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string]authenticationv1.ExtraValue{
-						"1": []string{"abc", "efg"},
-						"2": []string{"efg", "abc"},
-					},
-				},
-			},
-			cr: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string][]string{
-						"1": {"abc", "efg"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-			wantE: nil,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			gotE, gotW := ValidateCreate(test.req, test.cr)
-			if !reflect.DeepEqual(gotE, test.wantE) {
-				t.Errorf("errors from ValidateCreate() = %v, want %v", gotE, test.wantE)
-			}
-			if !reflect.DeepEqual(gotW, test.wantW) {
-				t.Errorf("warnings from ValidateCreate() = %v, want %v", gotW, test.wantW)
-			}
-		})
-	}
-}
-
-func TestValidateUpdate(t *testing.T) {
-	fldPath := field.NewPath("spec")
-
-	tests := map[string]struct {
-		oldCR, newCR *cmapi.CertificateRequest
-		wantE        field.ErrorList
-		wantW        validation.WarningList
-	}{
-		"if identity fields don't match that of the old CertificateRequest, should fail": {
-			oldCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string][]string{
-						"1": {"abc", "efg"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-			newCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "efg",
-					Username: "user-2",
-					Groups:   []string{"group-3", "group-4"},
-					Extra: map[string][]string{
-						"1": {"123", "456"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-			wantE: field.ErrorList{
-				field.Forbidden(fldPath.Child("uid"), "uid identity cannot be changed once set"),
-				field.Forbidden(fldPath.Child("username"), "username identity cannot be changed once set"),
-				field.Forbidden(fldPath.Child("groups"), "groups identity cannot be changed once set"),
-				field.Forbidden(fldPath.Child("extra"), "extra identity cannot be changed once set"),
-			},
-		},
-		"if identity fields match that of requester, should pass": {
-			oldCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string][]string{
-						"1": {"abc", "efg"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-			newCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string][]string{
-						"1": {"abc", "efg"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-			wantE: nil,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			gotE, gotW := ValidateUpdate(nil, test.newCR, test.oldCR)
-			if !reflect.DeepEqual(gotE, test.wantE) {
-				t.Errorf("errors from ValidateUpdate() = %v, want %v", gotE, test.wantE)
-			}
-			if !reflect.DeepEqual(gotW, test.wantW) {
-				t.Errorf("warnings from ValidateUpdate() = %v, want %v", gotW, test.wantW)
-			}
-		})
-	}
-}
-
-func TestMutateCreate(t *testing.T) {
-	tests := map[string]struct {
-		req                    *admissionv1.AdmissionRequest
-		existingCR, expectedCR *cmapi.CertificateRequest
-	}{
-		"should set the identity of CertificateRequest to that of the requester": {
-			req: &admissionv1.AdmissionRequest{
-				UserInfo: authenticationv1.UserInfo{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string]authenticationv1.ExtraValue{
-						"1": []string{"abc", "efg"},
-						"2": []string{"efg", "abc"},
-					},
-				},
-			},
-			existingCR: new(cmapi.CertificateRequest),
-			expectedCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string][]string{
-						"1": {"abc", "efg"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-		},
-		"should overrite existing user info fields if they exist on a CREATE operation": {
-			req: &admissionv1.AdmissionRequest{
-				UserInfo: authenticationv1.UserInfo{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string]authenticationv1.ExtraValue{
-						"1": []string{"abc", "efg"},
-						"2": []string{"efg", "abc"},
-					},
-				},
-			},
-			existingCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "1234",
-					Username: "user-2",
-					Groups:   []string{"group-3", "group-4"},
-					Extra: map[string][]string{
-						"3": {"abc", "efg"},
-						"4": {"efg", "abc"},
-					},
-				},
-			},
-			expectedCR: &cmapi.CertificateRequest{
-				Spec: cmapi.CertificateRequestSpec{
-					UID:      "abc",
-					Username: "user-1",
-					Groups:   []string{"group-1", "group-2"},
-					Extra: map[string][]string{
-						"1": {"abc", "efg"},
-						"2": {"efg", "abc"},
-					},
-				},
-			},
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			cr := test.expectedCR.DeepCopy()
-			MutateCreate(test.req, cr)
-			if !reflect.DeepEqual(test.expectedCR, cr) {
-				t.Errorf("MutateCreate() = %v, want %v", cr, test.expectedCR)
-			}
-		})
-	}
-}
diff --git a/internal/apis/certmanager/identity/identity.go b/internal/apis/certmanager/identity/identity.go
deleted file mode 100644
index fd13d53de..000000000
--- a/internal/apis/certmanager/identity/identity.go
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package identity
-
-import (
-	"github.com/jetstack/cert-manager/internal/api/mutation"
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	"github.com/jetstack/cert-manager/internal/apis/certmanager/identity/certificaterequests"
-)
-
-func AddToValidationRegistry(reg *validation.Registry) error {
-	if err := reg.AddValidateFunc(&cmapi.CertificateRequest{}, certificaterequests.ValidateCreate); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&cmapi.CertificateRequest{}, certificaterequests.ValidateUpdate); err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func AddToMutationRegistry(reg *mutation.Registry) error {
-	if err := reg.AddMutateFunc(&cmapi.CertificateRequest{}, certificaterequests.MutateCreate); err != nil {
-		return err
-	}
-	if err := reg.AddMutateUpdateFunc(&cmapi.CertificateRequest{}, certificaterequests.MutateUpdate); err != nil {
-		return err
-	}
-
-	return nil
-}
diff --git a/internal/apis/certmanager/install/BUILD.bazel b/internal/apis/certmanager/install/BUILD.bazel
index 0072a8e9d..f9c83fef1 100644
--- a/internal/apis/certmanager/install/BUILD.bazel
+++ b/internal/apis/certmanager/install/BUILD.bazel
@@ -6,15 +6,11 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/internal/apis/certmanager/install",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/mutation:go_default_library",
-        "//internal/api/validation:go_default_library",
         "//internal/apis/certmanager:go_default_library",
-        "//internal/apis/certmanager/identity:go_default_library",
         "//internal/apis/certmanager/v1:go_default_library",
         "//internal/apis/certmanager/v1alpha2:go_default_library",
         "//internal/apis/certmanager/v1alpha3:go_default_library",
         "//internal/apis/certmanager/v1beta1:go_default_library",
-        "//internal/apis/certmanager/validation:go_default_library",
         "//internal/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/util/runtime:go_default_library",
diff --git a/internal/apis/certmanager/install/install.go b/internal/apis/certmanager/install/install.go
index af02001ba..0a05b3cfd 100644
--- a/internal/apis/certmanager/install/install.go
+++ b/internal/apis/certmanager/install/install.go
@@ -22,15 +22,11 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
 
-	"github.com/jetstack/cert-manager/internal/api/mutation"
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	"github.com/jetstack/cert-manager/internal/apis/certmanager"
-	cmidentity "github.com/jetstack/cert-manager/internal/apis/certmanager/identity"
 	v1 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1"
 	"github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha2"
 	"github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha3"
 	"github.com/jetstack/cert-manager/internal/apis/certmanager/v1beta1"
-	cmvalidation "github.com/jetstack/cert-manager/internal/apis/certmanager/validation"
 	cmmetav1 "github.com/jetstack/cert-manager/internal/apis/meta/v1"
 )
 
@@ -45,16 +41,3 @@ func Install(scheme *runtime.Scheme) {
 
 	utilruntime.Must(cmmetav1.AddToScheme(scheme))
 }
-
-// InstallValidation registers validation functions for the API group with a
-// validation registry
-func InstallValidation(registry *validation.Registry) {
-	utilruntime.Must(cmvalidation.AddToValidationRegistry(registry))
-	utilruntime.Must(cmidentity.AddToValidationRegistry(registry))
-}
-
-// InstallMutation registers mutation functions for the API group with a
-// mutation registry
-func InstallMutation(registry *mutation.Registry) {
-	utilruntime.Must(cmidentity.AddToMutationRegistry(registry))
-}
diff --git a/internal/apis/certmanager/validation/BUILD.bazel b/internal/apis/certmanager/validation/BUILD.bazel
index abf9b4093..df5458396 100644
--- a/internal/apis/certmanager/validation/BUILD.bazel
+++ b/internal/apis/certmanager/validation/BUILD.bazel
@@ -7,20 +7,14 @@ go_library(
         "certificate_for_issuer.go",
         "certificaterequest.go",
         "clusterissuer.go",
-        "deprecation.go",
         "issuer.go",
-        "register.go",
         "warnings.go",
     ],
     importpath = "github.com/jetstack/cert-manager/internal/apis/certmanager/validation",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//internal/apis/acme:go_default_library",
         "//internal/apis/certmanager:go_default_library",
-        "//internal/apis/certmanager/v1alpha2:go_default_library",
-        "//internal/apis/certmanager/v1alpha3:go_default_library",
-        "//internal/apis/certmanager/v1beta1:go_default_library",
         "//internal/apis/certmanager/validation/util:go_default_library",
         "//internal/apis/meta:go_default_library",
         "//internal/controller/feature:go_default_library",
@@ -35,10 +29,8 @@ go_library(
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_api//core/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/api/validation:go_default_library",
-        "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1/validation:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
     ],
 )
@@ -54,12 +46,8 @@ go_test(
     ],
     embed = [":go_default_library"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//internal/apis/acme:go_default_library",
         "//internal/apis/certmanager:go_default_library",
-        "//internal/apis/certmanager/v1alpha2:go_default_library",
-        "//internal/apis/certmanager/v1alpha3:go_default_library",
-        "//internal/apis/certmanager/v1beta1:go_default_library",
         "//internal/apis/meta:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
         "//pkg/util/pki:go_default_library",
@@ -83,7 +71,6 @@ filegroup(
     name = "all-srcs",
     srcs = [
         ":package-srcs",
-        "//internal/apis/certmanager/validation/plugins:all-srcs",
         "//internal/apis/certmanager/validation/util:all-srcs",
     ],
     tags = ["automanaged"],
diff --git a/internal/apis/certmanager/validation/certificate.go b/internal/apis/certmanager/validation/certificate.go
index c6c46c68f..5956af468 100644
--- a/internal/apis/certmanager/validation/certificate.go
+++ b/internal/apis/certmanager/validation/certificate.go
@@ -28,7 +28,6 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	internalcmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
 	cmmeta "github.com/jetstack/cert-manager/internal/apis/meta"
 	"github.com/jetstack/cert-manager/internal/controller/feature"
@@ -116,18 +115,16 @@ func ValidateCertificateSpec(crt *internalcmapi.CertificateSpec, fldPath *field.
 	return el
 }
 
-func ValidateCertificate(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateCertificate(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
 	crt := obj.(*internalcmapi.Certificate)
 	allErrs := ValidateCertificateSpec(&crt.Spec, field.NewPath("spec"))
-	w := validateAPIVersion(a.RequestKind)
-	return allErrs, w
+	return allErrs, nil
 }
 
-func ValidateUpdateCertificate(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateUpdateCertificate(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, []string) {
 	crt := obj.(*internalcmapi.Certificate)
 	allErrs := ValidateCertificateSpec(&crt.Spec, field.NewPath("spec"))
-	w := validateAPIVersion(a.RequestKind)
-	return allErrs, w
+	return allErrs, nil
 }
 
 func validateIssuerRef(issuerRef cmmeta.ObjectReference, fldPath *field.Path) field.ErrorList {
diff --git a/internal/apis/certmanager/validation/certificate_test.go b/internal/apis/certmanager/validation/certificate_test.go
index f99b330df..2d83e53fd 100644
--- a/internal/apis/certmanager/validation/certificate_test.go
+++ b/internal/apis/certmanager/validation/certificate_test.go
@@ -26,11 +26,7 @@ import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	internalcmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	cmapiv1alpha2 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha2"
-	cmapiv1alpha3 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha3"
-	cmapiv1beta1 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1beta1"
 	cmmeta "github.com/jetstack/cert-manager/internal/apis/meta"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	"github.com/stretchr/testify/assert"
@@ -65,7 +61,7 @@ func TestValidateCertificate(t *testing.T) {
 		cfg      *internalcmapi.Certificate
 		a        *admissionv1.AdmissionRequest
 		errs     []*field.Error
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"valid basic certificate": {
 			cfg: &internalcmapi.Certificate{
@@ -565,69 +561,6 @@ func TestValidateCertificate(t *testing.T) {
 				field.Invalid(fldPath.Child("revisionHistoryLimit"), int32(0), "must not be less than 1"),
 			},
 		},
-		"v1alpha2 certificate created": {
-			cfg: &internalcmapi.Certificate{
-				Spec: internalcmapi.CertificateSpec{
-					CommonName: "abc",
-					SecretName: "abc",
-					IssuerRef:  validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Certificate"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"Certificate",
-					cmapi.SchemeGroupVersion.String(),
-					"Certificate"),
-			},
-		},
-		"v1alpha3 certificate created": {
-			cfg: &internalcmapi.Certificate{
-				Spec: internalcmapi.CertificateSpec{
-					CommonName: "abc",
-					SecretName: "abc",
-					IssuerRef:  validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Certificate"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"Certificate",
-					cmapi.SchemeGroupVersion.String(),
-					"Certificate"),
-			},
-		},
-		"v1beta1 certificate created": {
-			cfg: &internalcmapi.Certificate{
-				Spec: internalcmapi.CertificateSpec{
-					CommonName: "abc",
-					SecretName: "abc",
-					IssuerRef:  validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Certificate"},
-			},
-			warnings: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"Certificate",
-					cmapi.SchemeGroupVersion.String(),
-					"Certificate"),
-			},
-		},
 		"valid with empty secretTemplate": {
 			cfg: &internalcmapi.Certificate{
 				Spec: internalcmapi.CertificateSpec{
diff --git a/internal/apis/certmanager/validation/certificaterequest.go b/internal/apis/certmanager/validation/certificaterequest.go
index 2ed5df670..64eabdb52 100644
--- a/internal/apis/certmanager/validation/certificaterequest.go
+++ b/internal/apis/certmanager/validation/certificaterequest.go
@@ -28,7 +28,6 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
 	cmmeta "github.com/jetstack/cert-manager/internal/apis/meta"
 	"github.com/jetstack/cert-manager/pkg/apis/acme"
@@ -39,18 +38,16 @@ import (
 
 var defaultInternalKeyUsages = []cmapi.KeyUsage{cmapi.UsageDigitalSignature, cmapi.UsageKeyEncipherment}
 
-func ValidateCertificateRequest(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateCertificateRequest(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
 	cr := obj.(*cmapi.CertificateRequest)
 	allErrs := ValidateCertificateRequestSpec(&cr.Spec, field.NewPath("spec"), true)
 	allErrs = append(allErrs,
 		ValidateCertificateRequestApprovalCondition(cr.Status.Conditions, field.NewPath("status", "conditions"))...)
 
-	w := validateAPIVersion(a.RequestKind)
-
-	return allErrs, w
+	return allErrs, nil
 }
 
-func ValidateUpdateCertificateRequest(a *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateUpdateCertificateRequest(a *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, []string) {
 	oldCR, newCR := oldObj.(*cmapi.CertificateRequest), newObj.(*cmapi.CertificateRequest)
 
 	var el field.ErrorList
@@ -68,9 +65,8 @@ func ValidateUpdateCertificateRequest(a *admissionv1.AdmissionRequest, oldObj, n
 	if !reflect.DeepEqual(oldCR.Spec, newCR.Spec) {
 		el = append(el, field.Forbidden(field.NewPath("spec"), "cannot change spec after creation"))
 	}
-	w := validateAPIVersion(a.RequestKind)
 
-	return el, w
+	return el, nil
 }
 
 func validateCertificateRequestAnnotations(objA, objB *cmapi.CertificateRequest, fieldPath *field.Path) field.ErrorList {
diff --git a/internal/apis/certmanager/validation/certificaterequest_test.go b/internal/apis/certmanager/validation/certificaterequest_test.go
index f3222b114..27dc5561d 100644
--- a/internal/apis/certmanager/validation/certificaterequest_test.go
+++ b/internal/apis/certmanager/validation/certificaterequest_test.go
@@ -19,7 +19,6 @@ package validation
 import (
 	"bytes"
 	"encoding/pem"
-	"fmt"
 	"reflect"
 	"testing"
 
@@ -27,11 +26,7 @@ import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cminternal "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	cmapiv1alpha2 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha2"
-	cmapiv1alpha3 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha3"
-	cmapiv1beta1 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1beta1"
 	cminternalmeta "github.com/jetstack/cert-manager/internal/apis/meta"
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	utilpki "github.com/jetstack/cert-manager/pkg/util/pki"
@@ -76,7 +71,7 @@ func TestValidateCertificateRequestUpdate(t *testing.T) {
 		oldCR, newCR *cminternal.CertificateRequest
 		a            *admissionv1.AdmissionRequest
 		wantE        field.ErrorList
-		wantW        validation.WarningList
+		wantW        []string
 	}{
 		"if CertificateRequest spec and cert-manager.io annotations change, error": {
 			oldCR: baseCR.DeepCopy(),
@@ -445,84 +440,6 @@ func TestValidateCertificateRequestUpdate(t *testing.T) {
 				field.Forbidden(fldPathConditions, "'Denied' condition may not be modified once set"),
 			},
 		},
-		"CertificateRequest  against v1alpha2 API should throw a warning": {
-			oldCR: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   baseRequest,
-					IssuerRef: validIssuerRef,
-				},
-			},
-			newCR: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   baseRequest,
-					IssuerRef: validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "CertificateRequest"},
-			},
-			wantW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"CertificateRequest",
-					cmapi.SchemeGroupVersion.String(),
-					"CertificateRequest"),
-			},
-		},
-		"CertificateRequest  against v1alpha3 API should throw a warning": {
-			oldCR: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   baseRequest,
-					IssuerRef: validIssuerRef,
-				},
-			},
-			newCR: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   baseRequest,
-					IssuerRef: validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "CertificateRequest"},
-			},
-			wantW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"CertificateRequest",
-					cmapi.SchemeGroupVersion.String(),
-					"CertificateRequest"),
-			},
-		},
-		"CertificateRequest  against v1beta1 API should throw a warning": {
-			oldCR: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   baseRequest,
-					IssuerRef: validIssuerRef,
-				},
-			},
-			newCR: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   baseRequest,
-					IssuerRef: validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "CertificateRequest"},
-			},
-			wantW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"CertificateRequest",
-					cmapi.SchemeGroupVersion.String(),
-					"CertificateRequest"),
-			},
-		},
 	}
 
 	for name, test := range tests {
@@ -553,7 +470,7 @@ func TestValidateCertificateRequest(t *testing.T) {
 		cr    *cminternal.CertificateRequest
 		a     *admissionv1.AdmissionRequest
 		wantE field.ErrorList
-		wantW validation.WarningList
+		wantW []string
 	}{
 		"Test csr with no usages": {
 			cr: &cminternal.CertificateRequest{
@@ -865,75 +782,6 @@ func TestValidateCertificateRequest(t *testing.T) {
 				field.Forbidden(fldPathConditions, `multiple "Denied" conditions present`),
 			},
 		},
-		"CertificateRequest  against v1alpha2 API should throw a warning": {
-			cr: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   mustGenerateCSR(t, gen.Certificate("spec", gen.SetCertificateDNSNames("example.com"), gen.SetCertificateKeyUsages(cmapi.UsageAny), gen.SetCertificateIsCA(true))),
-					IssuerRef: validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "CertificateRequest"},
-			},
-			wantW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"CertificateRequest",
-					cmapi.SchemeGroupVersion.String(),
-					"CertificateRequest"),
-			},
-			wantE: field.ErrorList{},
-		},
-		"CertificateRequest  against v1alpha3 API should throw a warning": {
-			cr: &cminternal.CertificateRequest{
-				TypeMeta: metav1.TypeMeta{
-					APIVersion: cmapiv1alpha3.SchemeGroupVersion.String(),
-					Kind:       "CertificateRequest",
-				},
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   mustGenerateCSR(t, gen.Certificate("spec", gen.SetCertificateDNSNames("example.com"), gen.SetCertificateKeyUsages(cmapi.UsageAny), gen.SetCertificateIsCA(true))),
-					IssuerRef: validIssuerRef,
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "CertificateRequest"},
-			},
-			wantW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"CertificateRequest",
-					cmapi.SchemeGroupVersion.String(),
-					"CertificateRequest"),
-			},
-			wantE: field.ErrorList{},
-		},
-		"CertificateRequest  against v1beta1 API should throw a warning": {
-			cr: &cminternal.CertificateRequest{
-				Spec: cminternal.CertificateRequestSpec{
-					Request:   mustGenerateCSR(t, gen.Certificate("spec", gen.SetCertificateDNSNames("example.com"), gen.SetCertificateKeyUsages(cmapi.UsageAny), gen.SetCertificateIsCA(true))),
-					IssuerRef: validIssuerRef,
-					IsCA:      true,
-					Usages:    []cminternal.KeyUsage{cminternal.UsageAny},
-				},
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "CertificateRequest"},
-			},
-			wantW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"CertificateRequest",
-					cmapi.SchemeGroupVersion.String(),
-					"CertificateRequest"),
-			},
-			wantE: field.ErrorList{},
-		},
 	}
 	for name, test := range tests {
 		t.Run(name, func(t *testing.T) {
diff --git a/internal/apis/certmanager/validation/clusterissuer.go b/internal/apis/certmanager/validation/clusterissuer.go
index 802490489..9f84c0da3 100644
--- a/internal/apis/certmanager/validation/clusterissuer.go
+++ b/internal/apis/certmanager/validation/clusterissuer.go
@@ -21,22 +21,19 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
 )
 
 // Validation functions for cert-manager ClusterIssuer types.
 
-func ValidateClusterIssuer(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateClusterIssuer(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
 	iss := obj.(*cmapi.ClusterIssuer)
 	allErrs, warnings := ValidateIssuerSpec(&iss.Spec, field.NewPath("spec"))
-	warnings = append(warnings, validateAPIVersion(a.RequestKind)...)
 	return allErrs, warnings
 }
 
-func ValidateUpdateClusterIssuer(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateUpdateClusterIssuer(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, []string) {
 	iss := obj.(*cmapi.ClusterIssuer)
 	allErrs, warnings := ValidateIssuerSpec(&iss.Spec, field.NewPath("spec"))
-	warnings = append(warnings, validateAPIVersion(a.RequestKind)...)
 	return allErrs, warnings
 }
diff --git a/internal/apis/certmanager/validation/clusterissuer_test.go b/internal/apis/certmanager/validation/clusterissuer_test.go
index 977dce192..21a194406 100644
--- a/internal/apis/certmanager/validation/clusterissuer_test.go
+++ b/internal/apis/certmanager/validation/clusterissuer_test.go
@@ -17,88 +17,22 @@ limitations under the License.
 package validation
 
 import (
-	"fmt"
 	"reflect"
 	"testing"
 
 	admissionv1 "k8s.io/api/admission/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	cmapiv1alpha2 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha2"
-	cmapiv1alpha3 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha3"
-	cmapiv1beta1 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1beta1"
-	cmapiv1 "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 )
 
 func TestValidateClusterIssuer(t *testing.T) {
-	baseIssuerConfig := cmapi.IssuerSpec{
-		IssuerConfig: cmapi.IssuerConfig{
-			SelfSigned: &cmapi.SelfSignedIssuer{},
-		}}
 	scenarios := map[string]struct {
 		cfg       *cmapi.ClusterIssuer
 		a         *admissionv1.AdmissionRequest
 		expectedE []*field.Error
-		expectedW validation.WarningList
-	}{
-		"v1alpha2 ClusterIssuer created": {
-			cfg: &cmapi.ClusterIssuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "ClusterIssuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"ClusterIssuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"ClusterIssuer"),
-			},
-		},
-		"v1alpha3 ClusterIssuer created": {
-			cfg: &cmapi.ClusterIssuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "ClusterIssuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"ClusterIssuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"ClusterIssuer"),
-			},
-		},
-		"v1beta1 ClusterIssuer created": {
-			cfg: &cmapi.ClusterIssuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "ClusterIssuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"ClusterIssuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"ClusterIssuer"),
-			},
-		},
-	}
+		expectedW []string
+	}{}
 
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
@@ -137,63 +71,8 @@ func TestUpdateValidateClusterIssuer(t *testing.T) {
 		iss       *cmapi.ClusterIssuer
 		a         *admissionv1.AdmissionRequest
 		expectedE []*field.Error
-		expectedW validation.WarningList
-	}{
-		"ClusterIssuer updated to v1alpha2 version": {
-			iss: &cmapi.ClusterIssuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "ClusterIssuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"ClusterIssuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"ClusterIssuer"),
-			},
-		},
-		"ClusterIssuer updated to v1alpha3 version": {
-			iss: &cmapi.ClusterIssuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "ClusterIssuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"ClusterIssuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"ClusterIssuer"),
-			},
-		},
-		"ClusterIssuer updated to v1beta1 version": {
-			iss: &cmapi.ClusterIssuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "ClusterIssuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"ClusterIssuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"ClusterIssuer"),
-			},
-		},
-	}
+		expectedW []string
+	}{}
 
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
diff --git a/internal/apis/certmanager/validation/deprecation.go b/internal/apis/certmanager/validation/deprecation.go
deleted file mode 100644
index 54a883034..000000000
--- a/internal/apis/certmanager/validation/deprecation.go
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation
-
-import (
-	"fmt"
-
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmapiv1alpha2 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha2"
-	cmapiv1alpha3 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha3"
-	cmapiv1beta1 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1beta1"
-	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
-)
-
-// This file holds temporary functionality for cert-manager v1.4 API deprecation.
-// It will be removed in cert-manager v1.6, when we remove the deprecated APIs.
-var (
-	deprecatedAPIs = map[string]schema.GroupVersion{
-		cmapiv1alpha2.SchemeGroupVersion.String(): cmapi.SchemeGroupVersion,
-		cmapiv1alpha3.SchemeGroupVersion.String(): cmapi.SchemeGroupVersion,
-		cmapiv1beta1.SchemeGroupVersion.String():  cmapi.SchemeGroupVersion,
-	}
-
-	deprecationMessageTemplate = "%s %s is deprecated in v1.4+, unavailable in v1.6+; use %v %s"
-)
-
-func validateAPIVersion(gvk *v1.GroupVersionKind) validation.WarningList {
-	// There might be a smarter way to get GroupVersion
-	gv := fmt.Sprintf("%s/%s", gvk.Group, gvk.Version)
-	kind := gvk.Kind
-	if newV, ok := deprecatedAPIs[gv]; ok {
-		w := fmt.Sprintf(deprecationMessageTemplate, gv, kind, newV, kind)
-		return validation.WarningList{w}
-	}
-	return nil
-}
diff --git a/internal/apis/certmanager/validation/issuer.go b/internal/apis/certmanager/validation/issuer.go
index 9cf0ed6fc..4121449c6 100644
--- a/internal/apis/certmanager/validation/issuer.go
+++ b/internal/apis/certmanager/validation/issuer.go
@@ -26,7 +26,6 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
 	"github.com/jetstack/cert-manager/internal/apis/certmanager"
 	"github.com/jetstack/cert-manager/internal/apis/certmanager/validation/util"
@@ -35,27 +34,25 @@ import (
 
 // Validation functions for cert-manager Issuer types.
 
-func ValidateIssuer(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateIssuer(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
 	iss := obj.(*certmanager.Issuer)
 	allErrs, warnings := ValidateIssuerSpec(&iss.Spec, field.NewPath("spec"))
-	warnings = append(warnings, validateAPIVersion(a.RequestKind)...)
 	return allErrs, warnings
 }
 
-func ValidateUpdateIssuer(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateUpdateIssuer(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, []string) {
 	iss := obj.(*certmanager.Issuer)
 	allErrs, warnings := ValidateIssuerSpec(&iss.Spec, field.NewPath("spec"))
 	// Admission request should never be nil
-	warnings = append(warnings, validateAPIVersion(a.RequestKind)...)
 	return allErrs, warnings
 }
 
-func ValidateIssuerSpec(iss *certmanager.IssuerSpec, fldPath *field.Path) (field.ErrorList, validation.WarningList) {
+func ValidateIssuerSpec(iss *certmanager.IssuerSpec, fldPath *field.Path) (field.ErrorList, []string) {
 	return ValidateIssuerConfig(&iss.IssuerConfig, fldPath)
 }
 
-func ValidateIssuerConfig(iss *certmanager.IssuerConfig, fldPath *field.Path) (field.ErrorList, validation.WarningList) {
-	var warnings validation.WarningList
+func ValidateIssuerConfig(iss *certmanager.IssuerConfig, fldPath *field.Path) (field.ErrorList, []string) {
+	var warnings []string
 	numConfigs := 0
 	el := field.ErrorList{}
 	if iss.ACME != nil {
@@ -106,8 +103,8 @@ func ValidateIssuerConfig(iss *certmanager.IssuerConfig, fldPath *field.Path) (f
 	return el, warnings
 }
 
-func ValidateACMEIssuerConfig(iss *cmacme.ACMEIssuer, fldPath *field.Path) (field.ErrorList, validation.WarningList) {
-	var warnings validation.WarningList
+func ValidateACMEIssuerConfig(iss *cmacme.ACMEIssuer, fldPath *field.Path) (field.ErrorList, []string) {
+	var warnings []string
 	el := field.ErrorList{}
 	if len(iss.PrivateKey.Name) == 0 {
 		el = append(el, field.Required(fldPath.Child("privateKeySecretRef", "name"), "private key secret name is a required field"))
diff --git a/internal/apis/certmanager/validation/issuer_test.go b/internal/apis/certmanager/validation/issuer_test.go
index 52058942f..d5b4a154e 100644
--- a/internal/apis/certmanager/validation/issuer_test.go
+++ b/internal/apis/certmanager/validation/issuer_test.go
@@ -17,25 +17,17 @@ limitations under the License.
 package validation
 
 import (
-	"fmt"
 	"reflect"
 	"testing"
 
 	"github.com/stretchr/testify/assert"
-
 	admissionv1 "k8s.io/api/admission/v1"
 	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	cmacme "github.com/jetstack/cert-manager/internal/apis/acme"
 	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	cmapiv1alpha2 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha2"
-	cmapiv1alpha3 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1alpha3"
-	cmapiv1beta1 "github.com/jetstack/cert-manager/internal/apis/certmanager/v1beta1"
 	cmmeta "github.com/jetstack/cert-manager/internal/apis/meta"
-	cmapiv1 "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 )
 
 var (
@@ -117,7 +109,7 @@ func TestValidateACMEIssuerConfig(t *testing.T) {
 	scenarios := map[string]struct {
 		spec     *cmacme.ACMEIssuer
 		errs     []*field.Error
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"valid acme issuer": {
 			spec: &validACMEIssuer,
@@ -212,7 +204,7 @@ func TestValidateACMEIssuerConfig(t *testing.T) {
 					},
 				},
 			},
-			warnings: validation.WarningList{deprecatedACMEEABKeyAlgorithmField},
+			warnings: []string{deprecatedACMEEABKeyAlgorithmField},
 		},
 		"acme solver with missing http01 config type": {
 			spec: &cmacme.ACMEIssuer{
@@ -411,7 +403,7 @@ func TestValidateIssuerSpec(t *testing.T) {
 	scenarios := map[string]struct {
 		spec     *cmapi.IssuerSpec
 		errs     field.ErrorList
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"valid ca issuer": {
 			spec: &cmapi.IssuerSpec{
@@ -1303,71 +1295,12 @@ func TestValidateVenafiTPP(t *testing.T) {
 }
 
 func TestValidateIssuer(t *testing.T) {
-	baseIssuerConfig := cmapi.IssuerSpec{
-		IssuerConfig: cmapi.IssuerConfig{
-			SelfSigned: &cmapi.SelfSignedIssuer{},
-		}}
 	scenarios := map[string]struct {
 		cfg       *cmapi.Issuer
 		a         *admissionv1.AdmissionRequest
 		expectedE []*field.Error
-		expectedW validation.WarningList
-	}{
-		"v1alpha2 Issuer created": {
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Issuer"},
-			},
-			cfg: &cmapi.Issuer{
-				Spec: baseIssuerConfig,
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"Issuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"Issuer"),
-			},
-		},
-		"v1alpha3 Issuer created": {
-			cfg: &cmapi.Issuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Issuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"Issuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"Issuer"),
-			},
-		},
-		"v1beta1 Issuer created": {
-			cfg: &cmapi.Issuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Issuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"Issuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"Issuer"),
-			},
-		},
-	}
+		expectedW []string
+	}{}
 
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
@@ -1406,63 +1339,8 @@ func TestUpdateValidateIssuer(t *testing.T) {
 		iss       *cmapi.Issuer
 		a         *admissionv1.AdmissionRequest
 		expectedE []*field.Error
-		expectedW validation.WarningList
-	}{
-		"Issuer updated to v1alpha2 version": {
-			iss: &cmapi.Issuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha2",
-					Kind:    "Issuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha2.SchemeGroupVersion.String(),
-					"Issuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"Issuer"),
-			},
-		},
-		"Issuer updated to v1alpha3 version": {
-			iss: &cmapi.Issuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1alpha3",
-					Kind:    "Issuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1alpha3.SchemeGroupVersion.String(),
-					"Issuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"Issuer"),
-			},
-		},
-		"Issuer updated to v1beta1 version": {
-			iss: &cmapi.Issuer{
-				Spec: baseIssuerConfig,
-			},
-			a: &admissionv1.AdmissionRequest{
-				RequestKind: &metav1.GroupVersionKind{Group: "cert-manager.io",
-					Version: "v1beta1",
-					Kind:    "Issuer"},
-			},
-			expectedE: []*field.Error{},
-			expectedW: validation.WarningList{
-				fmt.Sprintf(deprecationMessageTemplate,
-					cmapiv1beta1.SchemeGroupVersion.String(),
-					"Issuer",
-					cmapiv1.SchemeGroupVersion.String(),
-					"Issuer"),
-			},
-		},
-	}
+		expectedW []string
+	}{}
 
 	for n, s := range scenarios {
 		t.Run(n, func(t *testing.T) {
diff --git a/internal/apis/certmanager/validation/plugins/approval.go b/internal/apis/certmanager/validation/plugins/approval.go
deleted file mode 100644
index 322b7e89d..000000000
--- a/internal/apis/certmanager/validation/plugins/approval.go
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
-Copyright 2021 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package plugins
-
-import (
-	"context"
-	"errors"
-	"fmt"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	authzv1 "k8s.io/api/authorization/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-	"k8s.io/client-go/discovery"
-	"k8s.io/client-go/kubernetes"
-	authzclient "k8s.io/client-go/kubernetes/typed/authorization/v1"
-
-	internalcmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	"github.com/jetstack/cert-manager/internal/apis/certmanager/validation/util"
-	"github.com/jetstack/cert-manager/pkg/apis/certmanager"
-	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
-)
-
-// approval is responsible for reviewing whether users attempting to approve or
-// deny a CertificateRequest have sufficient permissions to do so.
-type approval struct {
-	scheme *runtime.Scheme
-
-	sarclient      authzclient.SubjectAccessReviewInterface
-	discoverclient discovery.DiscoveryInterface
-}
-
-type signerResource struct {
-	// signer resource name
-	name       string
-	group      string
-	namespaced bool
-
-	// name of the object for this signer
-	signerName       string
-	requestNamespace string
-}
-
-func newApproval(scheme *runtime.Scheme) *approval {
-	return &approval{
-		scheme: scheme,
-	}
-}
-
-func (a *approval) Init(client kubernetes.Interface) {
-	a.sarclient = client.AuthorizationV1().SubjectAccessReviews()
-	a.discoverclient = client.Discovery()
-}
-
-// Validate will review whether the client is able to approve or deny the given
-// request, if indeed they are attempting to. A SubjectAccessReview will be
-// performed if the client is attempting to approve/deny the request. An error
-// will be returned if the SubjectAccessReview fails, or if they do not have
-// permissions to perform the approval/denial. The request will also fail if
-// the referenced signer doesn't exist in this cluster.
-func (a *approval) Validate(ctx context.Context, req *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) *field.Error {
-	// Only perform validation on UPDATE operations
-	if req.Operation != admissionv1.Update {
-		return nil
-	}
-
-	// Only Validate over CertificateRequest resources
-	if req.RequestKind.Group != certmanager.GroupName || req.RequestKind.Kind != cmapi.CertificateRequestKind {
-		return nil
-	}
-
-	// Error if the clients are not initialised
-	if a.sarclient == nil || a.discoverclient == nil {
-		return internalError(errors.New("approval validation not initialised"))
-	}
-
-	gvk := schema.GroupVersionKind{
-		Group:   req.RequestKind.Group,
-		Version: runtime.APIVersionInternal,
-		Kind:    req.RequestKind.Kind,
-	}
-
-	// Convert the incomming old and new CertificateRequest into the internal
-	// version. This is so we can process a single type, reglardless of whatever
-	// CertificateRequest version is in the request.
-	for _, obj := range []runtime.Object{oldObj, obj} {
-		internalObj, err := a.scheme.New(gvk)
-		if err != nil {
-			return internalError(err)
-		}
-
-		if err := a.scheme.Convert(obj, internalObj, nil); err != nil {
-			return internalError(err)
-		}
-	}
-
-	oldCR := oldObj.(*internalcmapi.CertificateRequest)
-	newCR := obj.(*internalcmapi.CertificateRequest)
-
-	// If the request is not for approval, exit early
-	if !isApprovalRequest(oldCR, newCR) {
-		return nil
-	}
-
-	// Get the referenced signer signer definition
-	signer, ok, err := a.signerResource(newCR)
-	if err != nil {
-		return internalError(err)
-	}
-	if !ok {
-		return field.Forbidden(field.NewPath("spec.issuerRef"),
-			fmt.Sprintf("referenced signer resource does not exist: %v", newCR.Spec.IssuerRef))
-	}
-
-	// Construct the signer resource names that permissions should be granted
-	// for
-	names := a.signerResourceNames(signer)
-
-	// Review whether the approving user has the correct permissions for the
-	// given signer names
-	ok, err = a.reviewRequest(ctx, req, names)
-	if err != nil {
-		return internalError(err)
-	}
-
-	if !ok {
-		return field.Forbidden(field.NewPath("status.conditions"),
-			fmt.Sprintf("user %q does not have permissions to set approved/denied conditions for issuer %v", req.UserInfo.Username, newCR.Spec.IssuerRef))
-	}
-
-	return nil
-}
-
-// reviewRequest will perform a SubjectAccessReview with the UserInfo fields of
-// the client against the issuer of the CertificateRequest. A client must have
-// the "approve" verb, for the resource "signer", at the Cluster scope, for the
-// name "<signer-kind>.<signer-group>/[<signer-namespace.]<signer-name>", or
-// "<signer-kind>.<signer-group>/*".
-func (a *approval) reviewRequest(ctx context.Context, req *admissionv1.AdmissionRequest, names []string) (bool, error) {
-	extra := make(map[string]authzv1.ExtraValue)
-	for k, v := range req.UserInfo.Extra {
-		extra[k] = authzv1.ExtraValue(v)
-	}
-
-	for _, name := range names {
-		resp, err := a.sarclient.Create(ctx, &authzv1.SubjectAccessReview{
-			Spec: authzv1.SubjectAccessReviewSpec{
-				User:   req.UserInfo.Username,
-				Groups: req.UserInfo.Groups,
-				Extra:  extra,
-				UID:    req.UserInfo.UID,
-
-				ResourceAttributes: &authzv1.ResourceAttributes{
-					Group:    certmanager.GroupName,
-					Resource: "signers",
-					Name:     name,
-					Verb:     "approve",
-					Version:  "*",
-				},
-			},
-		}, metav1.CreateOptions{})
-		if err != nil {
-			return false, err
-		}
-
-		if resp.Status.Allowed {
-			return true, nil
-		}
-	}
-
-	return false, nil
-}
-
-// isApprovalRequest will return true if the request is given a new approved or
-// denied condition. This check is strictly concerned with these conditions
-// being _added_. We do this to reduce the number of SAR calls made, since
-// removal or changing of these conditions will be rejected elsewhere in the
-// validation chain locally.
-func isApprovalRequest(oldCR, newCR *internalcmapi.CertificateRequest) bool {
-	oldCRApproving := util.GetCertificateRequestCondition(oldCR.Status.Conditions, internalcmapi.CertificateRequestConditionApproved)
-	newCRApproving := util.GetCertificateRequestCondition(newCR.Status.Conditions, internalcmapi.CertificateRequestConditionApproved)
-
-	if oldCRApproving == nil && newCRApproving != nil {
-		return true
-	}
-
-	oldCRDenying := util.GetCertificateRequestCondition(oldCR.Status.Conditions, internalcmapi.CertificateRequestConditionDenied)
-	newCRDenying := util.GetCertificateRequestCondition(newCR.Status.Conditions, internalcmapi.CertificateRequestConditionDenied)
-
-	if oldCRDenying == nil && newCRDenying != nil {
-		return true
-	}
-
-	return false
-}
-
-// signerResourceNames returns a slice of the signer resource names that this
-// signer can be represented as, given the request.
-func (a *approval) signerResourceNames(signer *signerResource) []string {
-	wildcard := fmt.Sprintf("%s.%s/*", signer.name, signer.group)
-
-	named := fmt.Sprintf("%s.%s", signer.name, signer.group)
-	if signer.namespaced {
-		named = fmt.Sprintf("%s/%s.%s", named, signer.requestNamespace, signer.signerName)
-	} else {
-		named = fmt.Sprintf("%s/%s", named, signer.signerName)
-	}
-
-	return []string{wildcard, named}
-}
-
-// signerResource returns information about the singer resource in the cluster,
-// using the discovery client. Returns false if the signer is not installed in
-// the cluster.
-func (a *approval) signerResource(cr *internalcmapi.CertificateRequest) (*signerResource, bool, error) {
-	group := cr.Spec.IssuerRef.Group
-	if len(group) == 0 {
-		group = certmanager.GroupName
-	}
-
-	kind := cr.Spec.IssuerRef.Kind
-	if len(kind) == 0 {
-		kind = cmapi.IssuerKind
-	}
-
-	// Test for internal signer types and return accordingly
-	if group == certmanager.GroupName {
-		switch kind {
-		case cmapi.IssuerKind:
-			return &signerResource{
-				name:             "issuers",
-				group:            group,
-				namespaced:       true,
-				signerName:       cr.Spec.IssuerRef.Name,
-				requestNamespace: cr.Namespace,
-			}, true, nil
-
-		case cmapi.ClusterIssuerKind:
-			return &signerResource{
-				name:             "clusterissuers",
-				group:            group,
-				namespaced:       false,
-				signerName:       cr.Spec.IssuerRef.Name,
-				requestNamespace: cr.Namespace,
-			}, true, nil
-		}
-	}
-
-	grouplist, err := a.discoverclient.ServerGroups()
-	if err != nil {
-		return nil, false, err
-	}
-
-	for _, resourceGroup := range grouplist.Groups {
-		if group != resourceGroup.Name {
-			continue
-		}
-
-		for _, version := range resourceGroup.Versions {
-			resources, err := a.discoverclient.ServerResourcesForGroupVersion(version.GroupVersion)
-			if err != nil {
-				return nil, false, err
-			}
-
-			for _, resource := range resources.APIResources {
-				if resource.Kind == kind {
-					return &signerResource{
-						name:             resource.Name,
-						group:            group,
-						namespaced:       resource.Namespaced,
-						requestNamespace: cr.Namespace,
-						signerName:       cr.Spec.IssuerRef.Name,
-					}, true, nil
-				}
-			}
-		}
-	}
-
-	return nil, false, nil
-}
-
-func internalError(err error) *field.Error {
-	return field.InternalError(field.NewPath("status.conditions"), err)
-}
diff --git a/internal/apis/certmanager/validation/plugins/approval_test.go b/internal/apis/certmanager/validation/plugins/approval_test.go
deleted file mode 100644
index 49445feb8..000000000
--- a/internal/apis/certmanager/validation/plugins/approval_test.go
+++ /dev/null
@@ -1,993 +0,0 @@
-/*
-Copyright 2021 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package plugins
-
-import (
-	"context"
-	"errors"
-	"reflect"
-	"testing"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	authnv1 "k8s.io/api/authentication/v1"
-	authzv1 "k8s.io/api/authorization/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-	"k8s.io/client-go/discovery"
-	kubefake "k8s.io/client-go/kubernetes/fake"
-	coretesting "k8s.io/client-go/testing"
-
-	internalcmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-	internalcmmeta "github.com/jetstack/cert-manager/internal/apis/meta"
-	"github.com/jetstack/cert-manager/pkg/webhook"
-	discoveryfake "github.com/jetstack/cert-manager/test/unit/discovery"
-)
-
-var (
-	expNoServerGroups = func(t *testing.T) func() (*metav1.APIGroupList, error) {
-		return func() (*metav1.APIGroupList, error) {
-			t.Fatal("unexpected ServerGroups call")
-			return nil, nil
-		}
-	}
-
-	expNoServerResourcesForGroupVersion = func(t *testing.T) func(string) (*metav1.APIResourceList, error) {
-		return func(groupVersion string) (*metav1.APIResourceList, error) {
-			t.Fatal("unexpected ServerResourcesForGroupVersion call")
-			return nil, nil
-		}
-	}
-
-	expNoDiscovery = func(t *testing.T) discovery.DiscoveryInterface {
-		return discoveryfake.NewDiscovery().
-			WithServerGroups(expNoServerGroups(t)).
-			WithServerResourcesForGroupVersion(expNoServerResourcesForGroupVersion(t))
-	}
-)
-
-func TestValidate(t *testing.T) {
-	baseCR := &internalcmapi.CertificateRequest{}
-
-	approvedCR := &internalcmapi.CertificateRequest{
-		Spec: internalcmapi.CertificateRequestSpec{
-			IssuerRef: internalcmmeta.ObjectReference{
-				Name:  "my-issuer",
-				Kind:  "Issuer",
-				Group: "example.io",
-			},
-		},
-		Status: internalcmapi.CertificateRequestStatus{
-			Conditions: []internalcmapi.CertificateRequestCondition{
-				{
-					Type:    internalcmapi.CertificateRequestConditionApproved,
-					Status:  internalcmmeta.ConditionTrue,
-					Reason:  "cert-manager.io",
-					Message: "",
-				},
-			},
-		},
-	}
-
-	expNoSARReaction := func(t *testing.T) coretesting.ReactionFunc {
-		return func(_ coretesting.Action) (bool, runtime.Object, error) {
-			t.Fatal("unexpected call")
-			return true, nil, nil
-		}
-	}
-
-	tests := map[string]struct {
-		req          *admissionv1.AdmissionRequest
-		oldCR, newCR *internalcmapi.CertificateRequest
-
-		sarreaction    func(t *testing.T) coretesting.ReactionFunc
-		discoverclient func(t *testing.T) discovery.DiscoveryInterface
-
-		expErr *field.Error
-	}{
-		"if the request is not an UPDATE operation, exit nil": {
-			req: &admissionv1.AdmissionRequest{
-				Operation: admissionv1.Create,
-				RequestKind: &metav1.GroupVersionKind{
-					Group: "cert-manager.io",
-					Kind:  "CertificateRequest",
-				},
-			},
-			sarreaction:    expNoSARReaction,
-			discoverclient: expNoDiscovery,
-			expErr:         nil,
-		},
-		"if the request is not for CertificateRequest, exit nil": {
-			req: &admissionv1.AdmissionRequest{
-				Operation: admissionv1.Update,
-				RequestKind: &metav1.GroupVersionKind{
-					Group: "cert-manager.io",
-					Kind:  "Issuers",
-				},
-			},
-			sarreaction:    expNoSARReaction,
-			discoverclient: expNoDiscovery,
-			expErr:         nil,
-		},
-		"if the request is not for cert-manager.io, exit nil": {
-			req: &admissionv1.AdmissionRequest{
-				Operation: admissionv1.Update,
-				RequestKind: &metav1.GroupVersionKind{
-					Group: "foo.cert-manager.io",
-					Kind:  "CertificateRequest",
-				},
-			},
-			sarreaction:    expNoSARReaction,
-			discoverclient: expNoDiscovery,
-			expErr:         nil,
-		},
-		"if the CertificateRequest references a signer that doesn't exist, error": {
-			req: &admissionv1.AdmissionRequest{
-				Operation: admissionv1.Update,
-				RequestKind: &metav1.GroupVersionKind{
-					Group: "cert-manager.io",
-					Kind:  "CertificateRequest",
-				},
-			},
-			oldCR:       baseCR,
-			newCR:       approvedCR,
-			sarreaction: expNoSARReaction,
-			discoverclient: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "foo"},
-								{Name: "bar"},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(expNoServerResourcesForGroupVersion(t))
-			},
-			expErr: field.Forbidden(field.NewPath("spec.issuerRef"),
-				"referenced signer resource does not exist: {my-issuer Issuer example.io}"),
-		},
-		"if the CertificateRequest references a signer that the approver doesn't have permissions for, error": {
-			req: &admissionv1.AdmissionRequest{
-				UserInfo: authnv1.UserInfo{
-					Username: "user-1",
-				},
-				Operation: admissionv1.Update,
-				RequestKind: &metav1.GroupVersionKind{
-					Group: "cert-manager.io",
-					Kind:  "CertificateRequest",
-				},
-			},
-			oldCR: baseCR,
-			newCR: approvedCR,
-			discoverclient: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "example.io", Versions: []metav1.GroupVersionForDiscovery{
-									{GroupVersion: "foo-bar"},
-								}},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
-						if groupVersion != "foo-bar" {
-							t.Errorf("unexpected group version string: %s", groupVersion)
-						}
-						return &metav1.APIResourceList{
-							APIResources: []metav1.APIResource{
-								{
-									Kind: "hello-world",
-								},
-								{
-									Namespaced: true,
-									Name:       "issuers",
-									Kind:       "Issuer",
-								},
-							},
-						}, nil
-					})
-			},
-			sarreaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(action coretesting.Action) (bool, runtime.Object, error) {
-					return true, &authzv1.SubjectAccessReview{
-						Status: authzv1.SubjectAccessReviewStatus{
-							Allowed: false,
-						},
-					}, nil
-				}
-			},
-			expErr: field.Forbidden(field.NewPath("status.conditions"),
-				`user "user-1" does not have permissions to set approved/denied conditions for issuer {my-issuer Issuer example.io}`),
-		},
-		"if the CertificateRequest references a signer that the approver has permissions for, return nil": {
-			req: &admissionv1.AdmissionRequest{
-				UserInfo: authnv1.UserInfo{
-					Username: "user-1",
-				},
-				Operation: admissionv1.Update,
-				RequestKind: &metav1.GroupVersionKind{
-					Group: "cert-manager.io",
-					Kind:  "CertificateRequest",
-				},
-			},
-			oldCR: baseCR,
-			newCR: approvedCR,
-			discoverclient: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "example.io", Versions: []metav1.GroupVersionForDiscovery{
-									{GroupVersion: "foo-bar"},
-								}},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
-						if groupVersion != "foo-bar" {
-							t.Errorf("unexpected group version string: %s", groupVersion)
-						}
-						return &metav1.APIResourceList{
-							APIResources: []metav1.APIResource{
-								{
-									Kind: "hello-world",
-								},
-								{
-									Namespaced: true,
-									Name:       "issuers",
-									Kind:       "Issuer",
-								},
-							},
-						}, nil
-					})
-			},
-			sarreaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(action coretesting.Action) (bool, runtime.Object, error) {
-					return true, &authzv1.SubjectAccessReview{
-						Status: authzv1.SubjectAccessReviewStatus{
-							Allowed: true,
-						},
-					}, nil
-				}
-			},
-			expErr: nil,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			client := kubefake.NewSimpleClientset()
-			client.Fake.PrependReactor("*", "*", test.sarreaction(t))
-
-			a := approval{
-				scheme:         webhook.Scheme,
-				sarclient:      client.AuthorizationV1().SubjectAccessReviews(),
-				discoverclient: test.discoverclient(t),
-			}
-
-			err := a.Validate(context.TODO(), test.req, test.oldCR, test.newCR)
-			if !reflect.DeepEqual(test.expErr, err) {
-				t.Errorf("unexpected error, exp=%#+v got=%#+v",
-					test.expErr, err)
-			}
-		})
-	}
-}
-
-func TestReviewRequest(t *testing.T) {
-	userInfo := authnv1.UserInfo{
-		Username: "user-1",
-		Groups:   []string{"group-1", "group-2"},
-		UID:      "abc1",
-		Extra: map[string]authnv1.ExtraValue{
-			"foo": {"123", "456"},
-			"bar": {"789", "000"},
-		},
-	}
-
-	verifyRequestUserInfo := func(t *testing.T, action coretesting.Action) {
-		sar := action.(coretesting.CreateActionImpl).Object.(*authzv1.SubjectAccessReview)
-		if sar.Spec.User != "user-1" ||
-			!reflect.DeepEqual(sar.Spec.Groups, []string{"group-1", "group-2"}) ||
-			sar.Spec.UID != "abc1" ||
-			!reflect.DeepEqual(sar.Spec.Extra, map[string]authzv1.ExtraValue{
-				"foo": {"123", "456"},
-				"bar": {"789", "000"},
-			}) {
-			t.Errorf("got unexpected review userinfo: %#+v", sar.Spec)
-		}
-	}
-
-	tests := map[string]struct {
-		names    []string
-		reaction func(t *testing.T) coretesting.ReactionFunc
-
-		expOK, expErr bool
-	}{
-		"if no names given, expect no calls and return false": {
-			names: []string{},
-			reaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(_ coretesting.Action) (bool, runtime.Object, error) {
-					t.Fatal("unexpected call")
-					return true, nil, nil
-				}
-			},
-			expOK:  false,
-			expErr: false,
-		},
-		"if SAR returns error, return error": {
-			names: []string{
-				"issuers.cert-manager.io/*",
-				"issuers.cert-manager.io/sandbox.my-issuer",
-			},
-			reaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(action coretesting.Action) (bool, runtime.Object, error) {
-					verifyRequestUserInfo(t, action)
-					return true, nil, errors.New("this is an error")
-				}
-			},
-			expOK:  false,
-			expErr: true,
-		},
-		"if both SARs returns false, return false": {
-			names: []string{
-				"issuers.cert-manager.io/*",
-				"issuers.cert-manager.io/sandbox.my-issuer",
-			},
-			reaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(action coretesting.Action) (bool, runtime.Object, error) {
-					verifyRequestUserInfo(t, action)
-					return true, &authzv1.SubjectAccessReview{
-						Status: authzv1.SubjectAccessReviewStatus{
-							Allowed: false,
-						},
-					}, nil
-				}
-			},
-			expOK:  false,
-			expErr: false,
-		},
-		"if first sar returns true, return ok": {
-			names: []string{
-				"issuers.cert-manager.io/*",
-				"issuers.cert-manager.io/sandbox.my-issuer",
-			},
-			reaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(action coretesting.Action) (bool, runtime.Object, error) {
-					verifyRequestUserInfo(t, action)
-
-					sar := action.(coretesting.CreateActionImpl).Object.(*authzv1.SubjectAccessReview)
-					switch sar.Spec.ResourceAttributes.Name {
-					case "issuers.cert-manager.io/*":
-						return true, &authzv1.SubjectAccessReview{
-							Status: authzv1.SubjectAccessReviewStatus{
-								Allowed: true,
-							},
-						}, nil
-
-					default:
-						t.Fatalf("unexpected sar call: %#+v\n", sar.Spec)
-						return true, nil, nil
-					}
-				}
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if second sar returns true, return true": {
-			names: []string{
-				"issuers.cert-manager.io/*",
-				"issuers.cert-manager.io/sandbox.my-issuer",
-			},
-			reaction: func(t *testing.T) coretesting.ReactionFunc {
-				return func(action coretesting.Action) (bool, runtime.Object, error) {
-					verifyRequestUserInfo(t, action)
-
-					sar := action.(coretesting.CreateActionImpl).Object.(*authzv1.SubjectAccessReview)
-					switch sar.Spec.ResourceAttributes.Name {
-					case "issuers.cert-manager.io/*":
-						return true, &authzv1.SubjectAccessReview{
-							Status: authzv1.SubjectAccessReviewStatus{
-								Allowed: false,
-							},
-						}, nil
-
-					case "issuers.cert-manager.io/sandbox.my-issuer":
-						return true, &authzv1.SubjectAccessReview{
-							Status: authzv1.SubjectAccessReviewStatus{
-								Allowed: true,
-							},
-						}, nil
-
-					default:
-						t.Fatalf("unexpected sar call: %#+v\n", sar.Spec)
-						return true, nil, nil
-					}
-				}
-			},
-			expOK:  true,
-			expErr: false,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			client := kubefake.NewSimpleClientset()
-			client.Fake.PrependReactor("*", "*", test.reaction(t))
-
-			a := &approval{
-				sarclient: client.AuthorizationV1().SubjectAccessReviews(),
-			}
-
-			req := &admissionv1.AdmissionRequest{UserInfo: userInfo}
-			ok, err := a.reviewRequest(context.TODO(), req, test.names)
-			if (err != nil) != test.expErr {
-				t.Errorf("unexpected error, exp=%t got=%v",
-					test.expErr, err)
-			}
-
-			if ok != test.expOK {
-				t.Errorf("unexpected ok, exp=%t got=%t",
-					test.expOK, ok)
-			}
-		})
-	}
-}
-
-func TestIsApprovalRequest(t *testing.T) {
-	baseCR := &internalcmapi.CertificateRequest{}
-
-	approvedCR := &internalcmapi.CertificateRequest{
-		Status: internalcmapi.CertificateRequestStatus{
-			Conditions: []internalcmapi.CertificateRequestCondition{
-				{
-					Type:    internalcmapi.CertificateRequestConditionApproved,
-					Status:  internalcmmeta.ConditionTrue,
-					Reason:  "cert-manager.io",
-					Message: "",
-				},
-			},
-		},
-	}
-
-	deniedCR := &internalcmapi.CertificateRequest{
-		Status: internalcmapi.CertificateRequestStatus{
-			Conditions: []internalcmapi.CertificateRequestCondition{
-				{
-					Type:    internalcmapi.CertificateRequestConditionDenied,
-					Status:  internalcmmeta.ConditionTrue,
-					Reason:  "cert-manager.io",
-					Message: "",
-				},
-			},
-		},
-	}
-
-	tests := map[string]struct {
-		oldCR, newCR *internalcmapi.CertificateRequest
-		expIs        bool
-	}{
-		"if no approval condition change, then return false": {
-			oldCR: baseCR,
-			newCR: baseCR,
-			expIs: false,
-		},
-		"if approval condition added, then return true": {
-			oldCR: baseCR,
-			newCR: approvedCR,
-			expIs: true,
-		},
-		"if denied condition added, then return true": {
-			oldCR: baseCR,
-			newCR: deniedCR,
-			expIs: true,
-		},
-		"if both old and new approved, return false": {
-			oldCR: approvedCR,
-			newCR: approvedCR,
-			expIs: false,
-		},
-		"if both old and new denied, return false": {
-			oldCR: deniedCR,
-			newCR: deniedCR,
-			expIs: false,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			is := isApprovalRequest(test.oldCR, test.newCR)
-			if test.expIs != is {
-				t.Errorf("unexpected isApprovalRequest response, exp=%t got=%t",
-					test.expIs, is)
-			}
-		})
-	}
-}
-
-func TestSignerResource(t *testing.T) {
-	tests := map[string]struct {
-		request *internalcmapi.CertificateRequest
-
-		client        func(t *testing.T) discovery.DiscoveryInterface
-		expSigner     *signerResource
-		expOK, expErr bool
-	}{
-		"if no group or kind, return internal signer resource for issuers.cert-manager.io": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Name: "my-issuer",
-					},
-				},
-			},
-			client: expNoDiscovery,
-			expSigner: &signerResource{
-				name:             "issuers",
-				group:            "cert-manager.io",
-				namespaced:       true,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if no group with kind Issuer, return internal signer resource for issuers.cert-manager.io": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Kind: "Issuer",
-						Name: "my-issuer",
-					},
-				},
-			},
-			client: expNoDiscovery,
-			expSigner: &signerResource{
-				name:             "issuers",
-				group:            "cert-manager.io",
-				namespaced:       true,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if no kind with group cert-manager.io, return internal signer resource for issuers.cert-manager.io": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "cert-manager.io",
-						Name:  "my-issuer",
-					},
-				},
-			},
-			client: expNoDiscovery,
-			expSigner: &signerResource{
-				name:             "issuers",
-				group:            "cert-manager.io",
-				namespaced:       true,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if cert-manager.io Issuer, should return internal signer resource": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "cert-manager.io",
-						Kind:  "Issuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-			client: expNoDiscovery,
-			expSigner: &signerResource{
-				name:             "issuers",
-				group:            "cert-manager.io",
-				namespaced:       true,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if no group with ClusterIssuer, return internal signer resource for clusterissuers.cert-manager.io": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Kind: "ClusterIssuer",
-						Name: "my-issuer",
-					},
-				},
-			},
-			client: expNoDiscovery,
-			expSigner: &signerResource{
-				name:             "clusterissuers",
-				group:            "cert-manager.io",
-				namespaced:       false,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if kind ClusterIssuer group cert-manager.io, return internal signer resource for clusterissuers.cert-manager.io": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "cert-manager.io",
-						Kind:  "ClusterIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-			expSigner: &signerResource{
-				name:             "clusterissuers",
-				group:            "cert-manager.io",
-				namespaced:       false,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			client: expNoDiscovery,
-			expOK:  true,
-			expErr: false,
-		},
-		"if external group where the groups call errors, return error": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "example.io",
-						Kind:  "MyClusterIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-
-			client: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return nil, errors.New("this is an error")
-					}).
-					WithServerResourcesForGroupVersion(expNoServerResourcesForGroupVersion(t))
-			},
-			expSigner: nil,
-			expOK:     false,
-			expErr:    true,
-		},
-		"if external group is not registered, then return false": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "example.io",
-						Kind:  "MyClusterIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-
-			client: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "foo"},
-								{Name: "bar"},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(expNoServerResourcesForGroupVersion(t))
-			},
-			expSigner: nil,
-			expOK:     false,
-			expErr:    false,
-		},
-		"if external group is registered, but server resources call errors, error": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "example.io",
-						Kind:  "MyClusterIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-
-			client: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "foo"},
-								{Name: "bar"},
-								{Name: "example.io", Versions: []metav1.GroupVersionForDiscovery{
-									{GroupVersion: "foo-bar"},
-								}},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
-						if groupVersion != "foo-bar" {
-							t.Errorf("unexpected group version string: %s", groupVersion)
-						}
-						return nil, errors.New("this is an error")
-					})
-			},
-			expSigner: nil,
-			expOK:     false,
-			expErr:    true,
-		},
-		"if external group is registered, but server resources kind is not, return false": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "example.io",
-						Kind:  "MyClusterIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-
-			client: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "foo"},
-								{Name: "bar"},
-								{Name: "example.io", Versions: []metav1.GroupVersionForDiscovery{
-									{GroupVersion: "foo-bar"},
-									{GroupVersion: "bar-foo"},
-								}},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
-						if groupVersion != "foo-bar" && groupVersion != "bar-foo" {
-							t.Errorf("unexpected group version string: %s", groupVersion)
-						}
-						return &metav1.APIResourceList{
-							APIResources: []metav1.APIResource{
-								{
-									Kind: "hello-world",
-								},
-								{
-									Kind: "NotMyClusterIssuer",
-								},
-							},
-						}, nil
-					})
-			},
-			expSigner: nil,
-			expOK:     false,
-			expErr:    false,
-		},
-		"if external group is registered, and server resources kind exists and namespaced, return namespaced signer": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "example.io",
-						Kind:  "MyClusterIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-
-			client: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "foo"},
-								{Name: "bar"},
-								{Name: "example.io", Versions: []metav1.GroupVersionForDiscovery{
-									{GroupVersion: "foo-bar"},
-									{GroupVersion: "bar-foo"},
-								}},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
-						if groupVersion != "foo-bar" && groupVersion != "bar-foo" {
-							t.Errorf("unexpected group version string: %s", groupVersion)
-						}
-						return &metav1.APIResourceList{
-							APIResources: []metav1.APIResource{
-								{
-									Kind: "hello-world",
-								},
-								{
-									Namespaced: true,
-									Name:       "issuers",
-									Kind:       "MyClusterIssuer",
-								},
-							},
-						}, nil
-					})
-			},
-			expSigner: &signerResource{
-				name:             "issuers",
-				group:            "example.io",
-				namespaced:       true,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-		"if external group is registered, and server resources kind exists and cluster scoped, return cluster scoped signer": {
-			request: &internalcmapi.CertificateRequest{
-				ObjectMeta: metav1.ObjectMeta{
-					Namespace: "test-ns",
-				},
-				Spec: internalcmapi.CertificateRequestSpec{
-					IssuerRef: internalcmmeta.ObjectReference{
-						Group: "example.io",
-						Kind:  "MyIssuer",
-						Name:  "my-issuer",
-					},
-				},
-			},
-
-			client: func(t *testing.T) discovery.DiscoveryInterface {
-				return discoveryfake.NewDiscovery().
-					WithServerGroups(func() (*metav1.APIGroupList, error) {
-						return &metav1.APIGroupList{
-							Groups: []metav1.APIGroup{
-								{Name: "foo"},
-								{Name: "bar"},
-								{Name: "example.io", Versions: []metav1.GroupVersionForDiscovery{
-									{GroupVersion: "foo-bar"},
-									{GroupVersion: "bar-foo"},
-								}},
-							},
-						}, nil
-					}).
-					WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
-						if groupVersion != "foo-bar" && groupVersion != "bar-foo" {
-							t.Errorf("unexpected group version string: %s", groupVersion)
-						}
-						return &metav1.APIResourceList{
-							APIResources: []metav1.APIResource{
-								{
-									Kind: "hello-world",
-								},
-								{
-									Namespaced: false,
-									Name:       "issuers",
-									Kind:       "MyIssuer",
-								},
-							},
-						}, nil
-					})
-			},
-			expSigner: &signerResource{
-				name:             "issuers",
-				group:            "example.io",
-				namespaced:       false,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expOK:  true,
-			expErr: false,
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			a := &approval{
-				discoverclient: test.client(t),
-			}
-
-			signer, ok, err := a.signerResource(test.request)
-			if (err != nil) != test.expErr {
-				t.Errorf("unexpected error, exp=%t got=%v",
-					test.expErr, err)
-			}
-
-			if ok != test.expOK {
-				t.Errorf("unexpected ok, exp=%t got=%v",
-					test.expOK, ok)
-			}
-
-			if !reflect.DeepEqual(signer, test.expSigner) {
-				t.Errorf("unexpected signer, exp=%#+v got=%#+v",
-					test.expSigner, signer)
-			}
-		})
-	}
-}
-
-func TestSignerResourceNames(t *testing.T) {
-	tests := map[string]struct {
-		signer   *signerResource
-		expNames []string
-	}{
-		"if namespaced, should return a wildcard and namespaced signer name": {
-			signer: &signerResource{
-				name:             "exampleissuers",
-				group:            "my-group.io",
-				namespaced:       true,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expNames: []string{
-				"exampleissuers.my-group.io/*",
-				"exampleissuers.my-group.io/test-ns.my-issuer",
-			},
-		},
-		"if cluster scoped, should return a wildcard and non namespaced signer name": {
-			signer: &signerResource{
-				name:             "exampleissuers",
-				group:            "my-group.io",
-				namespaced:       false,
-				signerName:       "my-issuer",
-				requestNamespace: "test-ns",
-			},
-			expNames: []string{
-				"exampleissuers.my-group.io/*",
-				"exampleissuers.my-group.io/my-issuer",
-			},
-		},
-	}
-
-	for name, test := range tests {
-		t.Run(name, func(t *testing.T) {
-			names := new(approval).signerResourceNames(test.signer)
-			if !reflect.DeepEqual(names, test.expNames) {
-				t.Errorf("unexpected signer names, exp=%v got=%v",
-					test.expNames, names)
-			}
-		})
-	}
-}
diff --git a/internal/apis/certmanager/validation/register.go b/internal/apis/certmanager/validation/register.go
deleted file mode 100644
index a89984547..000000000
--- a/internal/apis/certmanager/validation/register.go
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation
-
-import (
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	cmapi "github.com/jetstack/cert-manager/internal/apis/certmanager"
-)
-
-func AddToValidationRegistry(reg *validation.Registry) error {
-	if err := reg.AddValidateFunc(&cmapi.Certificate{}, ValidateCertificate); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&cmapi.Certificate{}, ValidateUpdateCertificate); err != nil {
-		return err
-	}
-
-	if err := reg.AddValidateFunc(&cmapi.CertificateRequest{}, ValidateCertificateRequest); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&cmapi.CertificateRequest{}, ValidateUpdateCertificateRequest); err != nil {
-		return err
-	}
-
-	if err := reg.AddValidateFunc(&cmapi.ClusterIssuer{}, ValidateClusterIssuer); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&cmapi.ClusterIssuer{}, ValidateUpdateClusterIssuer); err != nil {
-		return err
-	}
-
-	if err := reg.AddValidateFunc(&cmapi.Issuer{}, ValidateIssuer); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&cmapi.Issuer{}, ValidateUpdateIssuer); err != nil {
-		return err
-	}
-	return nil
-}
diff --git a/internal/ingress/BUILD.bazel b/internal/ingress/BUILD.bazel
index 9b0c4b767..0571194e3 100644
--- a/internal/ingress/BUILD.bazel
+++ b/internal/ingress/BUILD.bazel
@@ -37,6 +37,7 @@ go_test(
     deps = [
         "//pkg/controller:go_default_library",
         "//test/unit/discovery:go_default_library",
+        "@com_github_google_gofuzz//:go_default_library",
         "@com_github_stretchr_testify//assert:go_default_library",
         "@io_k8s_api//networking/v1:go_default_library",
         "@io_k8s_api//networking/v1beta1:go_default_library",
diff --git a/internal/ingress/convert.go b/internal/ingress/convert.go
index aef164390..de175b632 100644
--- a/internal/ingress/convert.go
+++ b/internal/ingress/convert.go
@@ -225,25 +225,7 @@ func autoConvert_networking_IngressBackend_To_v1beta1_IngressBackend(in *network
 //  out := new(networkingv1.Ingress)
 //  err := Convert_v1beta1_Ingress_To_networking_Ingress(in, out, nil)
 func Convert_v1beta1_Ingress_To_networking_Ingress(in *networkingv1beta1.Ingress, out *networkingv1.Ingress, s conversion.Scope) error {
-	err := autoConvert_v1beta1_Ingress_To_networking_Ingress(in, out, s)
-	if err != nil {
-		return err
-	}
-	// v1beta1 Ingresses should not have IngressClassName set but instead use the deprecated annotation.
-	// Move the ingress class from the annotations to the Spec
-	if in.Annotations == nil {
-		return nil
-	}
-	if ingressClass, found := in.Annotations["kubernetes.io/ingress.class"]; found {
-		out.Spec.IngressClassName = &ingressClass
-		// HERE BE DRAGONS:
-		// in.Annotations and out.Annotations point to the same map.
-		// This mutates in as well as out, so make sure in is not an object in
-		// client-go's cache, for example by only passing DeepCopy()d objects
-		// to Convert_v1beta1_Ingress_To_networking_Ingress
-		delete(out.Annotations, "kubernetes.io/ingress.class")
-	}
-	return nil
+	return autoConvert_v1beta1_Ingress_To_networking_Ingress(in, out, s)
 }
 
 func autoConvert_v1beta1_Ingress_To_networking_Ingress(in *networkingv1beta1.Ingress, out *networkingv1.Ingress, s conversion.Scope) error {
diff --git a/internal/ingress/convert_test.go b/internal/ingress/convert_test.go
index 679b67bdb..0da935983 100644
--- a/internal/ingress/convert_test.go
+++ b/internal/ingress/convert_test.go
@@ -17,8 +17,10 @@ limitations under the License.
 package ingress
 
 import (
+	"regexp"
 	"testing"
 
+	fuzz "github.com/google/gofuzz"
 	"github.com/stretchr/testify/assert"
 	networkingv1 "k8s.io/api/networking/v1"
 	networkingv1beta1 "k8s.io/api/networking/v1beta1"
@@ -32,14 +34,23 @@ var v1TestIngress = &networkingv1.Ingress{
 		Name:      "test-networkingv1-ingress",
 		Namespace: "test-networkingv1-namespace",
 		Annotations: map[string]string{
-			"test.key": "test.value",
+			"test.key":                    "test.value",
+			"kubernetes.io/ingress.class": "bogus-ingress-class",
 		},
 		Labels: map[string]string{
 			"labelkey": "labelvalue",
 		},
 	},
 	Spec: networkingv1.IngressSpec{
-		IngressClassName: pointer.String("bogus-ingress-class"),
+		// As discussed in https://github.com/jetstack/cert-manager/issues/4537
+		// the IngressClassName field is not directly equivalent to the
+		// kubernetes.io/ingress.class annotation. According to the Ingress graduation KEP:
+		// https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/758-ingress-api-group/README.md
+		// the annotation, if present, overrides this field.
+		//
+		// As the goal of cert-manager is to be as widely compatible as possible, we can only use the
+		// annotation to describe an ingress class.
+		IngressClassName: nil,
 		DefaultBackend: &networkingv1.IngressBackend{
 			Service: &networkingv1.IngressServiceBackend{
 				Name: "default-backend-svc",
@@ -184,6 +195,31 @@ func TestConvert_networking_Ingress_To_v1beta1_Ingress(t *testing.T) {
 			}
 			assert.Equal(t, expected, out, "conversion was not as expected")
 		},
+		"v1 -> v1beta1 -> v1 round trip preserves fields": func(t *testing.T) {
+			// Something mentioned in a previous code review is we should make sure we do not
+			// remove fields during conversion. There may be a better way of doing this, but this
+			// test will fill every field with a fuzzer and perform a conversion round trip.
+
+			base := new(networkingv1.Ingress)
+			f := fuzz.New().
+				// Filling both the port name and port number is invalid so skip the number for now
+				// (the fuzzer will put some negative ports in as well).
+				SkipFieldsWithPattern(regexp.MustCompile("Number")).
+				// The IngressClassNameLogic is tested below
+				SkipFieldsWithPattern(regexp.MustCompile("IngressClassName"))
+			f.Fuzz(base)
+
+			in := base.DeepCopy()
+			expected := in.DeepCopy()
+			intermediate := new(networkingv1beta1.Ingress)
+			out := new(networkingv1.Ingress)
+
+			err := Convert_networking_Ingress_To_v1beta1_Ingress(in, intermediate, nil)
+			assert.NoError(t, err, "conversion from v1 to v1beta1 should not fail")
+			err = Convert_v1beta1_Ingress_To_networking_Ingress(intermediate.DeepCopy(), out, nil)
+			assert.NoError(t, err, "conversion from v1beta1 to v1 should not fail")
+			assert.Equal(t, expected.Spec, out.Spec, "output Spec was not equal to input Spec after round trip")
+		},
 	}
 	for name, test := range tests {
 		t.Run(name, test)
diff --git a/internal/plugin/BUILD.bazel b/internal/plugin/BUILD.bazel
new file mode 100644
index 000000000..21cbf425a
--- /dev/null
+++ b/internal/plugin/BUILD.bazel
@@ -0,0 +1,36 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+
+go_library(
+    name = "go_default_library",
+    srcs = ["plugins.go"],
+    importpath = "github.com/jetstack/cert-manager/internal/plugin",
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//internal/plugin/admission/apideprecation:go_default_library",
+        "//internal/plugin/admission/certificaterequest/approval:go_default_library",
+        "//internal/plugin/admission/certificaterequest/identity:go_default_library",
+        "//internal/plugin/admission/resourcevalidation:go_default_library",
+        "//pkg/webhook/admission:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/sets:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [
+        ":package-srcs",
+        "//internal/plugin/admission/apideprecation:all-srcs",
+        "//internal/plugin/admission/certificaterequest/approval:all-srcs",
+        "//internal/plugin/admission/certificaterequest/identity:all-srcs",
+        "//internal/plugin/admission/resourcevalidation:all-srcs",
+    ],
+    tags = ["automanaged"],
+    visibility = ["//visibility:public"],
+)
diff --git a/internal/api/mutation/BUILD.bazel b/internal/plugin/admission/apideprecation/BUILD.bazel
similarity index 54%
rename from internal/api/mutation/BUILD.bazel
rename to internal/plugin/admission/apideprecation/BUILD.bazel
index abb208104..b743c1a52 100644
--- a/internal/api/mutation/BUILD.bazel
+++ b/internal/plugin/admission/apideprecation/BUILD.bazel
@@ -2,16 +2,15 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 
 go_library(
     name = "go_default_library",
-    srcs = ["registry.go"],
-    importpath = "github.com/jetstack/cert-manager/internal/api/mutation",
+    srcs = ["apideprecation.go"],
+    importpath = "github.com/jetstack/cert-manager/internal/plugin/admission/apideprecation",
     visibility = ["//:__subpackages__"],
     deps = [
+        "//pkg/apis/acme:go_default_library",
+        "//pkg/apis/certmanager:go_default_library",
+        "//pkg/webhook/admission:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/serializer:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/serializer/json:go_default_library",
-        "@xyz_gomodules_jsonpatch_v2//:go_default_library",
     ],
 )
 
@@ -31,15 +30,10 @@ filegroup(
 
 go_test(
     name = "go_default_test",
-    srcs = ["registry_test.go"],
+    srcs = ["apideprecation_test.go"],
+    embed = [":go_default_library"],
     deps = [
-        ":go_default_library",
-        "//internal/apis/certmanager:go_default_library",
-        "//pkg/apis/certmanager:go_default_library",
-        "//pkg/webhook:go_default_library",
-        "//test/unit/gen:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
     ],
 )
diff --git a/internal/plugin/admission/apideprecation/apideprecation.go b/internal/plugin/admission/apideprecation/apideprecation.go
new file mode 100644
index 000000000..23c9838e4
--- /dev/null
+++ b/internal/plugin/admission/apideprecation/apideprecation.go
@@ -0,0 +1,64 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package apideprecation
+
+import (
+	"context"
+	"fmt"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+
+	"github.com/jetstack/cert-manager/pkg/apis/acme"
+	"github.com/jetstack/cert-manager/pkg/apis/certmanager"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+)
+
+const PluginName = "APIDeprecation"
+
+type apiDeprecation struct{}
+
+// Register registers a plugin
+func Register(plugins *admission.Plugins) {
+	plugins.Register(PluginName, func() (admission.Interface, error) {
+		return NewPlugin(), nil
+	})
+}
+
+var _ admission.ValidationInterface = &apiDeprecation{}
+
+func (p apiDeprecation) Handles(_ admissionv1.Operation) bool {
+	return true
+}
+
+func (p apiDeprecation) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	// Only generate warning messages for cert-manager.io and acme.cert-manager.io APIs
+	if request.RequestResource.Group != certmanager.GroupName &&
+		request.RequestResource.Group != acme.GroupName {
+		return nil, nil
+	}
+
+	// All non-v1 API resources in cert-manager.io and acme.cert-manager.io are now deprecated
+	if request.RequestResource.Version == "v1" {
+		return nil, nil
+	}
+	return []string{fmt.Sprintf("%s.%s/%s is deprecated in v1.4+, unavailable in v1.6+; use %s.%s/v1", request.RequestResource.Resource, request.RequestResource.Group, request.RequestResource.Version, request.RequestResource.Resource, request.RequestResource.Group)}, nil
+}
+
+func NewPlugin() admission.Interface {
+	return new(apiDeprecation)
+}
diff --git a/internal/plugin/admission/apideprecation/apideprecation_test.go b/internal/plugin/admission/apideprecation/apideprecation_test.go
new file mode 100644
index 000000000..427aa3b44
--- /dev/null
+++ b/internal/plugin/admission/apideprecation/apideprecation_test.go
@@ -0,0 +1,75 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package apideprecation
+
+import (
+	"context"
+	"reflect"
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+func TestAPIDeprecation(t *testing.T) {
+	tests := map[string]struct {
+		req      *admissionv1.AdmissionRequest
+		warnings []string
+	}{
+		"should print warnings for all non-v1 cert-manager.io types": {
+			req: &admissionv1.AdmissionRequest{
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Version:  "something-not-v1",
+					Resource: "somethings",
+				},
+			},
+			warnings: []string{"somethings.cert-manager.io/something-not-v1 is deprecated in v1.4+, unavailable in v1.6+; use somethings.cert-manager.io/v1"},
+		},
+		"should print warnings for all non-v1 acme.cert-manager.io types": {
+			req: &admissionv1.AdmissionRequest{
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "acme.cert-manager.io",
+					Version:  "something-not-v1",
+					Resource: "somethings",
+				},
+			},
+			warnings: []string{"somethings.acme.cert-manager.io/something-not-v1 is deprecated in v1.4+, unavailable in v1.6+; use somethings.acme.cert-manager.io/v1"},
+		},
+		"should not print warnings for non-v1 types in other groups": {
+			req: &admissionv1.AdmissionRequest{
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "some-other-group-name",
+					Version:  "something-not-v1",
+					Resource: "somethings",
+				},
+			},
+		},
+	}
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			p := NewPlugin().(*apiDeprecation)
+			warnings, err := p.Validate(context.Background(), *test.req, nil, nil)
+			if err != nil {
+				t.Errorf("unexpected error")
+			}
+			if !reflect.DeepEqual(warnings, test.warnings) {
+				t.Errorf("unexpected warnings, exp=%q, got=%q", test.warnings, warnings)
+			}
+		})
+	}
+}
diff --git a/internal/apis/certmanager/validation/plugins/BUILD.bazel b/internal/plugin/admission/certificaterequest/approval/BUILD.bazel
similarity index 68%
rename from internal/apis/certmanager/validation/plugins/BUILD.bazel
rename to internal/plugin/admission/certificaterequest/approval/BUILD.bazel
index 73667a0d7..6ee62d549 100644
--- a/internal/apis/certmanager/validation/plugins/BUILD.bazel
+++ b/internal/plugin/admission/certificaterequest/approval/BUILD.bazel
@@ -2,47 +2,40 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 
 go_library(
     name = "go_default_library",
-    srcs = [
-        "approval.go",
-        "plugins.go",
-    ],
-    importpath = "github.com/jetstack/cert-manager/internal/apis/certmanager/validation/plugins",
+    srcs = ["certificaterequest_approval.go"],
+    importpath = "github.com/jetstack/cert-manager/internal/plugin/admission/certificaterequest/approval",
     visibility = ["//:__subpackages__"],
     deps = [
         "//internal/apis/certmanager:go_default_library",
         "//internal/apis/certmanager/validation/util:go_default_library",
-        "//pkg/apis/certmanager:go_default_library",
-        "//pkg/apis/certmanager/v1:go_default_library",
+        "//pkg/webhook/admission:go_default_library",
+        "//pkg/webhook/admission/initializer:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
-        "@io_k8s_api//authorization/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
+        "@io_k8s_apiserver//pkg/authentication/user:go_default_library",
+        "@io_k8s_apiserver//pkg/authorization/authorizer:go_default_library",
         "@io_k8s_client_go//discovery:go_default_library",
         "@io_k8s_client_go//kubernetes:go_default_library",
-        "@io_k8s_client_go//kubernetes/typed/authorization/v1:go_default_library",
     ],
 )
 
 go_test(
     name = "go_default_test",
-    srcs = ["approval_test.go"],
+    srcs = ["certificaterequest_approval_test.go"],
     embed = [":go_default_library"],
     deps = [
         "//internal/apis/certmanager:go_default_library",
         "//internal/apis/meta:go_default_library",
-        "//pkg/webhook:go_default_library",
         "//test/unit/discovery:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_api//authentication/v1:go_default_library",
-        "@io_k8s_api//authorization/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
+        "@io_k8s_apiserver//pkg/authorization/authorizer:go_default_library",
         "@io_k8s_client_go//discovery:go_default_library",
-        "@io_k8s_client_go//kubernetes/fake:go_default_library",
-        "@io_k8s_client_go//testing:go_default_library",
     ],
 )
 
diff --git a/internal/plugin/admission/certificaterequest/approval/certificaterequest_approval.go b/internal/plugin/admission/certificaterequest/approval/certificaterequest_approval.go
new file mode 100644
index 000000000..a85c6bdb3
--- /dev/null
+++ b/internal/plugin/admission/certificaterequest/approval/certificaterequest_approval.go
@@ -0,0 +1,288 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package approval
+
+// CertificateRequestApproval is a plugin that ensures entities that are attempting to
+// modify `status.conditions[type="Approved"]` or `status.conditions[type="Denied"]`
+// have permission to do so (granted via RBAC).
+// Entities will need to be able to `approve` (verb) `signers` (resource type) in
+// `cert-manager.io` (group) with the name `<issuer-type>.<issuer-group>/[<certificaterequest-namespace>.]<issuer-name>`.
+// For example: `issuers.cert-manager.io/my-namespace.my-issuer-name`.
+// A wildcard signerName format is also supported: `issuers.cert-manager.io/*`.
+
+import (
+	"context"
+	"fmt"
+	"strings"
+	"sync"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+	"k8s.io/apiserver/pkg/authentication/user"
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+	"k8s.io/client-go/discovery"
+	"k8s.io/client-go/kubernetes"
+
+	"github.com/jetstack/cert-manager/internal/apis/certmanager"
+	"github.com/jetstack/cert-manager/internal/apis/certmanager/validation/util"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission/initializer"
+)
+
+const PluginName = "CertificateRequestApproval"
+
+type certificateRequestApproval struct {
+	*admission.Handler
+
+	authorizer authorizer.Authorizer
+	discovery  discovery.DiscoveryInterface
+
+	// resourceCache stores the associated APIResource for a given GroupKind
+	// to making multiple queries to the API server for every approval.
+	resourceCache map[schema.GroupKind]metav1.APIResource
+	mutex         sync.RWMutex
+}
+
+var _ admission.ValidationInterface = &certificateRequestApproval{}
+var _ initializer.WantsAuthorizer = &certificateRequestApproval{}
+var _ initializer.WantsExternalKubeClientSet = &certificateRequestApproval{}
+
+func Register(plugins *admission.Plugins) {
+	plugins.Register(PluginName, func() (admission.Interface, error) {
+		return NewPlugin(), nil
+	})
+}
+
+func NewPlugin() admission.Interface {
+	return &certificateRequestApproval{
+		Handler:       admission.NewHandler(admissionv1.Update),
+		resourceCache: map[schema.GroupKind]metav1.APIResource{},
+	}
+}
+
+func (c *certificateRequestApproval) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	if request.RequestResource.Group != "cert-manager.io" ||
+		request.RequestResource.Resource != "certificaterequests" ||
+		request.RequestSubResource != "status" {
+		return nil, nil
+	}
+
+	oldCR, cr := oldObj.(*certmanager.CertificateRequest), obj.(*certmanager.CertificateRequest)
+	if !approvalConditionsHaveChanged(oldCR, cr) {
+		return nil, nil
+	}
+
+	group := cr.Spec.IssuerRef.Group
+	kind := cr.Spec.IssuerRef.Kind
+	// TODO: move this defaulting into the Scheme (registered as default functions) so
+	//       these will be set when the CertificateRequest is decoded.
+	if group == "" {
+		group = "cert-manager.io"
+	}
+	if kind == "" {
+		kind = "Issuer"
+	}
+	apiResource, err := c.apiResourceForGroupKind(schema.GroupKind{Group: group, Kind: kind})
+	switch {
+	case err == errNoResourceExists:
+		return nil, field.Forbidden(field.NewPath("spec.issuerRef"),
+			fmt.Sprintf("referenced signer resource does not exist: %v", cr.Spec.IssuerRef))
+	case err != nil:
+		return nil, err
+	}
+
+	signerName := signerNameForAPIResource(cr.Spec.IssuerRef.Name, cr.Namespace, *apiResource)
+	if !isAuthorizedForSignerName(ctx, c.authorizer, userInfoForRequest(request), signerName) {
+		return nil, field.Forbidden(field.NewPath("status.conditions"),
+			fmt.Sprintf("user %q does not have permissions to set approved/denied conditions for issuer %v", request.UserInfo.Username, cr.Spec.IssuerRef))
+	}
+
+	return nil, nil
+}
+
+// approvalConditionsHaveChanged returns true if either the Approved or Denied conditions
+// have been added to the CertificateRequest.
+func approvalConditionsHaveChanged(oldCR, cr *certmanager.CertificateRequest) bool {
+	oldCRApproving := util.GetCertificateRequestCondition(oldCR.Status.Conditions, certmanager.CertificateRequestConditionApproved)
+	newCRApproving := util.GetCertificateRequestCondition(cr.Status.Conditions, certmanager.CertificateRequestConditionApproved)
+	oldCRDenying := util.GetCertificateRequestCondition(oldCR.Status.Conditions, certmanager.CertificateRequestConditionDenied)
+	newCRDenying := util.GetCertificateRequestCondition(cr.Status.Conditions, certmanager.CertificateRequestConditionDenied)
+	return (oldCRApproving == nil && newCRApproving != nil) || (oldCRDenying == nil && newCRDenying != nil)
+}
+
+// apiResourceForGroupKind returns the metav1.APIResource descriptor for a given GroupKind.
+// This is required to properly construct the `signerName` used as part of validating
+// requests that approve or deny the CertificateRequest.
+// namespaced will be true if the resource is namespaced.
+// 'resource' may be nil even if err is also nil.
+func (c *certificateRequestApproval) apiResourceForGroupKind(groupKind schema.GroupKind) (resource *metav1.APIResource, err error) {
+	// fast path if resource is in the cache already
+	if resource := c.readAPIResourceFromCache(groupKind); resource != nil {
+		return resource, nil
+	}
+
+	// otherwise, query the apiserver
+	// TODO: we should enhance caching here to avoid performing discovery queries
+	//       many times if many CertificateRequest resources exist that reference
+	//       a resource that doesn't exist
+	groups, err := c.discovery.ServerGroups()
+	if err != nil {
+		return nil, err
+	}
+
+	for _, apiGroup := range groups.Groups {
+		if apiGroup.Name != groupKind.Group {
+			continue
+		}
+
+		for _, version := range apiGroup.Versions {
+			apiResources, err := c.discovery.ServerResourcesForGroupVersion(version.GroupVersion)
+			if err != nil {
+				return nil, err
+			}
+
+			for _, resource := range apiResources.APIResources {
+				if resource.Kind != groupKind.Kind {
+					continue
+				}
+
+				r := resource.DeepCopy()
+				// the Group field is not always populated in responses, so explicitly set it
+				r.Group = apiGroup.Name
+				c.cacheAPIResource(groupKind, *r)
+				return r, nil
+			}
+		}
+	}
+
+	return nil, errNoResourceExists
+}
+
+func (c *certificateRequestApproval) readAPIResourceFromCache(groupKind schema.GroupKind) *metav1.APIResource {
+	c.mutex.RLock()
+	defer c.mutex.RUnlock()
+	if resource, ok := c.resourceCache[groupKind]; ok {
+		return &resource
+	}
+	return nil
+}
+
+func (c *certificateRequestApproval) cacheAPIResource(groupKind schema.GroupKind, resource metav1.APIResource) {
+	c.mutex.Lock()
+	defer c.mutex.Unlock()
+	c.resourceCache[groupKind] = resource
+}
+
+var errNoResourceExists = fmt.Errorf("no resource registered")
+
+// signerNameForAPIResource returns the computed signerName for a given API resource
+// referenced by a CertificateRequest in a namespace.
+func signerNameForAPIResource(name, namespace string, apiResource metav1.APIResource) string {
+	if apiResource.Namespaced {
+		return fmt.Sprintf("%s.%s/%s.%s", apiResource.Name, apiResource.Group, namespace, name)
+	}
+	return fmt.Sprintf("%s.%s/%s", apiResource.Name, apiResource.Group, name)
+}
+
+// userInfoForRequest constructs a user.Info suitable for using with the authorizer interface
+// from an AdmissionRequest.
+func userInfoForRequest(req admissionv1.AdmissionRequest) user.Info {
+	extra := make(map[string][]string)
+	for k, v := range req.UserInfo.Extra {
+		extra[k] = v
+	}
+	return &user.DefaultInfo{
+		Name:   req.UserInfo.Username,
+		UID:    req.UserInfo.UID,
+		Groups: req.UserInfo.Groups,
+		Extra:  extra,
+	}
+}
+
+// isAuthorizedForSignerName checks whether an entity is authorized to 'approve' certificaterequests
+// for a given signerName.
+// We absorb errors from the authorizer because they are already retried by the underlying authorization
+// client, so we shouldn't ever see them unless the context webhook doesn't have the ability to submit
+// SARs or the context is cancelled (in which case, the AdmissionResponse won't ever be returned to the apiserver).
+func isAuthorizedForSignerName(ctx context.Context, authz authorizer.Authorizer, info user.Info, signerName string) bool {
+	verb := "approve"
+	// First check if the user has explicit permission to 'approve' for the given signerName.
+	attr := buildAttributes(info, verb, signerName)
+	decision, _, err := authz.Authorize(ctx, attr)
+	switch {
+	case err != nil:
+		return false
+	case decision == authorizer.DecisionAllow:
+		return true
+	}
+
+	// If not, check if the user has wildcard permissions to 'approve' for the domain portion of the signerName, e.g.
+	// 'issuers.cert-manager.io/*'.
+	attr = buildWildcardAttributes(info, verb, signerName)
+	decision, _, err = authz.Authorize(ctx, attr)
+	switch {
+	case err != nil:
+		return false
+	case decision == authorizer.DecisionAllow:
+		return true
+	}
+
+	return false
+}
+
+func buildAttributes(info user.Info, verb, signerName string) authorizer.Attributes {
+	return authorizer.AttributesRecord{
+		User:            info,
+		Verb:            verb,
+		Name:            signerName,
+		APIGroup:        "cert-manager.io",
+		APIVersion:      "*",
+		Resource:        "signers",
+		ResourceRequest: true,
+	}
+}
+
+func buildWildcardAttributes(info user.Info, verb, signerName string) authorizer.Attributes {
+	parts := strings.Split(signerName, "/")
+	domain := parts[0]
+	return buildAttributes(info, verb, domain+"/*")
+}
+
+func (c *certificateRequestApproval) SetAuthorizer(a authorizer.Authorizer) {
+	c.authorizer = a
+}
+
+func (c *certificateRequestApproval) SetExternalKubeClientSet(client kubernetes.Interface) {
+	c.discovery = client.Discovery()
+}
+
+func (c *certificateRequestApproval) ValidateInitialization() error {
+	if c.authorizer == nil {
+		return fmt.Errorf("authorizer not set")
+	}
+	if c.discovery == nil {
+		return fmt.Errorf("discovery client not set")
+	}
+	_, err := c.discovery.ServerGroups()
+	if err != nil {
+		return err
+	}
+	return nil
+}
diff --git a/internal/plugin/admission/certificaterequest/approval/certificaterequest_approval_test.go b/internal/plugin/admission/certificaterequest/approval/certificaterequest_approval_test.go
new file mode 100644
index 000000000..4ecb686ae
--- /dev/null
+++ b/internal/plugin/admission/certificaterequest/approval/certificaterequest_approval_test.go
@@ -0,0 +1,358 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package approval
+
+import (
+	"context"
+	"fmt"
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	authnv1 "k8s.io/api/authentication/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+	"k8s.io/client-go/discovery"
+
+	"github.com/jetstack/cert-manager/internal/apis/certmanager"
+	"github.com/jetstack/cert-manager/internal/apis/meta"
+	discoveryfake "github.com/jetstack/cert-manager/test/unit/discovery"
+)
+
+var (
+	expNoDiscovery = discovery.DiscoveryInterface(nil)
+)
+
+func TestValidate(t *testing.T) {
+	baseCR := &certmanager.CertificateRequest{
+		ObjectMeta: metav1.ObjectMeta{Namespace: "testns"},
+		Spec: certmanager.CertificateRequestSpec{
+			IssuerRef: meta.ObjectReference{
+				Name:  "my-issuer",
+				Kind:  "Issuer",
+				Group: "example.io",
+			},
+		},
+	}
+
+	approvedCR := baseCR.DeepCopy()
+	approvedCR.Status = certmanager.CertificateRequestStatus{
+		Conditions: []certmanager.CertificateRequestCondition{
+			{
+				Type:    certmanager.CertificateRequestConditionApproved,
+				Status:  meta.ConditionTrue,
+				Reason:  "cert-manager.io",
+				Message: "",
+			},
+		},
+	}
+
+	var alwaysPanicAuthorizer *fakeAuthorizer
+	tests := map[string]struct {
+		req          *admissionv1.AdmissionRequest
+		oldCR, newCR *certmanager.CertificateRequest
+
+		authorizer     *fakeAuthorizer
+		discoverclient discovery.DiscoveryInterface
+
+		expErr error
+	}{
+		"if the request is not for CertificateRequest, exit nil": {
+			req: &admissionv1.AdmissionRequest{
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Resource: "issuers",
+				},
+				RequestSubResource: "status",
+			},
+			authorizer:     alwaysPanicAuthorizer,
+			discoverclient: expNoDiscovery,
+			expErr:         nil,
+		},
+		"if the request is not for cert-manager.io, exit nil": {
+			req: &admissionv1.AdmissionRequest{
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "foo.cert-manager.io",
+					Resource: "certificaterequests",
+				},
+				RequestSubResource: "status",
+			},
+			authorizer: alwaysPanicAuthorizer,
+			expErr:     nil,
+		},
+		"if the CertificateRequest references a signer that doesn't exist, error": {
+			req: &admissionv1.AdmissionRequest{
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Resource: "certificaterequests",
+				},
+				RequestSubResource: "status",
+			},
+			oldCR:      baseCR,
+			newCR:      approvedCR,
+			authorizer: alwaysPanicAuthorizer,
+			discoverclient: discoveryfake.NewDiscovery().
+				WithServerGroups(func() (*metav1.APIGroupList, error) {
+					return &metav1.APIGroupList{}, nil
+				}),
+			expErr: field.Forbidden(field.NewPath("spec.issuerRef"),
+				"referenced signer resource does not exist: {my-issuer Issuer example.io}"),
+		},
+		"if the CertificateRequest references a signer that the approver doesn't have permissions for, error": {
+			req: &admissionv1.AdmissionRequest{
+				UserInfo: authnv1.UserInfo{
+					Username: "user-1",
+				},
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Resource: "certificaterequests",
+				},
+				RequestSubResource: "status",
+			},
+			oldCR: baseCR,
+			newCR: approvedCR,
+			discoverclient: discoveryfake.NewDiscovery().
+				WithServerGroups(func() (*metav1.APIGroupList, error) {
+					return &metav1.APIGroupList{
+						Groups: []metav1.APIGroup{
+							{
+								Name: "example.io",
+								Versions: []metav1.GroupVersionForDiscovery{
+									{GroupVersion: "example.io/a-version", Version: "a-version"},
+								},
+							},
+						},
+					}, nil
+				}).
+				WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
+					return &metav1.APIResourceList{
+						APIResources: []metav1.APIResource{
+							{
+								Name:       "issuers",
+								Namespaced: true,
+								Kind:       "Issuer",
+							},
+						},
+					}, nil
+				}),
+			authorizer: &fakeAuthorizer{
+				verb:        "approve",
+				allowedName: "issuers.example.io/testns.my-issuer",
+				decision:    authorizer.DecisionNoOpinion,
+			},
+			expErr: field.Forbidden(field.NewPath("status.conditions"),
+				`user "user-1" does not have permissions to set approved/denied conditions for issuer {my-issuer Issuer example.io}`),
+		},
+		"if the CertificateRequest references a signer that the approver has permissions for, return nil": {
+			req: &admissionv1.AdmissionRequest{
+				UserInfo: authnv1.UserInfo{
+					Username: "user-1",
+				},
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Resource: "certificaterequests",
+				},
+				RequestSubResource: "status",
+			},
+			oldCR: baseCR,
+			newCR: approvedCR,
+			discoverclient: discoveryfake.NewDiscovery().
+				WithServerGroups(func() (*metav1.APIGroupList, error) {
+					return &metav1.APIGroupList{
+						Groups: []metav1.APIGroup{
+							{
+								Name: "example.io",
+								Versions: []metav1.GroupVersionForDiscovery{
+									{GroupVersion: "example.io/a-version", Version: "a-version"},
+								},
+							},
+						},
+					}, nil
+				}).
+				WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
+					return &metav1.APIResourceList{
+						APIResources: []metav1.APIResource{
+							{
+								Name:       "issuers",
+								Namespaced: true,
+								Kind:       "Issuer",
+							},
+						},
+					}, nil
+				}),
+			authorizer: &fakeAuthorizer{
+				verb:        "approve",
+				allowedName: "issuers.example.io/testns.my-issuer",
+				decision:    authorizer.DecisionAllow,
+			},
+		},
+		"if the CertificateRequest references a signer that the approver has permissions for the wildcard of, return nil": {
+			req: &admissionv1.AdmissionRequest{
+				UserInfo: authnv1.UserInfo{
+					Username: "user-1",
+				},
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Resource: "certificaterequests",
+				},
+				RequestSubResource: "status",
+			},
+			oldCR: baseCR,
+			newCR: approvedCR,
+			discoverclient: discoveryfake.NewDiscovery().
+				WithServerGroups(func() (*metav1.APIGroupList, error) {
+					return &metav1.APIGroupList{
+						Groups: []metav1.APIGroup{
+							{
+								Name: "example.io",
+								Versions: []metav1.GroupVersionForDiscovery{
+									{GroupVersion: "example.io/a-version", Version: "a-version"},
+								},
+							},
+						},
+					}, nil
+				}).
+				WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
+					return &metav1.APIResourceList{
+						APIResources: []metav1.APIResource{
+							{
+								Name:       "issuers",
+								Namespaced: true,
+								Kind:       "Issuer",
+							},
+						},
+					}, nil
+				}),
+			authorizer: &fakeAuthorizer{
+				verb:        "approve",
+				allowedName: "issuers.example.io/*",
+				decision:    authorizer.DecisionAllow,
+			},
+		},
+		"should error if the authorizer returns an error": {
+			req: &admissionv1.AdmissionRequest{
+				UserInfo: authnv1.UserInfo{
+					Username: "user-1",
+				},
+				Operation: admissionv1.Update,
+				RequestResource: &metav1.GroupVersionResource{
+					Group:    "cert-manager.io",
+					Resource: "certificaterequests",
+				},
+				RequestSubResource: "status",
+			},
+			oldCR: baseCR,
+			newCR: approvedCR,
+			discoverclient: discoveryfake.NewDiscovery().
+				WithServerGroups(func() (*metav1.APIGroupList, error) {
+					return &metav1.APIGroupList{
+						Groups: []metav1.APIGroup{
+							{
+								Name: "example.io",
+								Versions: []metav1.GroupVersionForDiscovery{
+									{GroupVersion: "example.io/a-version", Version: "a-version"},
+								},
+							},
+						},
+					}, nil
+				}).
+				WithServerResourcesForGroupVersion(func(groupVersion string) (*metav1.APIResourceList, error) {
+					return &metav1.APIResourceList{
+						APIResources: []metav1.APIResource{
+							{
+								Name:       "issuers",
+								Namespaced: true,
+								Kind:       "Issuer",
+							},
+						},
+					}, nil
+				}),
+			authorizer: &fakeAuthorizer{
+				err: fmt.Errorf("authorizer error"),
+			},
+			expErr: field.Forbidden(field.NewPath("status.conditions"),
+				`user "user-1" does not have permissions to set approved/denied conditions for issuer {my-issuer Issuer example.io}`),
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			a := NewPlugin().(*certificateRequestApproval)
+			a.discovery = test.discoverclient
+			if test.authorizer != nil {
+				test.authorizer.t = t
+			}
+			a.authorizer = test.authorizer
+
+			warnings, err := a.Validate(context.TODO(), *test.req, test.oldCR, test.newCR)
+			if len(warnings) > 0 {
+				t.Errorf("expected no warnings but got: %v", warnings)
+			}
+			compareErrors(t, test.expErr, err)
+		})
+	}
+}
+
+type fakeAuthorizer struct {
+	t           *testing.T
+	verb        string
+	allowedName string
+	decision    authorizer.Decision
+	err         error
+}
+
+func (f fakeAuthorizer) Authorize(ctx context.Context, a authorizer.Attributes) (authorizer.Decision, string, error) {
+	if f.err != nil {
+		return f.decision, "forced error", f.err
+	}
+	if a.GetVerb() != f.verb {
+		return authorizer.DecisionDeny, fmt.Sprintf("unrecognised verb '%s'", a.GetVerb()), nil
+	}
+	if a.GetAPIGroup() != "cert-manager.io" {
+		return authorizer.DecisionDeny, fmt.Sprintf("unrecognised groupName '%s'", a.GetAPIGroup()), nil
+	}
+	if a.GetAPIVersion() != "*" {
+		return authorizer.DecisionDeny, fmt.Sprintf("unrecognised apiVersion '%s'", a.GetAPIVersion()), nil
+	}
+	if a.GetResource() != "signers" {
+		return authorizer.DecisionDeny, fmt.Sprintf("unrecognised resource '%s'", a.GetResource()), nil
+	}
+	if a.GetName() != f.allowedName {
+		return authorizer.DecisionDeny, fmt.Sprintf("unrecognised resource name '%s'", a.GetName()), nil
+	}
+	if !a.IsResourceRequest() {
+		return authorizer.DecisionDeny, fmt.Sprintf("unrecognised IsResourceRequest '%t'", a.IsResourceRequest()), nil
+	}
+	return f.decision, "", nil
+}
+
+func compareErrors(t *testing.T, exp, act error) {
+	if exp == nil && act == nil {
+		return
+	}
+	if exp == nil && act != nil ||
+		exp != nil && act == nil ||
+		exp.Error() != act.Error() {
+		t.Errorf("error not as expected. exp=%v, act=%v", exp, act)
+	}
+}
diff --git a/internal/apis/certmanager/identity/certificaterequests/BUILD.bazel b/internal/plugin/admission/certificaterequest/identity/BUILD.bazel
similarity index 77%
rename from internal/apis/certmanager/identity/certificaterequests/BUILD.bazel
rename to internal/plugin/admission/certificaterequest/identity/BUILD.bazel
index 556d2183c..2e927742c 100644
--- a/internal/apis/certmanager/identity/certificaterequests/BUILD.bazel
+++ b/internal/plugin/admission/certificaterequest/identity/BUILD.bazel
@@ -2,13 +2,13 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 
 go_library(
     name = "go_default_library",
-    srcs = ["certificaterequests.go"],
-    importpath = "github.com/jetstack/cert-manager/internal/apis/certmanager/identity/certificaterequests",
+    srcs = ["certificaterequest_identity.go"],
+    importpath = "github.com/jetstack/cert-manager/internal/plugin/admission/certificaterequest/identity",
     visibility = ["//:__subpackages__"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//internal/apis/certmanager:go_default_library",
         "//pkg/util:go_default_library",
+        "//pkg/webhook/admission:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_api//authentication/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
@@ -16,6 +16,19 @@ go_library(
     ],
 )
 
+go_test(
+    name = "go_default_test",
+    srcs = ["certificaterequest_identity_test.go"],
+    embed = [":go_default_library"],
+    deps = [
+        "//internal/apis/certmanager:go_default_library",
+        "@io_k8s_api//admission/v1:go_default_library",
+        "@io_k8s_api//authentication/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
+    ],
+)
+
 filegroup(
     name = "package-srcs",
     srcs = glob(["**"]),
@@ -29,16 +42,3 @@ filegroup(
     tags = ["automanaged"],
     visibility = ["//visibility:public"],
 )
-
-go_test(
-    name = "go_default_test",
-    srcs = ["certificaterequests_test.go"],
-    embed = [":go_default_library"],
-    deps = [
-        "//internal/api/validation:go_default_library",
-        "//internal/apis/certmanager:go_default_library",
-        "@io_k8s_api//admission/v1:go_default_library",
-        "@io_k8s_api//authentication/v1:go_default_library",
-        "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
-    ],
-)
diff --git a/internal/plugin/admission/certificaterequest/identity/certificaterequest_identity.go b/internal/plugin/admission/certificaterequest/identity/certificaterequest_identity.go
new file mode 100644
index 000000000..476827db9
--- /dev/null
+++ b/internal/plugin/admission/certificaterequest/identity/certificaterequest_identity.go
@@ -0,0 +1,158 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package identity
+
+import (
+	"context"
+	"fmt"
+	"reflect"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	authenticationv1 "k8s.io/api/authentication/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+
+	"github.com/jetstack/cert-manager/internal/apis/certmanager"
+	"github.com/jetstack/cert-manager/pkg/util"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+)
+
+const PluginName = "CertificateRequestIdentity"
+
+type certificateRequestIdentity struct {
+	*admission.Handler
+}
+
+// Register registers a plugin
+func Register(plugins *admission.Plugins) {
+	plugins.Register(PluginName, func() (admission.Interface, error) {
+		return NewPlugin(), nil
+	})
+}
+
+var _ admission.ValidationInterface = &certificateRequestIdentity{}
+var _ admission.MutationInterface = &certificateRequestIdentity{}
+
+func NewPlugin() admission.Interface {
+	return &certificateRequestIdentity{
+		Handler: admission.NewHandler(admissionv1.Create, admissionv1.Update),
+	}
+}
+
+func (p *certificateRequestIdentity) Mutate(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+	// Only run this admission plugin for the certificaterequests/status sub-resource
+	if request.RequestResource.Group != "cert-manager.io" ||
+		request.RequestResource.Resource != "certificaterequests" ||
+		request.Operation != admissionv1.Create {
+		return nil
+	}
+
+	cr := obj.(*certmanager.CertificateRequest)
+	cr.Spec.UID = request.UserInfo.UID
+	cr.Spec.Username = request.UserInfo.Username
+	cr.Spec.Groups = request.UserInfo.Groups
+	cr.Spec.Extra = make(map[string][]string)
+	for k, v := range request.UserInfo.Extra {
+		cr.Spec.Extra[k] = v
+	}
+
+	return nil
+}
+
+func (p *certificateRequestIdentity) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+	// Only run this admission plugin for CertificateRequest resources
+	if request.RequestResource.Group != "cert-manager.io" ||
+		request.RequestResource.Resource != "certificaterequests" {
+		return nil, nil
+	}
+
+	// Cast the obj to a CertificateRequest
+	cr, ok := obj.(*certmanager.CertificateRequest)
+	if !ok {
+		return nil, fmt.Errorf("internal error: object in admission request is not of type *certmanager.CertificateRequest")
+	}
+
+	switch request.Operation {
+	case admissionv1.Create:
+		return nil, validateCreate(request, cr)
+	case admissionv1.Update:
+		oldCR, ok := oldObj.(*certmanager.CertificateRequest)
+		if !ok {
+			return nil, fmt.Errorf("internal error: oldObject in admission request is not of type *certmanager.CertificateRequest")
+		}
+		return nil, validateUpdate(oldCR, cr)
+	}
+
+	return nil, fmt.Errorf("internal error: request operation has changed - this should never be possible")
+}
+
+func validateUpdate(oldCR *certmanager.CertificateRequest, cr *certmanager.CertificateRequest) error {
+	fldPath := field.NewPath("spec")
+
+	var el field.ErrorList
+	if oldCR.Spec.UID != cr.Spec.UID {
+		el = append(el, field.Forbidden(fldPath.Child("uid"), "uid identity cannot be changed once set"))
+	}
+	if oldCR.Spec.Username != cr.Spec.Username {
+		el = append(el, field.Forbidden(fldPath.Child("username"), "username identity cannot be changed once set"))
+	}
+	if !util.EqualUnsorted(oldCR.Spec.Groups, cr.Spec.Groups) {
+		el = append(el, field.Forbidden(fldPath.Child("groups"), "groups identity cannot be changed once set"))
+	}
+	if !reflect.DeepEqual(oldCR.Spec.Extra, cr.Spec.Extra) {
+		el = append(el, field.Forbidden(fldPath.Child("extra"), "extra identity cannot be changed once set"))
+	}
+	return el.ToAggregate()
+}
+
+func validateCreate(request admissionv1.AdmissionRequest, cr *certmanager.CertificateRequest) error {
+	fldPath := field.NewPath("spec")
+
+	var el field.ErrorList
+	if cr.Spec.UID != request.UserInfo.UID {
+		el = append(el, field.Forbidden(fldPath.Child("uid"), "uid identity must be that of the requester"))
+	}
+	if cr.Spec.Username != request.UserInfo.Username {
+		el = append(el, field.Forbidden(fldPath.Child("username"), "username identity must be that of the requester"))
+	}
+	if !util.EqualUnsorted(cr.Spec.Groups, request.UserInfo.Groups) {
+		el = append(el, field.Forbidden(fldPath.Child("groups"), "groups identity must be that of the requester"))
+	}
+	if !extrasMatch(cr.Spec.Extra, request.UserInfo.Extra) {
+		el = append(el, field.Forbidden(fldPath.Child("extra"), "extra identity must be that of the requester"))
+	}
+	return el.ToAggregate()
+}
+
+func extrasMatch(crExtra map[string][]string, reqExtra map[string]authenticationv1.ExtraValue) bool {
+	if len(crExtra) != len(reqExtra) {
+		return false
+	}
+
+	for k, v := range crExtra {
+		reqv, ok := reqExtra[k]
+		if !ok {
+			return false
+		}
+
+		if !util.EqualUnsorted(v, reqv) {
+			return false
+		}
+	}
+
+	return true
+}
diff --git a/internal/plugin/admission/certificaterequest/identity/certificaterequest_identity_test.go b/internal/plugin/admission/certificaterequest/identity/certificaterequest_identity_test.go
new file mode 100644
index 000000000..5e30f65cd
--- /dev/null
+++ b/internal/plugin/admission/certificaterequest/identity/certificaterequest_identity_test.go
@@ -0,0 +1,467 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package identity
+
+import (
+	"context"
+	"reflect"
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	authenticationv1 "k8s.io/api/authentication/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+
+	"github.com/jetstack/cert-manager/internal/apis/certmanager"
+)
+
+var correctRequestResource = &metav1.GroupVersionResource{
+	Group:    "cert-manager.io",
+	Version:  "v1",
+	Resource: "certificaterequests",
+}
+
+func TestMutate(t *testing.T) {
+	plugin := NewPlugin().(*certificateRequestIdentity)
+	cr := &certmanager.CertificateRequest{}
+	err := plugin.Mutate(context.Background(), admissionv1.AdmissionRequest{
+		Operation: admissionv1.Create,
+		RequestResource: &metav1.GroupVersionResource{
+			Group:    "cert-manager.io",
+			Version:  "v1",
+			Resource: "certificaterequests",
+		},
+		UserInfo: authenticationv1.UserInfo{
+			Username: "testuser",
+			UID:      "testuid",
+			Groups:   []string{"testgroup"},
+			Extra: map[string]authenticationv1.ExtraValue{
+				"testkey": []string{"testvalue"},
+			},
+		}}, cr)
+	if err != nil {
+		t.Errorf("unexpected error: %v", err)
+	}
+
+	if cr.Spec.Username != "testuser" {
+		t.Errorf("unexpected username. got: %q, expected %q", cr.Spec.UID, "testuser")
+	}
+	if cr.Spec.UID != "testuid" {
+		t.Errorf("unexpected uid. got: %q, expected %q", cr.Spec.UID, "testuid")
+	}
+	if len(cr.Spec.Groups) != 1 || cr.Spec.Groups[0] != "testgroup" {
+		t.Errorf("unexpected groups. got: %q, expected %q", cr.Spec.Groups, "[testgroup]")
+	}
+	if len(cr.Spec.Extra) != 1 || len(cr.Spec.Extra["testkey"]) != 1 || cr.Spec.Extra["testkey"][0] != "testvalue" {
+		t.Errorf("unexpected uid. got: %q, expected %q", cr.Spec.Extra, "{testkey=testvalue}")
+	}
+}
+
+func TestMutate_Ignores(t *testing.T) {
+	plugin := NewPlugin().(*certificateRequestIdentity)
+	tests := map[string]struct {
+		op  admissionv1.Operation
+		gvr *metav1.GroupVersionResource
+	}{
+		"ignores if resource is not 'certificaterequests'": {
+			op: admissionv1.Create,
+			gvr: &metav1.GroupVersionResource{
+				Group:    "cert-manager.io",
+				Version:  "v1",
+				Resource: "not-certificaterequests",
+			},
+		},
+		"ignores if group is not 'cert-manager.io'": {
+			op: admissionv1.Create,
+			gvr: &metav1.GroupVersionResource{
+				Group:    "not-cert-manager.io",
+				Version:  "v1",
+				Resource: "certificaterequests",
+			},
+		},
+		"ignores if operation is not Create": {
+			op: admissionv1.Update,
+			gvr: &metav1.GroupVersionResource{
+				Group:    "cert-manager.io",
+				Version:  "v1",
+				Resource: "certificaterequests",
+			},
+		},
+	}
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			cr := &certmanager.CertificateRequest{}
+			err := plugin.Mutate(context.Background(), admissionv1.AdmissionRequest{
+				Operation:       test.op,
+				RequestResource: test.gvr,
+				UserInfo: authenticationv1.UserInfo{
+					Username: "testuser",
+					UID:      "testuid",
+					Groups:   []string{"testgroup"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"testkey": []string{"testvalue"},
+					},
+				}}, cr)
+			if err != nil {
+				t.Errorf("unexpected error: %v", err)
+			}
+			if cr.Spec.UID != "" || cr.Spec.Extra != nil || cr.Spec.Username != "" || len(cr.Spec.Groups) != 0 {
+				t.Errorf("unexpected mutation")
+			}
+		})
+	}
+}
+
+func TestValidateCreate(t *testing.T) {
+	fldPath := field.NewPath("spec")
+
+	tests := map[string]struct {
+		req   *admissionv1.AdmissionRequest
+		cr    *certmanager.CertificateRequest
+		wantE error
+		wantW []string
+	}{
+		"if identity fields don't match that of requester, should fail": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Create,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			cr: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "efg",
+					Username: "user-2",
+					Groups:   []string{"group-3", "group-4"},
+					Extra: map[string][]string{
+						"1": {"123", "456"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+			wantE: field.ErrorList{
+				field.Forbidden(fldPath.Child("uid"), "uid identity must be that of the requester"),
+				field.Forbidden(fldPath.Child("username"), "username identity must be that of the requester"),
+				field.Forbidden(fldPath.Child("groups"), "groups identity must be that of the requester"),
+				field.Forbidden(fldPath.Child("extra"), "extra identity must be that of the requester"),
+			}.ToAggregate(),
+		},
+		"if identity fields match that of requester, should pass": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Create,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			cr: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string][]string{
+						"1": {"abc", "efg"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+			wantE: nil,
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			p := NewPlugin().(*certificateRequestIdentity)
+			gotW, gotE := p.Validate(context.Background(), *test.req, nil, test.cr)
+			compareErrors(t, test.wantE, gotE)
+			if !reflect.DeepEqual(gotW, test.wantW) {
+				t.Errorf("warnings from ValidateCreate() = %v, want %v", gotW, test.wantW)
+			}
+		})
+	}
+}
+
+func compareErrors(t *testing.T, exp, act error) {
+	if exp == nil && act == nil {
+		return
+	}
+	if exp == nil && act != nil ||
+		exp != nil && act == nil ||
+		exp.Error() != act.Error() {
+		t.Errorf("error not as expected. exp=%v, act=%v", exp, act)
+	}
+}
+
+func TestValidateUpdate(t *testing.T) {
+	fldPath := field.NewPath("spec")
+
+	tests := map[string]struct {
+		req          *admissionv1.AdmissionRequest
+		oldCR, newCR *certmanager.CertificateRequest
+		wantE        error
+		wantW        []string
+	}{
+		"if identity fields don't match that of the old CertificateRequest, should fail": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Update,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			oldCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string][]string{
+						"1": {"abc", "efg"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+			newCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "efg",
+					Username: "user-2",
+					Groups:   []string{"group-3", "group-4"},
+					Extra: map[string][]string{
+						"1": {"123", "456"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+			wantE: field.ErrorList{
+				field.Forbidden(fldPath.Child("uid"), "uid identity cannot be changed once set"),
+				field.Forbidden(fldPath.Child("username"), "username identity cannot be changed once set"),
+				field.Forbidden(fldPath.Child("groups"), "groups identity cannot be changed once set"),
+				field.Forbidden(fldPath.Child("extra"), "extra identity cannot be changed once set"),
+			}.ToAggregate(),
+		},
+		"if identity fields match that of requester, should pass": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Update,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			oldCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string][]string{
+						"1": {"abc", "efg"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+			newCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string][]string{
+						"1": {"abc", "efg"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+			wantE: nil,
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			p := NewPlugin().(*certificateRequestIdentity)
+			gotW, gotE := p.Validate(context.Background(), *test.req, test.oldCR, test.newCR)
+			compareErrors(t, test.wantE, gotE)
+			if !reflect.DeepEqual(gotW, test.wantW) {
+				t.Errorf("warnings from ValidateUpdate() = %v, want %v", gotW, test.wantW)
+			}
+		})
+	}
+}
+
+func TestMutateCreate(t *testing.T) {
+	tests := map[string]struct {
+		req                    *admissionv1.AdmissionRequest
+		existingCR, expectedCR *certmanager.CertificateRequest
+	}{
+		"should set the identity of CertificateRequest to that of the requester": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Create,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			existingCR: new(certmanager.CertificateRequest),
+			expectedCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string][]string{
+						"1": {"abc", "efg"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+		},
+		"should overwrite user info fields if already present during a CREATE operation": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Create,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			existingCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "1234",
+					Username: "user-2",
+					Groups:   []string{"group-3", "group-4"},
+					Extra: map[string][]string{
+						"3": {"abc", "efg"},
+						"4": {"efg", "abc"},
+					},
+				},
+			},
+			expectedCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string][]string{
+						"1": {"abc", "efg"},
+						"2": {"efg", "abc"},
+					},
+				},
+			},
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			cr := test.existingCR.DeepCopy()
+			p := NewPlugin().(*certificateRequestIdentity)
+			if err := p.Mutate(context.Background(), *test.req, cr); err != nil {
+				t.Errorf("unexpected error: %v", err)
+			}
+			if !reflect.DeepEqual(test.expectedCR, cr) {
+				t.Errorf("MutateCreate() = %v, want %v", cr, test.expectedCR)
+			}
+		})
+	}
+}
+
+func TestMutateUpdate(t *testing.T) {
+	tests := map[string]struct {
+		req                    *admissionv1.AdmissionRequest
+		existingCR, expectedCR *certmanager.CertificateRequest
+	}{
+		"should not overwrite user info fields during an Update operation": {
+			req: &admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Update,
+				RequestResource: correctRequestResource,
+				UserInfo: authenticationv1.UserInfo{
+					UID:      "abc",
+					Username: "user-1",
+					Groups:   []string{"group-1", "group-2"},
+					Extra: map[string]authenticationv1.ExtraValue{
+						"1": []string{"abc", "efg"},
+						"2": []string{"efg", "abc"},
+					},
+				},
+			},
+			existingCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "1234",
+					Username: "user-2",
+					Groups:   []string{"group-3", "group-4"},
+					Extra: map[string][]string{
+						"3": {"abc", "efg"},
+						"4": {"efg", "abc"},
+					},
+				},
+			},
+			expectedCR: &certmanager.CertificateRequest{
+				Spec: certmanager.CertificateRequestSpec{
+					UID:      "1234",
+					Username: "user-2",
+					Groups:   []string{"group-3", "group-4"},
+					Extra: map[string][]string{
+						"3": {"abc", "efg"},
+						"4": {"efg", "abc"},
+					},
+				},
+			},
+		},
+	}
+
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			cr := test.existingCR.DeepCopy()
+			p := NewPlugin().(*certificateRequestIdentity)
+			if err := p.Mutate(context.Background(), *test.req, cr); err != nil {
+				t.Errorf("unexpected error: %v", err)
+			}
+			if !reflect.DeepEqual(test.expectedCR, cr) {
+				t.Errorf("MutateCreate() = %v, want %v", cr, test.expectedCR)
+			}
+		})
+	}
+}
diff --git a/internal/api/validation/BUILD.bazel b/internal/plugin/admission/resourcevalidation/BUILD.bazel
similarity index 63%
rename from internal/api/validation/BUILD.bazel
rename to internal/plugin/admission/resourcevalidation/BUILD.bazel
index a56cc67ef..380418705 100644
--- a/internal/api/validation/BUILD.bazel
+++ b/internal/plugin/admission/resourcevalidation/BUILD.bazel
@@ -2,32 +2,18 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 
 go_library(
     name = "go_default_library",
-    srcs = [
-        "registry.go",
-        "warning.go",
-    ],
-    importpath = "github.com/jetstack/cert-manager/internal/api/validation",
+    srcs = ["resourcevalidation.go"],
+    importpath = "github.com/jetstack/cert-manager/internal/plugin/admission/resourcevalidation",
     visibility = ["//:__subpackages__"],
     deps = [
-        "@io_k8s_api//admission/v1:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
-        "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
-    ],
-)
-
-go_test(
-    name = "go_default_test",
-    srcs = ["registry_test.go"],
-    deps = [
-        ":go_default_library",
-        "//internal/apis/certmanager:go_default_library",
+        "//internal/apis/acme/validation:go_default_library",
+        "//internal/apis/certmanager/validation:go_default_library",
+        "//pkg/apis/acme/v1:go_default_library",
         "//pkg/apis/certmanager/v1:go_default_library",
-        "//pkg/webhook:go_default_library",
+        "//pkg/webhook/admission:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
-        "@io_k8s_api//core/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
-        "@io_k8s_apimachinery//pkg/util/runtime:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
     ],
 )
@@ -45,3 +31,16 @@ filegroup(
     tags = ["automanaged"],
     visibility = ["//visibility:public"],
 )
+
+go_test(
+    name = "go_default_test",
+    srcs = ["resourcevalidation_test.go"],
+    embed = [":go_default_library"],
+    deps = [
+        "@io_k8s_api//admission/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
+    ],
+)
diff --git a/internal/plugin/admission/resourcevalidation/resourcevalidation.go b/internal/plugin/admission/resourcevalidation/resourcevalidation.go
new file mode 100644
index 000000000..cbe61e37c
--- /dev/null
+++ b/internal/plugin/admission/resourcevalidation/resourcevalidation.go
@@ -0,0 +1,113 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package resourcevalidation
+
+import (
+	"context"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+
+	acmevalidation "github.com/jetstack/cert-manager/internal/apis/acme/validation"
+	cmvalidation "github.com/jetstack/cert-manager/internal/apis/certmanager/validation"
+	acmev1 "github.com/jetstack/cert-manager/pkg/apis/acme/v1"
+	certmanagerv1 "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
+	admission "github.com/jetstack/cert-manager/pkg/webhook/admission"
+)
+
+const PluginName = "ResourceValidation"
+
+type resourceValidation struct {
+	*admission.Handler
+
+	validationMappings map[schema.GroupVersionResource]validationPair
+}
+
+// Register registers a plugin
+func Register(plugins *admission.Plugins) {
+	plugins.Register(PluginName, func() (admission.Interface, error) {
+		return NewPlugin(), nil
+	})
+}
+
+var _ admission.ValidationInterface = &resourceValidation{}
+
+var certificateGVR = certmanagerv1.SchemeGroupVersion.WithResource("certificates")
+var certificateRequestGVR = certmanagerv1.SchemeGroupVersion.WithResource("certificaterequests")
+var issuerGVR = certmanagerv1.SchemeGroupVersion.WithResource("issuers")
+var clusterIssuerGVR = certmanagerv1.SchemeGroupVersion.WithResource("clusterissuers")
+var orderGVR = acmev1.SchemeGroupVersion.WithResource("orders")
+var challengeGVR = acmev1.SchemeGroupVersion.WithResource("challenges")
+
+type validateCreateFunc func(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string)
+type validateUpdateFunc func(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, []string)
+
+type validationPair struct {
+	create validateCreateFunc
+	update validateUpdateFunc
+}
+
+func newValidationPair(create validateCreateFunc, update validateUpdateFunc) validationPair {
+	return validationPair{create: create, update: update}
+}
+
+var validationMapping = map[schema.GroupVersionResource]validationPair{
+	certificateGVR:        newValidationPair(cmvalidation.ValidateCertificate, cmvalidation.ValidateUpdateCertificate),
+	certificateRequestGVR: newValidationPair(cmvalidation.ValidateCertificateRequest, cmvalidation.ValidateUpdateCertificateRequest),
+	issuerGVR:             newValidationPair(cmvalidation.ValidateIssuer, cmvalidation.ValidateUpdateIssuer),
+	clusterIssuerGVR:      newValidationPair(cmvalidation.ValidateClusterIssuer, cmvalidation.ValidateUpdateClusterIssuer),
+	orderGVR:              newValidationPair(acmevalidation.ValidateOrder, acmevalidation.ValidateOrderUpdate),
+	challengeGVR:          newValidationPair(acmevalidation.ValidateChallenge, acmevalidation.ValidateChallengeUpdate),
+}
+
+func NewPlugin() admission.Interface {
+	return &resourceValidation{
+		Handler: admission.NewHandler(admissionv1.Create, admissionv1.Update),
+	}
+}
+
+func (p resourceValidation) Validate(_ context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+	requestResource := schema.GroupVersionResource{
+		Group:    request.RequestResource.Group,
+		Version:  request.RequestResource.Version,
+		Resource: request.RequestResource.Resource,
+	}
+
+	pair, ok := validationMapping[requestResource]
+	if !ok {
+		return nil, nil
+	}
+
+	switch request.Operation {
+	case admissionv1.Create:
+		if pair.create == nil {
+			return nil, nil
+		}
+		errs, warnings := pair.create(&request, obj)
+		return warnings, errs.ToAggregate()
+	case admissionv1.Update:
+		if pair.update == nil {
+			return nil, nil
+		}
+		errs, warnings := pair.update(&request, oldObj, obj)
+		return warnings, errs.ToAggregate()
+	}
+
+	return nil, nil
+}
diff --git a/internal/plugin/admission/resourcevalidation/resourcevalidation_test.go b/internal/plugin/admission/resourcevalidation/resourcevalidation_test.go
new file mode 100644
index 000000000..0c8cbedfa
--- /dev/null
+++ b/internal/plugin/admission/resourcevalidation/resourcevalidation_test.go
@@ -0,0 +1,104 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package resourcevalidation
+
+import (
+	"context"
+	"reflect"
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/util/validation/field"
+)
+
+var (
+	sampleSchemaGVR = schema.GroupVersionResource{
+		Group:    "sample-group",
+		Version:  "sample-version",
+		Resource: "sample-resource",
+	}
+	sampleMetaGVR = metav1.GroupVersionResource{
+		Group:    sampleSchemaGVR.Group,
+		Version:  sampleSchemaGVR.Version,
+		Resource: sampleSchemaGVR.Resource,
+	}
+
+	alwaysFailsCreateFunc = func(a *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
+		panic("create function not expected to be called")
+	}
+	alwaysFailsUpdateFunc = func(a *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (field.ErrorList, []string) {
+		panic("update function not expected to be called")
+	}
+
+	alwaysFailsValidationPair = validationPair{
+		create: alwaysFailsCreateFunc,
+		update: alwaysFailsUpdateFunc,
+	}
+)
+
+func TestResourceValidation(t *testing.T) {
+	tests := map[string]struct {
+		mapping     map[schema.GroupVersionResource]validationPair
+		req         admissionv1.AdmissionRequest
+		oldObj, obj runtime.Object
+
+		expectedWarnings []string
+		expectedError    error
+	}{
+		"should not perform any validation if no validation functions are registered": {
+			mapping: map[schema.GroupVersionResource]validationPair{},
+			req: admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Create,
+				RequestResource: &sampleMetaGVR,
+			},
+		},
+		"does nothing for non-create or update operations": {
+			mapping: map[schema.GroupVersionResource]validationPair{
+				sampleSchemaGVR: alwaysFailsValidationPair,
+			},
+			req: admissionv1.AdmissionRequest{
+				Operation:       admissionv1.Connect,
+				RequestResource: &sampleMetaGVR,
+			},
+		},
+	}
+	for name, test := range tests {
+		t.Run(name, func(t *testing.T) {
+			p := NewPlugin().(*resourceValidation)
+			p.validationMappings = test.mapping
+			warnings, err := p.Validate(context.Background(), test.req, test.oldObj, test.obj)
+			compareErrors(t, test.expectedError, err)
+			if !reflect.DeepEqual(test.expectedWarnings, warnings) {
+				t.Errorf("unexpected warnings. exp=%v, got=%v", test.expectedWarnings, warnings)
+			}
+		})
+	}
+}
+
+func compareErrors(t *testing.T, exp, act error) {
+	if exp == nil && act == nil {
+		return
+	}
+	if exp == nil && act != nil ||
+		exp != nil && act == nil ||
+		exp.Error() != act.Error() {
+		t.Errorf("error not as expected. exp=%v, act=%v", exp, act)
+	}
+}
diff --git a/internal/plugin/plugins.go b/internal/plugin/plugins.go
new file mode 100644
index 000000000..199fdbe29
--- /dev/null
+++ b/internal/plugin/plugins.go
@@ -0,0 +1,54 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package plugin
+
+import (
+	"github.com/jetstack/cert-manager/internal/plugin/admission/apideprecation"
+	certificaterequestapproval "github.com/jetstack/cert-manager/internal/plugin/admission/certificaterequest/approval"
+	certificaterequestidentity "github.com/jetstack/cert-manager/internal/plugin/admission/certificaterequest/identity"
+	"github.com/jetstack/cert-manager/internal/plugin/admission/resourcevalidation"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"k8s.io/apimachinery/pkg/util/sets"
+)
+
+var AllOrderedPlugins = []string{
+	apideprecation.PluginName,
+	resourcevalidation.PluginName,
+	certificaterequestidentity.PluginName,
+	certificaterequestapproval.PluginName,
+}
+
+func RegisterAllPlugins(plugins *admission.Plugins) {
+	apideprecation.Register(plugins)
+	certificaterequestidentity.Register(plugins)
+	certificaterequestapproval.Register(plugins)
+	resourcevalidation.Register(plugins)
+}
+
+func DefaultOnAdmissionPlugins() sets.String {
+	return sets.NewString(
+		apideprecation.PluginName,
+		resourcevalidation.PluginName,
+		certificaterequestidentity.PluginName,
+		certificaterequestapproval.PluginName,
+	)
+}
+
+// DefaultOffAdmissionPlugins gets admission plugins off by default for the webhook.
+func DefaultOffAdmissionPlugins() sets.String {
+	return sets.NewString(AllOrderedPlugins...).Difference(DefaultOnAdmissionPlugins())
+}
diff --git a/internal/webhook/BUILD.bazel b/internal/webhook/BUILD.bazel
new file mode 100644
index 000000000..35dc0e2e9
--- /dev/null
+++ b/internal/webhook/BUILD.bazel
@@ -0,0 +1,50 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "scheme.go",
+        "webhook.go",
+    ],
+    importpath = "github.com/jetstack/cert-manager/internal/webhook",
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//cmd/webhook/app/options:go_default_library",
+        "//internal/apis/acme/install:go_default_library",
+        "//internal/apis/certmanager/install:go_default_library",
+        "//internal/apis/config/webhook:go_default_library",
+        "//internal/apis/meta/install:go_default_library",
+        "//internal/plugin:go_default_library",
+        "//pkg/logs:go_default_library",
+        "//pkg/webhook/admission:go_default_library",
+        "//pkg/webhook/admission/initializer:go_default_library",
+        "//pkg/webhook/authority:go_default_library",
+        "//pkg/webhook/handlers:go_default_library",
+        "//pkg/webhook/server:go_default_library",
+        "//pkg/webhook/server/tls:go_default_library",
+        "@com_github_go_logr_logr//:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/wait:go_default_library",
+        "@io_k8s_apiserver//pkg/authorization/authorizerfactory:go_default_library",
+        "@io_k8s_client_go//kubernetes:go_default_library",
+        "@io_k8s_client_go//rest:go_default_library",
+        "@io_k8s_client_go//tools/clientcmd:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [
+        ":package-srcs",
+        "//internal/webhook/feature:all-srcs",
+    ],
+    tags = ["automanaged"],
+    visibility = ["//visibility:public"],
+)
diff --git a/internal/webhook/scheme.go b/internal/webhook/scheme.go
new file mode 100644
index 000000000..81db12036
--- /dev/null
+++ b/internal/webhook/scheme.go
@@ -0,0 +1,34 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package webhook
+
+import (
+	"k8s.io/apimachinery/pkg/runtime"
+)
+
+// Define a Scheme that has all cert-manager API types registered, including
+// the internal API version, defaulting functions and conversion functions for
+// all external versions.
+// This scheme should *only* be used by the webhook as the conversion/defaulter
+// functions are likely to change in the future.
+
+var (
+	// Scheme is a Kubernetes runtime.Scheme with all internal and external API
+	// versions for cert-manager types registered.
+	// TODO: this type should not be exported
+	Scheme = runtime.NewScheme()
+)
diff --git a/internal/webhook/webhook.go b/internal/webhook/webhook.go
new file mode 100644
index 000000000..13c7120d1
--- /dev/null
+++ b/internal/webhook/webhook.go
@@ -0,0 +1,148 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package webhook
+
+import (
+	"fmt"
+	"time"
+
+	"github.com/go-logr/logr"
+	"k8s.io/apimachinery/pkg/util/wait"
+	"k8s.io/apiserver/pkg/authorization/authorizerfactory"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/rest"
+	"k8s.io/client-go/tools/clientcmd"
+
+	"github.com/jetstack/cert-manager/cmd/webhook/app/options"
+	acmeinstall "github.com/jetstack/cert-manager/internal/apis/acme/install"
+	cminstall "github.com/jetstack/cert-manager/internal/apis/certmanager/install"
+	config "github.com/jetstack/cert-manager/internal/apis/config/webhook"
+	metainstall "github.com/jetstack/cert-manager/internal/apis/meta/install"
+	"github.com/jetstack/cert-manager/internal/plugin"
+	logf "github.com/jetstack/cert-manager/pkg/logs"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission/initializer"
+	"github.com/jetstack/cert-manager/pkg/webhook/authority"
+	"github.com/jetstack/cert-manager/pkg/webhook/handlers"
+	"github.com/jetstack/cert-manager/pkg/webhook/server"
+	"github.com/jetstack/cert-manager/pkg/webhook/server/tls"
+)
+
+var conversionHook handlers.ConversionHook = handlers.NewSchemeBackedConverter(logf.Log, Scheme)
+
+// WithConversionHandler allows you to override the handler for the `/convert`
+// endpoint in tests.
+func WithConversionHandler(handler handlers.ConversionHook) func(*server.Server) {
+	return func(s *server.Server) {
+		s.ConversionWebhook = handler
+	}
+}
+
+// NewCertManagerWebhookServer creates a new webhook server configured with all cert-manager
+// resource types, validation, defaulting and conversion functions.
+func NewCertManagerWebhookServer(log logr.Logger, _ options.WebhookFlags, opts config.WebhookConfiguration, optionFunctions ...func(*server.Server)) (*server.Server, error) {
+	restcfg, err := clientcmd.BuildConfigFromFlags(opts.APIServerHost, opts.KubeConfig)
+	if err != nil {
+		return nil, err
+	}
+
+	cl, err := kubernetes.NewForConfig(restcfg)
+	if err != nil {
+		return nil, fmt.Errorf("error creating kubernetes client: %s", err)
+	}
+
+	// Set up the admission chain
+	admissionHandler, err := buildAdmissionChain(cl)
+	if err != nil {
+		return nil, err
+	}
+
+	s := &server.Server{
+		ListenAddr:        fmt.Sprintf(":%d", *opts.SecurePort),
+		HealthzAddr:       fmt.Sprintf(":%d", *opts.HealthzPort),
+		EnablePprof:       opts.EnablePprof,
+		PprofAddr:         opts.PprofAddress,
+		CertificateSource: buildCertificateSource(log, opts.TLSConfig, restcfg),
+		CipherSuites:      opts.TLSConfig.CipherSuites,
+		MinTLSVersion:     opts.TLSConfig.MinTLSVersion,
+		ValidationWebhook: admissionHandler,
+		MutationWebhook:   admissionHandler,
+		ConversionWebhook: conversionHook,
+	}
+	for _, fn := range optionFunctions {
+		fn(s)
+	}
+	return s, nil
+}
+
+func buildAdmissionChain(client kubernetes.Interface) (*admission.RequestHandler, error) {
+	// Set up the admission chain
+	pluginHandler := admission.NewPlugins(Scheme)
+	plugin.RegisterAllPlugins(pluginHandler)
+	authorizer, err := authorizerfactory.DelegatingAuthorizerConfig{
+		SubjectAccessReviewClient: client.AuthorizationV1(),
+		// cache responses for 1 second
+		AllowCacheTTL: time.Second,
+		DenyCacheTTL:  time.Second,
+		WebhookRetryBackoff: &wait.Backoff{
+			Duration: time.Second,
+			Factor:   2,
+			Jitter:   0.2,
+			Steps:    2,
+			Cap:      time.Second * 5,
+		},
+	}.New()
+	if err != nil {
+		return nil, fmt.Errorf("error creating authorization handler: %v", err)
+	}
+	pluginInitializer := initializer.New(client, nil, authorizer, nil)
+	pluginChain, err := pluginHandler.NewFromPlugins(plugin.DefaultOnAdmissionPlugins().List(), pluginInitializer)
+	if err != nil {
+		return nil, fmt.Errorf("error building admission chain: %v", err)
+	}
+	return admission.NewRequestHandler(Scheme, pluginChain.(admission.ValidationInterface), pluginChain.(admission.MutationInterface)), nil
+}
+
+func buildCertificateSource(log logr.Logger, tlsConfig config.TLSConfig, restCfg *rest.Config) tls.CertificateSource {
+	switch {
+	case tlsConfig.FilesystemConfigProvided():
+		log.V(logf.InfoLevel).Info("using TLS certificate from local filesystem", "private_key_path", tlsConfig.Filesystem.KeyFile, "certificate", tlsConfig.Filesystem.CertFile)
+		return &tls.FileCertificateSource{
+			CertPath: tlsConfig.Filesystem.CertFile,
+			KeyPath:  tlsConfig.Filesystem.KeyFile,
+		}
+	case tlsConfig.DynamicConfigProvided():
+		log.V(logf.InfoLevel).Info("using dynamic certificate generating using CA stored in Secret resource", "secret_namespace", tlsConfig.Dynamic.SecretNamespace, "secret_name", tlsConfig.Dynamic.SecretName)
+		return &tls.DynamicSource{
+			DNSNames: tlsConfig.Dynamic.DNSNames,
+			Authority: &authority.DynamicAuthority{
+				SecretNamespace: tlsConfig.Dynamic.SecretNamespace,
+				SecretName:      tlsConfig.Dynamic.SecretName,
+				RESTConfig:      restCfg,
+			},
+		}
+	default:
+		log.V(logf.WarnLevel).Info("serving insecurely as tls certificate data not provided")
+	}
+	return nil
+}
+
+func init() {
+	cminstall.Install(Scheme)
+	acmeinstall.Install(Scheme)
+	metainstall.Install(Scheme)
+}
diff --git a/pkg/issuer/acme/http/ingress.go b/pkg/issuer/acme/http/ingress.go
index c94ddc384..6221aa33b 100644
--- a/pkg/issuer/acme/http/ingress.go
+++ b/pkg/issuer/acme/http/ingress.go
@@ -33,6 +33,14 @@ import (
 	logf "github.com/jetstack/cert-manager/pkg/logs"
 )
 
+const (
+	// annotationIngressClass is the well-known annotation key
+	// for specifying ingress classes. It is currently not specified
+	// in the networking/v1 package, so it is duplicated here
+	// to avoid an extra import of networking/v1beta1.
+	annotationIngressClass = "kubernetes.io/ingress.class"
+)
+
 // getIngressesForChallenge returns a list of Ingresses that were created to solve
 // http challenges for the given domain
 func (s *Solver) getIngressesForChallenge(ctx context.Context, ch *cmacme.Challenge) ([]*networkingv1.Ingress, error) {
@@ -137,10 +145,6 @@ func buildIngressResource(ch *cmacme.Challenge, svcName string) (*networkingv1.I
 	if err != nil {
 		return nil, err
 	}
-	var ingClass *string
-	if http01IngressCfg.Class != nil {
-		ingClass = http01IngressCfg.Class
-	}
 
 	podLabels := podLabels(ch)
 
@@ -149,6 +153,15 @@ func buildIngressResource(ch *cmacme.Challenge, svcName string) (*networkingv1.I
 	// TODO: Figure out how to remove this without breaking users who depend on it.
 	ingAnnotations["nginx.ingress.kubernetes.io/whitelist-source-range"] = "0.0.0.0/0,::/0"
 
+	// Use the Ingress Class annotation defined in networkingv1beta1 even though our Ingress objects
+	// are networkingv1, for maximum compatibility with all Ingress controllers.
+	// if the `kubernetes.io/ingress.class` annotation is present, it takes precedence over the
+	// `spec.IngressClassName` field.
+	// See discussion in https://github.com/jetstack/cert-manager/issues/4537.
+	if http01IngressCfg.Class != nil {
+		ingAnnotations[annotationIngressClass] = *http01IngressCfg.Class
+	}
+
 	ingPathToAdd := ingressPath(ch.Spec.Token, svcName)
 
 	httpHost := ch.Spec.DNSName
@@ -165,7 +178,8 @@ func buildIngressResource(ch *cmacme.Challenge, svcName string) (*networkingv1.I
 			OwnerReferences: []metav1.OwnerReference{*metav1.NewControllerRef(ch, challengeGvk)},
 		},
 		Spec: networkingv1.IngressSpec{
-			IngressClassName: ingClass,
+			// https://github.com/jetstack/cert-manager/issues/4537
+			IngressClassName: nil,
 			Rules: []networkingv1.IngressRule{
 				{
 					Host: httpHost,
diff --git a/pkg/issuer/acme/http/ingress_test.go b/pkg/issuer/acme/http/ingress_test.go
index 99dfa853c..e3447b856 100644
--- a/pkg/issuer/acme/http/ingress_test.go
+++ b/pkg/issuer/acme/http/ingress_test.go
@@ -533,6 +533,7 @@ func TestMergeIngressObjectMetaWithIngressResourceTemplate(t *testing.T) {
 					"nginx.ingress.kubernetes.io/whitelist-source-range":  "0.0.0.0/0,::/0",
 					"nginx.org/mergeable-ingress-type":                    "minion",
 					"traefik.ingress.kubernetes.io/frontend-entry-points": "http",
+					"kubernetes.io/ingress.class":                         "nginx",
 				}
 				s.testResources[createdIngressKey] = expectedIngress
 				s.Builder.Sync()
diff --git a/pkg/webhook/BUILD.bazel b/pkg/webhook/BUILD.bazel
index 033dd304d..d96d339b5 100644
--- a/pkg/webhook/BUILD.bazel
+++ b/pkg/webhook/BUILD.bazel
@@ -1,20 +1,3 @@
-load("@io_bazel_rules_go//go:def.bzl", "go_library")
-
-go_library(
-    name = "go_default_library",
-    srcs = ["scheme.go"],
-    importpath = "github.com/jetstack/cert-manager/pkg/webhook",
-    visibility = ["//visibility:public"],
-    deps = [
-        "//internal/api/mutation:go_default_library",
-        "//internal/api/validation:go_default_library",
-        "//internal/apis/acme/install:go_default_library",
-        "//internal/apis/certmanager/install:go_default_library",
-        "//internal/apis/meta/install:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
-    ],
-)
-
 filegroup(
     name = "package-srcs",
     srcs = glob(["**"]),
@@ -26,6 +9,7 @@ filegroup(
     name = "all-srcs",
     srcs = [
         ":package-srcs",
+        "//pkg/webhook/admission:all-srcs",
         "//pkg/webhook/authority:all-srcs",
         "//pkg/webhook/configfile:all-srcs",
         "//pkg/webhook/handlers:all-srcs",
diff --git a/pkg/webhook/admission/BUILD.bazel b/pkg/webhook/admission/BUILD.bazel
new file mode 100644
index 000000000..daf8e4de9
--- /dev/null
+++ b/pkg/webhook/admission/BUILD.bazel
@@ -0,0 +1,69 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "chain.go",
+        "handler.go",
+        "interfaces.go",
+        "plugins.go",
+        "request_handler.go",
+    ],
+    importpath = "github.com/jetstack/cert-manager/pkg/webhook/admission",
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//pkg/webhook/handlers:go_default_library",
+        "@io_k8s_api//admission/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime/serializer:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime/serializer/json:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/errors:go_default_library",
+        "@io_k8s_apimachinery//pkg/util/sets:go_default_library",
+        "@xyz_gomodules_jsonpatch_v2//:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [
+        ":package-srcs",
+        "//pkg/webhook/admission/initializer:all-srcs",
+    ],
+    tags = ["automanaged"],
+    visibility = ["//visibility:public"],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = [
+        "chain_test.go",
+        "handler_test.go",
+        "plugins_test.go",
+        "request_handler_test.go",
+        "util_test.go",
+    ],
+    embed = [":go_default_library"],
+    deps = [
+        "//pkg/webhook/admission/initializer:go_default_library",
+        "//pkg/webhook/handlers/testdata/apis/testgroup:go_default_library",
+        "//pkg/webhook/handlers/testdata/apis/testgroup/install:go_default_library",
+        "//pkg/webhook/handlers/testdata/apis/testgroup/v1:go_default_library",
+        "@io_k8s_api//admission/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
+        "@io_k8s_apimachinery//pkg/types:go_default_library",
+        "@io_k8s_client_go//kubernetes:go_default_library",
+        "@io_k8s_client_go//kubernetes/fake:go_default_library",
+        "@io_k8s_utils//diff:go_default_library",
+        "@xyz_gomodules_jsonpatch_v2//:go_default_library",
+    ],
+)
diff --git a/pkg/webhook/admission/chain.go b/pkg/webhook/admission/chain.go
new file mode 100644
index 000000000..68025c89a
--- /dev/null
+++ b/pkg/webhook/admission/chain.go
@@ -0,0 +1,70 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission
+
+import (
+	"context"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	utilerrors "k8s.io/apimachinery/pkg/util/errors"
+)
+
+type PluginChain []Interface
+
+var _ Interface = PluginChain(nil)
+var _ ValidationInterface = PluginChain(nil)
+var _ MutationInterface = PluginChain(nil)
+
+func (pc PluginChain) Handles(operation admissionv1.Operation) bool {
+	for _, plugin := range pc {
+		if plugin.Handles(operation) {
+			return true
+		}
+	}
+	return false
+}
+
+func (pc PluginChain) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+	var allWarnings []string
+	var allErrors []error
+	for _, handler := range pc {
+		if !handler.Handles(request.Operation) {
+			continue
+		}
+		if validator, ok := handler.(ValidationInterface); ok {
+			warnings, err := validator.Validate(ctx, request, oldObj, obj)
+			allErrors = append(allErrors, err)
+			allWarnings = append(allWarnings, warnings...)
+		}
+	}
+	return allWarnings, utilerrors.NewAggregate(allErrors)
+}
+
+func (pc PluginChain) Mutate(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+	for _, handler := range pc {
+		if !handler.Handles(request.Operation) {
+			continue
+		}
+		if mutator, ok := handler.(MutationInterface); ok {
+			if err := mutator.Mutate(ctx, request, obj); err != nil {
+				return err
+			}
+		}
+	}
+	return nil
+}
diff --git a/pkg/webhook/admission/chain_test.go b/pkg/webhook/admission/chain_test.go
new file mode 100644
index 000000000..ca9185972
--- /dev/null
+++ b/pkg/webhook/admission/chain_test.go
@@ -0,0 +1,178 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission_test
+
+import (
+	"context"
+	"fmt"
+	"reflect"
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v1"
+)
+
+func TestChainHandles(t *testing.T) {
+	pc := admission.PluginChain([]admission.Interface{
+		// this handler should be called
+		validatingImplementation{handles: handles(true).Handles},
+		validatingImplementation{handles: handles(false).Handles},
+	})
+	// actual operation passed here does not matter
+	if !pc.Handles(admissionv1.Create) {
+		t.Errorf("expected handler to handle this request but it did not")
+	}
+}
+
+func TestChainDoesntHandle(t *testing.T) {
+	pc := admission.PluginChain([]admission.Interface{
+		// this handler should be called
+		validatingImplementation{handles: handles(false).Handles},
+		validatingImplementation{handles: handles(false).Handles},
+	})
+	// actual operation passed here does not matter
+	if pc.Handles(admissionv1.Create) {
+		t.Errorf("expected handler to not handle this message but it did")
+	}
+}
+
+func TestChainValidate(t *testing.T) {
+	validateCalled := false
+	pc := admission.PluginChain([]admission.Interface{
+		// this handler should be called
+		validatingImplementation{
+			handles: handles(true).Handles,
+			validate: func(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+				validateCalled = true
+				return []string{"warning1", "warning2"}, nil
+			},
+		},
+		// it's not expected that this handler will be called
+		validatingImplementation{
+			// this handler explicitly does not handle the call
+			handles: handles(false).Handles,
+			validate: func(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+				t.Errorf("second validation function was unexpectedly called during a validate call")
+				return []string{"warning3", "warning4"}, nil
+			},
+		},
+		// this handler should be called
+		validatingImplementation{
+			handles: handles(true).Handles,
+			validate: func(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+				return []string{"warning5"}, nil
+			},
+		},
+		mutatingImplementation{
+			handles: handles(true).Handles,
+			mutate: func(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+				t.Errorf("mutate function was unexpectedly called during a validate call")
+				return fmt.Errorf("unexpected error")
+			},
+		},
+	})
+	warnings, err := pc.Validate(context.Background(), admissionv1.AdmissionRequest{}, nil, nil)
+	if err != nil {
+		t.Errorf("unexpected error: %v", err)
+	}
+	if !validateCalled {
+		t.Errorf("validation function was not called")
+	}
+	if !reflect.DeepEqual(warnings, []string{"warning1", "warning2", "warning5"}) {
+		t.Errorf("got unexpected list of warnings: %v", warnings)
+	}
+}
+
+func TestChainValidate_Fails(t *testing.T) {
+	pc := admission.PluginChain([]admission.Interface{
+		// this handler should be called
+		validatingImplementation{
+			handles: handles(true).Handles,
+			validate: func(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+				return []string{"warning1", "warning2"}, fmt.Errorf("error")
+			},
+		},
+		// this handler should be called
+		validatingImplementation{
+			handles: handles(true).Handles,
+			validate: func(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error) {
+				return []string{"warning5"}, nil
+			},
+		},
+	})
+	warnings, err := pc.Validate(context.Background(), admissionv1.AdmissionRequest{}, nil, nil)
+	if err == nil {
+		t.Errorf("didn't get an error when one was expected")
+	}
+	if !reflect.DeepEqual(warnings, []string{"warning1", "warning2", "warning5"}) {
+		t.Errorf("got unexpected list of warnings: %v", warnings)
+	}
+}
+
+func TestChainMutate(t *testing.T) {
+	pc := admission.PluginChain([]admission.Interface{
+		// this handler should be called
+		mutatingImplementation{
+			handles: handles(true).Handles,
+			mutate: func(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+				tt := obj.(*v1.TestType)
+				tt.TestField = "testvalue"
+				return nil
+			},
+		},
+		// this handler should not be called
+		mutatingImplementation{
+			handles: handles(false).Handles,
+			mutate: func(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+				tt := obj.(*v1.TestType)
+				tt.TestFieldImmutable = "hopefully-not-set"
+				return nil
+			},
+		},
+	})
+	tt := &v1.TestType{}
+	err := pc.Mutate(context.Background(), admissionv1.AdmissionRequest{}, tt)
+	if err != nil {
+		t.Errorf("unexpected error: %v", err)
+	}
+	if tt.TestField != "testvalue" {
+		t.Errorf("expected tt.TestField=testvalue but got %q", tt.TestField)
+	}
+	if tt.TestFieldImmutable != "" {
+		t.Errorf("expected tt.TestFieldImmutable to not be set, but got %q", tt.TestFieldImmutable)
+	}
+}
+
+func TestChainMutate_Fails(t *testing.T) {
+	pc := admission.PluginChain([]admission.Interface{
+		// this handler should be called and should error
+		mutatingImplementation{
+			handles: handles(true).Handles,
+			mutate: func(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+				return fmt.Errorf("error")
+			},
+		},
+	})
+	tt := &v1.TestType{}
+	err := pc.Mutate(context.Background(), admissionv1.AdmissionRequest{}, tt)
+	if err == nil {
+		t.Errorf("expected error but got none")
+	}
+}
diff --git a/internal/apis/certmanager/validation/plugins/plugins.go b/pkg/webhook/admission/handler.go
similarity index 56%
rename from internal/apis/certmanager/validation/plugins/plugins.go
rename to pkg/webhook/admission/handler.go
index a579b7d9f..119f18e19 100644
--- a/internal/apis/certmanager/validation/plugins/plugins.go
+++ b/pkg/webhook/admission/handler.go
@@ -14,25 +14,27 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */
 
-package plugins
+package admission
 
 import (
-	"context"
-
 	admissionv1 "k8s.io/api/admission/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-	"k8s.io/client-go/kubernetes"
+	"k8s.io/apimachinery/pkg/util/sets"
 )
 
-// Plugin is an admission plugin that will run during admission webhook events.
-type Plugin interface {
-	Init(client kubernetes.Interface)
-	Validate(ctx context.Context, admissionSpec *admissionv1.AdmissionRequest, oldObj, obj runtime.Object) *field.Error
+type Handler struct {
+	operations sets.String
+}
+
+func (h Handler) Handles(operation admissionv1.Operation) bool {
+	return h.operations.Has(string(operation))
 }
 
-func All(scheme *runtime.Scheme) []Plugin {
-	return []Plugin{
-		newApproval(scheme),
+var _ Interface = &Handler{}
+
+func NewHandler(ops ...admissionv1.Operation) *Handler {
+	operations := sets.NewString()
+	for _, op := range ops {
+		operations.Insert(string(op))
 	}
+	return &Handler{operations: operations}
 }
diff --git a/pkg/webhook/admission/handler_test.go b/pkg/webhook/admission/handler_test.go
new file mode 100644
index 000000000..a97f69238
--- /dev/null
+++ b/pkg/webhook/admission/handler_test.go
@@ -0,0 +1,38 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission
+
+import (
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+)
+
+var allOperations = []admissionv1.Operation{admissionv1.Update, admissionv1.Create, admissionv1.Connect, admissionv1.Delete}
+
+func TestHandler(t *testing.T) {
+	h := NewHandler(admissionv1.Create)
+	for _, op := range allOperations {
+		handles := h.Handles(op)
+		if op == admissionv1.Create && !handles {
+			t.Error("expected handler to handle CREATE but it did not")
+		}
+		if op != admissionv1.Create && handles {
+			t.Errorf("did not expect handler to handle %q", op)
+		}
+	}
+}
diff --git a/pkg/webhook/admission/initializer/BUILD.bazel b/pkg/webhook/admission/initializer/BUILD.bazel
new file mode 100644
index 000000000..95922beb2
--- /dev/null
+++ b/pkg/webhook/admission/initializer/BUILD.bazel
@@ -0,0 +1,49 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "initializer.go",
+        "interfaces.go",
+    ],
+    importpath = "github.com/jetstack/cert-manager/pkg/webhook/admission/initializer",
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//pkg/webhook/admission:go_default_library",
+        "@io_k8s_apiserver//pkg/authorization/authorizer:go_default_library",
+        "@io_k8s_apiserver//pkg/quota/v1:go_default_library",
+        "@io_k8s_client_go//informers:go_default_library",
+        "@io_k8s_client_go//kubernetes:go_default_library",
+        "@io_k8s_component_base//featuregate:go_default_library",
+    ],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = ["initializer_test.go"],
+    deps = [
+        ":go_default_library",
+        "//pkg/webhook/admission:go_default_library",
+        "@io_k8s_api//admission/v1:go_default_library",
+        "@io_k8s_apimachinery//pkg/runtime:go_default_library",
+        "@io_k8s_apiserver//pkg/authorization/authorizer:go_default_library",
+        "@io_k8s_client_go//informers:go_default_library",
+        "@io_k8s_client_go//kubernetes:go_default_library",
+        "@io_k8s_client_go//kubernetes/fake:go_default_library",
+        "@io_k8s_component_base//featuregate:go_default_library",
+    ],
+)
+
+filegroup(
+    name = "package-srcs",
+    srcs = glob(["**"]),
+    tags = ["automanaged"],
+    visibility = ["//visibility:private"],
+)
+
+filegroup(
+    name = "all-srcs",
+    srcs = [":package-srcs"],
+    tags = ["automanaged"],
+    visibility = ["//visibility:public"],
+)
diff --git a/pkg/webhook/admission/initializer/initializer.go b/pkg/webhook/admission/initializer/initializer.go
new file mode 100644
index 000000000..c0df2f97b
--- /dev/null
+++ b/pkg/webhook/admission/initializer/initializer.go
@@ -0,0 +1,73 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+/*
+Copyright 2017 The Kubernetes Authors.
+Derived from https://github.com/kubernetes/kubernetes/blob/9d0d2e8ece9bdd0cd8c23be2f36eee5473afc648/staging/src/k8s.io/apiserver/pkg/admission/initializer/initializer.go
+*/
+
+package initializer
+
+import (
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+	"k8s.io/client-go/informers"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/component-base/featuregate"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+)
+
+type pluginInitializer struct {
+	externalClient    kubernetes.Interface
+	externalInformers informers.SharedInformerFactory
+	authorizer        authorizer.Authorizer
+	featureGates      featuregate.FeatureGate
+}
+
+// New creates an instance of admission plugins initializer.
+// This constructor is public with a long param list so that callers immediately know that new information can be expected
+// during compilation when they update a level.
+func New(extClientset kubernetes.Interface, extInformers informers.SharedInformerFactory, authz authorizer.Authorizer, featureGates featuregate.FeatureGate) pluginInitializer {
+	return pluginInitializer{
+		externalClient:    extClientset,
+		externalInformers: extInformers,
+		authorizer:        authz,
+		featureGates:      featureGates,
+	}
+}
+
+// Initialize checks the initialization interfaces implemented by a plugin
+// and provide the appropriate initialization data
+func (i pluginInitializer) Initialize(plugin admission.Interface) {
+	// First tell the plugin about enabled features, so it can decide whether to start informers or not
+	if wants, ok := plugin.(WantsFeatures); ok {
+		wants.InspectFeatureGates(i.featureGates)
+	}
+
+	if wants, ok := plugin.(WantsExternalKubeClientSet); ok {
+		wants.SetExternalKubeClientSet(i.externalClient)
+	}
+
+	if wants, ok := plugin.(WantsExternalKubeInformerFactory); ok {
+		wants.SetExternalKubeInformerFactory(i.externalInformers)
+	}
+
+	if wants, ok := plugin.(WantsAuthorizer); ok {
+		wants.SetAuthorizer(i.authorizer)
+	}
+}
+
+var _ admission.PluginInitializer = pluginInitializer{}
diff --git a/pkg/webhook/admission/initializer/initializer_test.go b/pkg/webhook/admission/initializer/initializer_test.go
new file mode 100644
index 000000000..9e4844048
--- /dev/null
+++ b/pkg/webhook/admission/initializer/initializer_test.go
@@ -0,0 +1,159 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+/*
+Copyright 2017 The Kubernetes Authors.
+Derived from https://github.com/kubernetes/kubernetes/blob/9d0d2e8ece9bdd0cd8c23be2f36eee5473afc648/staging/src/k8s.io/apiserver/pkg/admission/initializer/initializer_test.go
+*/
+
+package initializer_test
+
+import (
+	"context"
+	"testing"
+	"time"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+	"k8s.io/client-go/informers"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/kubernetes/fake"
+	"k8s.io/component-base/featuregate"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission/initializer"
+)
+
+// TestWantsFeature ensures that the feature gates are injected
+// when the WantsFeatures interface is implemented by a plugin.
+func TestWantsFeatures(t *testing.T) {
+	target := initializer.New(nil, nil, nil, featuregate.NewFeatureGate())
+	wantFeaturesAdmission := &WantsFeaturesAdmission{}
+	target.Initialize(wantFeaturesAdmission)
+	if wantFeaturesAdmission.features == nil {
+		t.Errorf("expected features to be initialized but found nil")
+	}
+}
+
+// TestWantsAuthorizer ensures that the authorizer is injected
+// when the WantsAuthorizer interface is implemented by a plugin.
+func TestWantsAuthorizer(t *testing.T) {
+	target := initializer.New(nil, nil, &TestAuthorizer{}, nil)
+	wantAuthorizerAdmission := &WantAuthorizerAdmission{}
+	target.Initialize(wantAuthorizerAdmission)
+	if wantAuthorizerAdmission.auth == nil {
+		t.Errorf("expected authorizer to be initialized but found nil")
+	}
+}
+
+// TestWantsExternalKubeClientSet ensures that the clientset is injected
+// when the WantsExternalKubeClientSet interface is implemented by a plugin.
+func TestWantsExternalKubeClientSet(t *testing.T) {
+	cs := &fake.Clientset{}
+	target := initializer.New(cs, nil, &TestAuthorizer{}, nil)
+	wantExternalKubeClientSet := &WantExternalKubeClientSet{}
+	target.Initialize(wantExternalKubeClientSet)
+	if wantExternalKubeClientSet.cs != cs {
+		t.Errorf("expected clientset to be initialized")
+	}
+}
+
+// TestWantsExternalKubeInformerFactory ensures that the informer factory is injected
+// when the WantsExternalKubeInformerFactory interface is implemented by a plugin.
+func TestWantsExternalKubeInformerFactory(t *testing.T) {
+	cs := &fake.Clientset{}
+	sf := informers.NewSharedInformerFactory(cs, time.Duration(1)*time.Second)
+	target := initializer.New(cs, sf, &TestAuthorizer{}, nil)
+	wantExternalKubeInformerFactory := &WantExternalKubeInformerFactory{}
+	target.Initialize(wantExternalKubeInformerFactory)
+	if wantExternalKubeInformerFactory.sf != sf {
+		t.Errorf("expected informer factory to be initialized")
+	}
+}
+
+// WantExternalKubeInformerFactory is a test stub that fulfills the WantsExternalKubeInformerFactory interface
+type WantExternalKubeInformerFactory struct {
+	sf informers.SharedInformerFactory
+}
+
+func (self *WantExternalKubeInformerFactory) SetExternalKubeInformerFactory(sf informers.SharedInformerFactory) {
+	self.sf = sf
+}
+func (self *WantExternalKubeInformerFactory) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	return nil, nil
+}
+func (self *WantExternalKubeInformerFactory) Handles(o admissionv1.Operation) bool { return false }
+func (self *WantExternalKubeInformerFactory) ValidateInitialization() error        { return nil }
+
+var _ admission.Interface = &WantExternalKubeInformerFactory{}
+var _ initializer.WantsExternalKubeInformerFactory = &WantExternalKubeInformerFactory{}
+
+// WantExternalKubeClientSet is a test stub that fulfills the WantsExternalKubeClientSet interface
+type WantExternalKubeClientSet struct {
+	cs kubernetes.Interface
+}
+
+func (self *WantExternalKubeClientSet) SetExternalKubeClientSet(cs kubernetes.Interface) {
+	self.cs = cs
+}
+func (self *WantExternalKubeClientSet) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	return nil, nil
+}
+func (self *WantExternalKubeClientSet) Handles(o admissionv1.Operation) bool { return false }
+func (self *WantExternalKubeClientSet) ValidateInitialization() error        { return nil }
+
+var _ admission.Interface = &WantExternalKubeClientSet{}
+var _ initializer.WantsExternalKubeClientSet = &WantExternalKubeClientSet{}
+
+// WantAuthorizerAdmission is a test stub that fulfills the WantsAuthorizer interface.
+type WantAuthorizerAdmission struct {
+	auth authorizer.Authorizer
+}
+
+func (self *WantAuthorizerAdmission) SetAuthorizer(a authorizer.Authorizer) { self.auth = a }
+func (self *WantAuthorizerAdmission) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	return nil, nil
+}
+func (self *WantAuthorizerAdmission) Handles(o admissionv1.Operation) bool { return false }
+func (self *WantAuthorizerAdmission) ValidateInitialization() error        { return nil }
+
+var _ admission.Interface = &WantAuthorizerAdmission{}
+var _ initializer.WantsAuthorizer = &WantAuthorizerAdmission{}
+
+// TestAuthorizer is a test stub that fulfills the WantsAuthorizer interface.
+type TestAuthorizer struct{}
+
+func (t *TestAuthorizer) Authorize(ctx context.Context, a authorizer.Attributes) (authorized authorizer.Decision, reason string, err error) {
+	return authorizer.DecisionNoOpinion, "", nil
+}
+
+// WantsFeaturesAdmission is a test stub that fulfills the WantsFeatures interface.
+type WantsFeaturesAdmission struct {
+	features featuregate.FeatureGate
+}
+
+func (self *WantsFeaturesAdmission) InspectFeatureGates(gate featuregate.FeatureGate) {
+	self.features = gate
+}
+func (self *WantsFeaturesAdmission) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	return nil, nil
+}
+func (self *WantsFeaturesAdmission) Handles(o admissionv1.Operation) bool { return false }
+func (self *WantsFeaturesAdmission) ValidateInitialization() error        { return nil }
+
+var _ admission.Interface = &WantsFeaturesAdmission{}
+var _ initializer.WantsFeatures = &WantsFeaturesAdmission{}
diff --git a/pkg/webhook/admission/initializer/interfaces.go b/pkg/webhook/admission/initializer/interfaces.go
new file mode 100644
index 000000000..c09bbc639
--- /dev/null
+++ b/pkg/webhook/admission/initializer/interfaces.go
@@ -0,0 +1,67 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+/*
+Copyright 2017 The Kubernetes Authors.
+Derived from https://github.com/kubernetes/kubernetes/blob/9d0d2e8ece9bdd0cd8c23be2f36eee5473afc648/staging/src/k8s.io/apiserver/pkg/admission/initializer/interfaces.go
+*/
+
+package initializer
+
+import (
+	"k8s.io/apiserver/pkg/authorization/authorizer"
+	quota "k8s.io/apiserver/pkg/quota/v1"
+	"k8s.io/client-go/informers"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/component-base/featuregate"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+)
+
+// WantsExternalKubeClientSet defines a function which sets external ClientSet for admission plugins that need it
+type WantsExternalKubeClientSet interface {
+	SetExternalKubeClientSet(kubernetes.Interface)
+	admission.InitializationValidator
+}
+
+// WantsExternalKubeInformerFactory defines a function which sets InformerFactory for admission plugins that need it
+type WantsExternalKubeInformerFactory interface {
+	SetExternalKubeInformerFactory(informers.SharedInformerFactory)
+	admission.InitializationValidator
+}
+
+// WantsAuthorizer defines a function which sets Authorizer for admission plugins that need it.
+type WantsAuthorizer interface {
+	SetAuthorizer(authorizer.Authorizer)
+	admission.InitializationValidator
+}
+
+// WantsQuotaConfiguration defines a function which sets quota configuration for admission plugins that need it.
+type WantsQuotaConfiguration interface {
+	SetQuotaConfiguration(quota.Configuration)
+	admission.InitializationValidator
+}
+
+// WantsFeatures defines a function which passes the featureGates for inspection by an admission plugin.
+// Admission plugins should not hold a reference to the featureGates.  Instead, they should query a particular one
+// and assign it to a simple bool in the admission plugin struct.
+// func (a *admissionPlugin) InspectFeatureGates(features featuregate.FeatureGate){
+//     a.myFeatureIsOn = features.Enabled("my-feature")
+// }
+type WantsFeatures interface {
+	InspectFeatureGates(featuregate.FeatureGate)
+	admission.InitializationValidator
+}
diff --git a/pkg/webhook/admission/interfaces.go b/pkg/webhook/admission/interfaces.go
new file mode 100644
index 000000000..e00db44dd
--- /dev/null
+++ b/pkg/webhook/admission/interfaces.go
@@ -0,0 +1,62 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission
+
+import (
+	"context"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+)
+
+// Factory constructs an admission plugin.
+// This may be used in future to provide an `io.Reader` to the
+// plugin to be used for loading plugin specific configuration.
+type Factory func() (Interface, error)
+
+// PluginInitializer is used for initialization of shareable resources between admission plugins.
+// After initialization the resources have to be set separately
+type PluginInitializer interface {
+	Initialize(plugin Interface)
+}
+
+// InitializationValidator holds ValidateInitialization functions, which are responsible for validation of initialized
+// shared resources and should be implemented on admission plugins
+type InitializationValidator interface {
+	ValidateInitialization() error
+}
+
+// Interface is the base admission interface
+type Interface interface {
+	Handles(admissionv1.Operation) bool
+}
+
+// ValidationInterface defines an admission handler that validates requests.
+// It may not perform any kind of mutation.
+type ValidationInterface interface {
+	Interface
+
+	Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error)
+}
+
+// MutationInterface defines an admission handler that validates requests.
+// It may not perform any kind of mutation.
+type MutationInterface interface {
+	Interface
+
+	Mutate(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) (err error)
+}
diff --git a/pkg/webhook/admission/plugins.go b/pkg/webhook/admission/plugins.go
new file mode 100644
index 000000000..4e0b8270b
--- /dev/null
+++ b/pkg/webhook/admission/plugins.go
@@ -0,0 +1,94 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission
+
+import (
+	"fmt"
+
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/serializer"
+)
+
+// Plugins manages initialising, registering and executing admission plugins
+// for both validation and mutation.
+type Plugins struct {
+	decoder runtime.Decoder
+
+	pluginFactory map[string]Factory
+}
+
+func NewPlugins(scheme *runtime.Scheme) *Plugins {
+	return &Plugins{
+		decoder:       serializer.NewCodecFactory(scheme).UniversalDecoder(),
+		pluginFactory: make(map[string]Factory),
+	}
+}
+
+func (ps *Plugins) Register(name string, factory Factory) {
+	ps.pluginFactory[name] = factory
+}
+
+func (ps *Plugins) NewFromPlugins(names []string, pluginInitializer PluginInitializer) (Interface, error) {
+	var plugins []Interface
+	for _, pluginName := range names {
+		plugin, err := ps.InitPlugin(pluginName, pluginInitializer)
+		if err != nil {
+			return nil, err
+		}
+		plugins = append(plugins, plugin)
+	}
+	return PluginChain(plugins), nil
+}
+
+func (ps *Plugins) getPlugin(name string) (Interface, bool, error) {
+	f, ok := ps.pluginFactory[name]
+	if !ok {
+		return nil, false, nil
+	}
+
+	plugin, err := f()
+	return plugin, true, err
+}
+
+func (ps *Plugins) InitPlugin(name string, pluginInitializer PluginInitializer) (Interface, error) {
+	plugin, found, err := ps.getPlugin(name)
+	if err != nil {
+		return nil, err
+	}
+	if !found {
+		return nil, fmt.Errorf("No plugin named %q registered", name)
+	}
+
+	pluginInitializer.Initialize(plugin)
+	if err := ValidateInitialization(plugin); err != nil {
+		return nil, err
+	}
+
+	return plugin, nil
+}
+
+// ValidateInitialization will call the InitializationValidate function in each plugin if they implement
+// the InitializationValidator interface.
+func ValidateInitialization(plugin Interface) error {
+	if validater, ok := plugin.(InitializationValidator); ok {
+		err := validater.ValidateInitialization()
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
diff --git a/pkg/webhook/admission/plugins_test.go b/pkg/webhook/admission/plugins_test.go
new file mode 100644
index 000000000..92118159d
--- /dev/null
+++ b/pkg/webhook/admission/plugins_test.go
@@ -0,0 +1,146 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission_test
+
+import (
+	"fmt"
+	"testing"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/kubernetes/fake"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"github.com/jetstack/cert-manager/pkg/webhook/admission/initializer"
+)
+
+func TestPlugins_InitializesNamedOnly(t *testing.T) {
+	scheme := runtime.NewScheme()
+	p := admission.NewPlugins(scheme)
+
+	testPlugin1 := &testPlugin{}
+	p.Register("TestPlugin1", func() (admission.Interface, error) {
+		return testPlugin1, nil
+	})
+
+	testPlugin2 := &testPlugin{
+		initErr: fmt.Errorf("failed init"),
+	}
+	p.Register("TestPlugin2", func() (admission.Interface, error) {
+		return testPlugin2, nil
+	})
+
+	// only initialize TestPlugin1
+	_, err := p.NewFromPlugins([]string{"TestPlugin1"}, initializer.New(fake.NewSimpleClientset(), nil, nil, nil))
+	if err != nil {
+		t.Errorf("got unexpected error: %v", err)
+	}
+	if testPlugin1.kc == nil {
+		t.Errorf("expected TestPlugin1 to be initialized")
+	}
+	if testPlugin2.kc != nil {
+		t.Errorf("expected TestPlugin2 to not be initialized")
+	}
+}
+
+func TestPlugins_FailsIfAnyPluginFails(t *testing.T) {
+	scheme := runtime.NewScheme()
+	p := admission.NewPlugins(scheme)
+
+	testPlugin1 := &testPlugin{}
+	p.Register("TestPlugin1", func() (admission.Interface, error) {
+		return testPlugin1, nil
+	})
+
+	testPlugin2 := &testPlugin{
+		initErr: fmt.Errorf("failed init"),
+	}
+	p.Register("TestPlugin2", func() (admission.Interface, error) {
+		return testPlugin2, nil
+	})
+
+	// only initialize TestPlugin1
+	_, err := p.NewFromPlugins([]string{"TestPlugin1", "TestPlugin2"}, initializer.New(fake.NewSimpleClientset(), nil, nil, nil))
+	if err == nil {
+		t.Errorf("expected an error but got none")
+	}
+	if testPlugin1.kc == nil {
+		t.Errorf("expected TestPlugin1 to be initialized")
+	}
+	if testPlugin2.kc == nil {
+		t.Errorf("expected TestPlugin2 to be initialized")
+	}
+}
+
+func TestPlugins_FailsNonExistingPlugin(t *testing.T) {
+	scheme := runtime.NewScheme()
+	p := admission.NewPlugins(scheme)
+
+	testPlugin1 := &testPlugin{}
+	p.Register("TestPlugin1", func() (admission.Interface, error) {
+		return testPlugin1, nil
+	})
+
+	// only initialize TestPlugin1
+	_, err := p.NewFromPlugins([]string{"TestPlugin1", "TestPluginDoesNotExist"}, initializer.New(fake.NewSimpleClientset(), nil, nil, nil))
+	if err == nil {
+		t.Errorf("expected an error but got none")
+	}
+	if testPlugin1.kc == nil {
+		t.Errorf("expected TestPlugin1 to be initialized")
+	}
+}
+
+func TestPlugins_FailsIfPluginFailsToBuild(t *testing.T) {
+	scheme := runtime.NewScheme()
+	p := admission.NewPlugins(scheme)
+
+	testPlugin1 := &testPlugin{}
+	p.Register("TestPlugin1", func() (admission.Interface, error) {
+		return testPlugin1, fmt.Errorf("an early error occurred")
+	})
+
+	// only initialize TestPlugin1
+	_, err := p.NewFromPlugins([]string{"TestPlugin1"}, initializer.New(fake.NewSimpleClientset(), nil, nil, nil))
+	if err == nil {
+		t.Errorf("expected an error but got none")
+	}
+	if testPlugin1.kc != nil {
+		t.Errorf("expected TestPlugin1 to not be initialized")
+	}
+}
+
+type testPlugin struct {
+	kc      kubernetes.Interface
+	initErr error
+}
+
+var _ admission.Interface = &testPlugin{}
+var _ initializer.WantsExternalKubeClientSet = &testPlugin{}
+
+func (t *testPlugin) Handles(_ admissionv1.Operation) bool {
+	return true
+}
+
+func (t *testPlugin) SetExternalKubeClientSet(k kubernetes.Interface) {
+	t.kc = k
+}
+
+func (t *testPlugin) ValidateInitialization() error {
+	return t.initErr
+}
diff --git a/pkg/webhook/admission/request_handler.go b/pkg/webhook/admission/request_handler.go
new file mode 100644
index 000000000..5f130bf0e
--- /dev/null
+++ b/pkg/webhook/admission/request_handler.go
@@ -0,0 +1,274 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission
+
+import (
+	"bytes"
+	"context"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"sort"
+
+	"gomodules.xyz/jsonpatch/v2"
+	admissionv1 "k8s.io/api/admission/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/runtime/serializer"
+	apijson "k8s.io/apimachinery/pkg/runtime/serializer/json"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/handlers"
+)
+
+// RequestHandler is an implementation of the webhook's request handling that
+// invokes a validating and/or mutating admission plugin (or chain of plugins).
+//
+// All runtime.Objects passed to the mutation and validation handlers will be in
+// their internal versions to make handling multiple API versions easier.
+//
+// During mutation, objects will be decoded using the scheme provided during the
+// NewRequestHandler call. This scheme will also be used to invoke defaulting functions
+// when the object is decoded.
+// This means that all resources passed to mutating admission plugins will have default
+// values applied before converting them into the internal version.
+type RequestHandler struct {
+	scheme *runtime.Scheme
+
+	// codecFactory used to create encoders and decoders
+	codecFactory serializer.CodecFactory
+
+	// serializer used to write resources as JSON after mutation to determine
+	// the final jsonpatch for resources
+	serializer *apijson.Serializer
+
+	// decoder used to decode & convert resources in AdmissionRequests into
+	// their internal versions
+	decoder runtime.Decoder
+
+	validator ValidationInterface
+	mutator   MutationInterface
+}
+
+// NewRequestHandler will construct a new request handler using the given scheme for
+// conversion & defaulting. Either validator or mutator can be nil, and if so no
+// action will be taken.
+func NewRequestHandler(scheme *runtime.Scheme, validator ValidationInterface, mutator MutationInterface) *RequestHandler {
+	cf := serializer.NewCodecFactory(scheme)
+	return &RequestHandler{
+		scheme:       scheme,
+		codecFactory: cf,
+		serializer:   apijson.NewSerializerWithOptions(apijson.DefaultMetaFactory, scheme, scheme, apijson.SerializerOptions{}),
+		decoder:      cf.UniversalDecoder(),
+		validator:    validator,
+		mutator:      mutator,
+	}
+}
+
+var _ handlers.ValidatingAdmissionHook = &RequestHandler{}
+var _ handlers.MutatingAdmissionHook = &RequestHandler{}
+
+// Validate will decode the Object (and OldObject, if set) in the AdmissionRequest into the
+// internal API version.
+// It will then invoke the validation handler to build a list of warning messages and any
+// errors generated during the admission chain.
+func (rh *RequestHandler) Validate(ctx context.Context, admissionSpec *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {
+	status := &admissionv1.AdmissionResponse{}
+	status.UID = admissionSpec.UID
+	// short-path if there is no validator actually registered or the handler does not handle this operation.
+	if rh.validator == nil || !rh.validator.Handles(admissionSpec.Operation) {
+		status.Allowed = true
+		return status
+	}
+
+	// decode new version of object
+	obj, err := rh.deseralizeToInternalVersion(admissionSpec.Object.Raw)
+	if err != nil {
+		return badRequestError(status, err)
+	}
+
+	// attempt to decode old object
+	var oldObj runtime.Object
+	if len(admissionSpec.OldObject.Raw) > 0 {
+		oldObj, err = rh.deseralizeToInternalVersion(admissionSpec.OldObject.Raw)
+		if err != nil {
+			return badRequestError(status, err)
+		}
+	}
+
+	warnings, err := rh.validator.Validate(ctx, *admissionSpec, oldObj, obj)
+	status.Warnings = warnings
+
+	// return with allowed = false if any errors occurred
+	if err != nil {
+		status.Allowed = false
+		status.Result = &metav1.Status{
+			Status: metav1.StatusFailure, Code: http.StatusNotAcceptable, Reason: metav1.StatusReasonNotAcceptable,
+			Message: err.Error(),
+		}
+		return status
+	}
+	status.Allowed = true
+	return status
+}
+
+func (rh *RequestHandler) Mutate(ctx context.Context, admissionSpec *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {
+	status := &admissionv1.AdmissionResponse{}
+	status.UID = admissionSpec.UID
+	status.Allowed = true
+	// short-path if there is no mutator actually registered
+	// we still continue if the mutator does not handle the resource so scheme-registered
+	// defaulting functions are still run against the object.
+	if rh.mutator == nil {
+		status.Allowed = true
+		return status
+	}
+
+	// If the resource submitted to the webhook is in a different version to the request version,
+	// we must take special steps to ensure the correct defaults are applied to the resource (as
+	// defaults are applied by the decoder when the resource is decoded in the version of the
+	// encoded resource).
+	obj, errResponse := rh.decodeRequestObject(status, admissionSpec.Kind, *admissionSpec.RequestKind, admissionSpec.Object.Raw)
+	if errResponse != nil {
+		return errResponse
+	}
+
+	if rh.mutator.Handles(admissionSpec.Operation) {
+		if err := rh.mutator.Mutate(ctx, *admissionSpec, obj); err != nil {
+			return internalServerError(status, err)
+		}
+	}
+
+	// Convert the object into the original version that was submitted to the webhook
+	// before generating the patch.
+	outputGroupVersioner := runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: admissionSpec.Kind.Group, Version: admissionSpec.Kind.Version})
+	finalObject, err := rh.scheme.ConvertToVersion(obj, outputGroupVersioner)
+	if err != nil {
+		return internalServerError(status, err)
+	}
+
+	patch, err := rh.createMutatePatch(admissionSpec, finalObject)
+	if err != nil {
+		return internalServerError(status, err)
+	}
+
+	patchType := admissionv1.PatchTypeJSONPatch
+	status.PatchType = &patchType
+	status.Patch = patch
+
+	return status
+}
+
+// decodeRequestObject will decode the given 'bytes' into the internal API version.
+// It will apply defaults using the 'defaultsInGVK', regardless of what API version
+// the encoded bytes are in.
+func (rh *RequestHandler) decodeRequestObject(status *admissionv1.AdmissionResponse, objectGVK, defaultInGVK metav1.GroupVersionKind, bytes []byte) (runtime.Object, *admissionv1.AdmissionResponse) {
+	if objectGVK == defaultInGVK {
+		obj, _, err := rh.decoder.Decode(bytes, nil, nil)
+		if err != nil {
+			return nil, badRequestError(status, err)
+		}
+		return obj, nil
+	}
+
+	// Decode the object to the internal version without defaulting
+	internalObj, err := rh.deseralizeToInternalVersion(bytes)
+	if err != nil {
+		return nil, badRequestError(status, err)
+	}
+
+	// Now convert into the request version so we can apply the appropriate defaults
+	requestGroupVersioner := runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: defaultInGVK.Group, Version: defaultInGVK.Version})
+	requestObj, err := rh.scheme.ConvertToVersion(internalObj, requestGroupVersioner)
+	if err != nil {
+		return nil, internalServerError(status, err)
+	}
+
+	// At last, apply defaults in the request API version
+	rh.scheme.Default(requestObj)
+
+	// Finally, convert the resource back to the internal version so regular admission can proceed
+	obj, err := rh.scheme.ConvertToVersion(requestObj, runtime.InternalGroupVersioner)
+	if err != nil {
+		return nil, internalServerError(status, err)
+	}
+
+	return obj, nil
+}
+
+// deseralizeToInternalVersion will decode an object into its internal version
+// without applying default values.
+func (rh *RequestHandler) deseralizeToInternalVersion(bytes []byte) (runtime.Object, error) {
+	// First, use the UniversalDeserializer to decode the bytes (which does not perform
+	// conversion or defaulting).
+	obj, _, err := rh.codecFactory.UniversalDeserializer().Decode(bytes, nil, nil)
+	if err != nil {
+		return nil, err
+	}
+
+	// Then convert to the internal version
+	return rh.scheme.ConvertToVersion(obj, runtime.InternalGroupVersioner)
+}
+
+func badRequestError(status *admissionv1.AdmissionResponse, err error) *admissionv1.AdmissionResponse {
+	status.Allowed = false
+	status.Result = &metav1.Status{
+		Status: metav1.StatusFailure, Code: http.StatusBadRequest, Reason: metav1.StatusReasonBadRequest,
+		Message: err.Error(),
+	}
+	return status
+}
+
+func internalServerError(status *admissionv1.AdmissionResponse, err error) *admissionv1.AdmissionResponse {
+	status.Allowed = false
+	status.Result = &metav1.Status{
+		Status: metav1.StatusFailure, Code: http.StatusInternalServerError, Reason: metav1.StatusReasonInternalError,
+		Message: err.Error(),
+	}
+	return status
+}
+
+// createMutatePatch will generate a JSON patch based upon the given original
+// raw object, and the mutated typed object.
+func (rh *RequestHandler) createMutatePatch(req *admissionv1.AdmissionRequest, obj runtime.Object) ([]byte, error) {
+	var buf bytes.Buffer
+
+	encoder := rh.codecFactory.EncoderForVersion(rh.serializer, schema.GroupVersion{Group: req.Kind.Group, Version: req.Kind.Version})
+	if err := encoder.Encode(obj, &buf); err != nil {
+		return nil, fmt.Errorf("failed to encode object after mutation: %s", err)
+	}
+
+	ops, err := jsonpatch.CreatePatch(req.Object.Raw, buf.Bytes())
+	if err != nil {
+		return nil, fmt.Errorf("failed to set mutation patch: %s", err)
+	}
+
+	sortOps(ops)
+
+	patch, err := json.Marshal(ops)
+	if err != nil {
+		return nil, fmt.Errorf("failed to generate json patch: %s", err)
+	}
+
+	return patch, nil
+}
+
+func sortOps(ops []jsonpatch.JsonPatchOperation) {
+	sort.Slice(ops, func(i, j int) bool {
+		return ops[i].Path < ops[j].Path
+	})
+}
diff --git a/pkg/webhook/admission/request_handler_test.go b/pkg/webhook/admission/request_handler_test.go
new file mode 100644
index 000000000..aede70d80
--- /dev/null
+++ b/pkg/webhook/admission/request_handler_test.go
@@ -0,0 +1,321 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission_test
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"reflect"
+	"testing"
+
+	"gomodules.xyz/jsonpatch/v2"
+	admissionv1 "k8s.io/api/admission/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/diff"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup"
+	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/install"
+)
+
+var (
+	jsonPatchType = admissionv1.PatchTypeJSONPatch
+)
+
+// Tests to ensure that the RequestHandler applies scheme-registered
+// defaults when mutating objects.
+func TestRequestHandler_MutateAppliesDefaultValues(t *testing.T) {
+	scheme := runtime.NewScheme()
+	install.Install(scheme)
+
+	rh := admission.NewRequestHandler(scheme, nil, testMutator{
+		handles: true,
+		mutate: func(_ context.Context, _ admissionv1.AdmissionRequest, obj runtime.Object) error {
+			obj.(*testgroup.TestType).TestField = "some-value"
+			return nil
+		},
+	})
+	inputRequest := admissionv1.AdmissionRequest{
+		UID:       types.UID("abc"),
+		Operation: admissionv1.Create,
+		Kind: metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		RequestKind: &metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		Object: runtime.RawExtension{
+			Raw: []byte(`
+{
+	"apiVersion": "testgroup.testing.cert-manager.io/v1",
+	"kind": "TestType",
+	"metadata": {
+		"name": "testing",
+		"namespace": "abc",
+		"creationTimestamp": null
+	},
+	"testFieldImmutable": "abc",
+	"testDefaultingField": "set-to-something"
+}
+`),
+		},
+	}
+	expectedResponse := admissionv1.AdmissionResponse{
+		UID:     types.UID("abc"),
+		Allowed: true,
+		Patch: responseForOperations(
+			jsonpatch.JsonPatchOperation{
+				Operation: "add",
+				Path:      "/testField",
+				Value:     "some-value",
+			},
+			jsonpatch.JsonPatchOperation{
+				Operation: "add",
+				Path:      "/testFieldPtr",
+				Value:     "teststr",
+			},
+		),
+		PatchType: &jsonPatchType,
+	}
+
+	resp := rh.Mutate(context.TODO(), &inputRequest)
+	if !reflect.DeepEqual(&expectedResponse, resp) {
+		t.Errorf("Response was not as expected: %v", diff.ObjectGoPrintSideBySide(&expectedResponse, resp))
+	}
+}
+
+func TestRequestHandler_MutateAppliesDefaultsInRequestVersion(t *testing.T) {
+	scheme := runtime.NewScheme()
+	install.Install(scheme)
+
+	rh := admission.NewRequestHandler(scheme, nil, testMutator{
+		handles: true,
+		mutate: func(_ context.Context, _ admissionv1.AdmissionRequest, obj runtime.Object) error {
+			// Doesn't do anything as the request handler itself will generate patches to apply
+			// defaults instead of it being applied within a particular admission plugin.
+			return nil
+		},
+	})
+	inputRequest := admissionv1.AdmissionRequest{
+		UID:       types.UID("abc"),
+		Operation: admissionv1.Create,
+		Kind: metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		RequestKind: &metav1.GroupVersionKind{
+			Group: "testgroup.testing.cert-manager.io",
+			// Because the API version is v2, we expect the `testDefaultingField` field to be set to `set-in-v2`.
+			// In v1, the field will be set to `set-in-v1`.
+			Version: "v2",
+			Kind:    "TestType",
+		},
+		Object: runtime.RawExtension{
+			Raw: []byte(`
+{
+	"apiVersion": "testgroup.testing.cert-manager.io/v1",
+	"kind": "TestType",
+	"metadata": {
+		"name": "testing",
+		"namespace": "abc",
+		"creationTimestamp": null
+	},
+	"testField": "set-to-something-to-avoid-extra-mutations",
+	"testFieldImmutable": "set-to-something-to-avoid-extra-mutations",
+	"testFieldPtr": "set-to-something-to-avoid-extra-mutations"
+}
+`),
+		},
+	}
+	expectedResponse := admissionv1.AdmissionResponse{
+		UID:     types.UID("abc"),
+		Allowed: true,
+		Patch: responseForOperations(
+			jsonpatch.JsonPatchOperation{
+				Operation: "add",
+				Path:      "/testDefaultingField",
+				Value:     "set-in-v2",
+			},
+		),
+		PatchType: &jsonPatchType,
+	}
+
+	resp := rh.Mutate(context.TODO(), &inputRequest)
+	if !reflect.DeepEqual(&expectedResponse, resp) {
+		t.Errorf("Response was not as expected: %v", diff.ObjectGoPrintSideBySide(&expectedResponse, resp))
+	}
+}
+
+// Tests to ensure that the RequestHandler skips running mutation handlers
+// that do not return true to Handles, but still applies scheme based defaulting.
+func TestRequestHandler_MutateSkipsMutation(t *testing.T) {
+	scheme := runtime.NewScheme()
+	install.Install(scheme)
+
+	rh := admission.NewRequestHandler(scheme, nil, testMutator{
+		handles: false,
+	})
+	inputRequest := admissionv1.AdmissionRequest{
+		UID:       types.UID("abc"),
+		Operation: admissionv1.Create,
+		Kind: metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		RequestKind: &metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		Object: runtime.RawExtension{
+			Raw: []byte(`
+{
+	"apiVersion": "testgroup.testing.cert-manager.io/v1",
+	"kind": "TestType",
+	"metadata": {
+		"name": "testing",
+		"namespace": "abc",
+		"creationTimestamp": null
+	},
+	"testField": "some-value",
+	"testFieldImmutable": "abc",
+	"testDefaultingField": "set-to-something"
+}
+`),
+		},
+	}
+	expectedResponse := admissionv1.AdmissionResponse{
+		UID:     types.UID("abc"),
+		Allowed: true,
+		Patch: responseForOperations(
+			jsonpatch.JsonPatchOperation{
+				Operation: "add",
+				Path:      "/testFieldPtr",
+				Value:     "teststr",
+			},
+		),
+		PatchType: &jsonPatchType,
+	}
+
+	resp := rh.Mutate(context.TODO(), &inputRequest)
+	if !reflect.DeepEqual(&expectedResponse, resp) {
+		t.Errorf("Response was not as expected: %v", diff.ObjectGoPrintSideBySide(&expectedResponse, resp))
+	}
+}
+
+func TestRequestHandler_ValidateReturnsErrorsAndWarnings(t *testing.T) {
+	scheme := runtime.NewScheme()
+	install.Install(scheme)
+
+	rh := admission.NewRequestHandler(scheme, testValidator{
+		handles:  true,
+		warnings: []string{"a warning"},
+		err:      fmt.Errorf("some synthetic error"),
+	}, nil)
+	inputRequest := admissionv1.AdmissionRequest{
+		UID:       types.UID("abc"),
+		Operation: admissionv1.Create,
+		Kind: metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		RequestKind: &metav1.GroupVersionKind{
+			Group:   "testgroup.testing.cert-manager.io",
+			Version: "v1",
+			Kind:    "TestType",
+		},
+		Object: runtime.RawExtension{
+			Raw: []byte(`
+{
+	"apiVersion": "testgroup.testing.cert-manager.io/v1",
+	"kind": "TestType",
+	"metadata": {
+		"name": "testing",
+		"namespace": "abc"
+	}
+}
+`),
+		},
+	}
+	expectedResponse := admissionv1.AdmissionResponse{
+		UID:     types.UID("abc"),
+		Allowed: false,
+		Result: &metav1.Status{
+			Status:  metav1.StatusFailure,
+			Message: "some synthetic error",
+			Reason:  metav1.StatusReasonNotAcceptable,
+			Code:    http.StatusNotAcceptable,
+		},
+		Warnings: []string{"a warning"},
+	}
+
+	resp := rh.Validate(context.TODO(), &inputRequest)
+	if !reflect.DeepEqual(&expectedResponse, resp) {
+		t.Errorf("Response was not as expected: %v", diff.ObjectGoPrintSideBySide(&expectedResponse, resp))
+	}
+}
+
+func responseForOperations(ops ...jsonpatch.JsonPatchOperation) []byte {
+	b, err := json.Marshal(ops)
+	if err != nil {
+		// this shouldn't ever be reached
+		panic("failed to encode JSON test data")
+	}
+	return b
+}
+
+type testValidator struct {
+	handles  bool
+	warnings []string
+	err      error
+}
+
+var _ admission.ValidationInterface = testValidator{}
+
+func (t testValidator) Handles(operation admissionv1.Operation) bool {
+	return t.handles
+}
+
+func (t testValidator) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	return t.warnings, t.err
+}
+
+type testMutator struct {
+	handles bool
+	mutate  func(_ context.Context, _ admissionv1.AdmissionRequest, obj runtime.Object) error
+}
+
+var _ admission.MutationInterface = testMutator{}
+
+func (t testMutator) Handles(_ admissionv1.Operation) bool {
+	return t.handles
+}
+
+func (t testMutator) Mutate(ctx context.Context, req admissionv1.AdmissionRequest, obj runtime.Object) error {
+	return t.mutate(ctx, req, obj)
+}
diff --git a/pkg/webhook/admission/util_test.go b/pkg/webhook/admission/util_test.go
new file mode 100644
index 000000000..a8489c3c1
--- /dev/null
+++ b/pkg/webhook/admission/util_test.go
@@ -0,0 +1,62 @@
+/*
+Copyright 2021 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package admission_test
+
+import (
+	"context"
+
+	admissionv1 "k8s.io/api/admission/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+
+	"github.com/jetstack/cert-manager/pkg/webhook/admission"
+)
+
+type handles bool
+
+func (h handles) Handles(admissionv1.Operation) bool {
+	return bool(h)
+}
+
+type validatingImplementation struct {
+	handles  func(admissionv1.Operation) bool
+	validate func(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) ([]string, error)
+}
+
+func (v validatingImplementation) Handles(operation admissionv1.Operation) bool {
+	return v.handles(operation)
+}
+
+func (v validatingImplementation) Validate(ctx context.Context, request admissionv1.AdmissionRequest, oldObj, obj runtime.Object) (warnings []string, err error) {
+	return v.validate(ctx, request, oldObj, obj)
+}
+
+var _ admission.ValidationInterface = &validatingImplementation{}
+
+type mutatingImplementation struct {
+	handles func(admissionv1.Operation) bool
+	mutate  func(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error
+}
+
+func (v mutatingImplementation) Handles(operation admissionv1.Operation) bool {
+	return v.handles(operation)
+}
+
+func (v mutatingImplementation) Mutate(ctx context.Context, request admissionv1.AdmissionRequest, obj runtime.Object) error {
+	return v.mutate(ctx, request, obj)
+}
+
+var _ admission.MutationInterface = &mutatingImplementation{}
diff --git a/pkg/webhook/handlers/BUILD.bazel b/pkg/webhook/handlers/BUILD.bazel
index 599177592..1f2319c0e 100644
--- a/pkg/webhook/handlers/BUILD.bazel
+++ b/pkg/webhook/handlers/BUILD.bazel
@@ -5,15 +5,10 @@ go_library(
     srcs = [
         "conversion.go",
         "interfaces.go",
-        "mutation.go",
-        "validation.go",
     ],
     importpath = "github.com/jetstack/cert-manager/pkg/webhook/handlers",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/mutation:go_default_library",
-        "//internal/api/validation:go_default_library",
-        "//internal/apis/certmanager/validation/plugins:go_default_library",
         "//pkg/logs:go_default_library",
         "@com_github_go_logr_logr//:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
@@ -21,38 +16,24 @@ go_library(
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime/schema:go_default_library",
-        "@io_k8s_apimachinery//pkg/runtime/serializer:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime/serializer/json:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime/serializer/versioning:go_default_library",
-        "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
-        "@io_k8s_client_go//kubernetes:go_default_library",
     ],
 )
 
 go_test(
     name = "go_default_test",
-    srcs = [
-        "conversion_test.go",
-        "mutation_test.go",
-        "validation_test.go",
-    ],
+    srcs = ["conversion_test.go"],
     embed = [":go_default_library"],
     deps = [
-        "//internal/api/mutation:go_default_library",
-        "//internal/api/validation:go_default_library",
-        "//pkg/logs:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup/install:go_default_library",
-        "//pkg/webhook/handlers/testdata/apis/testgroup/v1:go_default_library",
-        "//pkg/webhook/handlers/testdata/apis/testgroup/v2:go_default_library",
-        "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_apiextensions_apiserver//pkg/apis/apiextensions/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/types:go_default_library",
         "@io_k8s_klog_v2//klogr:go_default_library",
         "@io_k8s_utils//diff:go_default_library",
-        "@xyz_gomodules_jsonpatch_v2//:go_default_library",
     ],
 )
 
diff --git a/pkg/webhook/handlers/interfaces.go b/pkg/webhook/handlers/interfaces.go
index a2e04a1a6..8e9bab824 100644
--- a/pkg/webhook/handlers/interfaces.go
+++ b/pkg/webhook/handlers/interfaces.go
@@ -21,21 +21,16 @@ import (
 
 	admissionv1 "k8s.io/api/admission/v1"
 	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
-	"k8s.io/client-go/kubernetes"
 )
 
 type ValidatingAdmissionHook interface {
 	// Validate is called to decide whether to accept the admission request. The returned AdmissionResponse
 	// must not use the Patch field.
 	Validate(ctx context.Context, admissionSpec *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse
-
-	// InitPlugins will initialise all plugins which are registered for this
-	// validating admission hook.
-	InitPlugins(client kubernetes.Interface)
 }
 
 type MutatingAdmissionHook interface {
-	// Admit is called to decide whether to accept the admission request. The returned AdmissionResponse may
+	// Mutate is called to decide whether to accept the admission request. The returned AdmissionResponse may
 	// use the Patch field to mutate the object from the passed AdmissionRequest.
 	Mutate(ctx context.Context, admissionSpec *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse
 }
diff --git a/pkg/webhook/handlers/mutation.go b/pkg/webhook/handlers/mutation.go
deleted file mode 100644
index 67eb438d4..000000000
--- a/pkg/webhook/handlers/mutation.go
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package handlers
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-
-	"github.com/go-logr/logr"
-	admissionv1 "k8s.io/api/admission/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/serializer"
-
-	"github.com/jetstack/cert-manager/internal/api/mutation"
-	logf "github.com/jetstack/cert-manager/pkg/logs"
-)
-
-type RegistryBackedMutator struct {
-	log      logr.Logger
-	decoder  runtime.Decoder
-	registry *mutation.Registry
-}
-
-func NewRegistryBackedMutator(log logr.Logger, scheme *runtime.Scheme, registry *mutation.Registry) *RegistryBackedMutator {
-	factory := serializer.NewCodecFactory(scheme)
-	return &RegistryBackedMutator{
-		log:      log,
-		decoder:  factory.UniversalDecoder(),
-		registry: registry,
-	}
-}
-
-func (c *RegistryBackedMutator) Mutate(_ context.Context, admissionSpec *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {
-	status := &admissionv1.AdmissionResponse{}
-	status.UID = admissionSpec.UID
-
-	// Generate a patch from the appropriate functions installed in the mutation registry
-	patch, err := c.registry.Mutate(admissionSpec)
-	if err != nil {
-		status.Result = &metav1.Status{
-			Status: metav1.StatusFailure, Code: http.StatusInternalServerError, Reason: metav1.StatusReasonInternalError,
-			Message: fmt.Sprintf("Failed to mutate object: %v", err.Error()),
-		}
-		return status
-	}
-
-	// set the AdmissionReview status
-	jsonPatchType := admissionv1.PatchTypeJSONPatch
-	status.Patch = patch
-	status.PatchType = &jsonPatchType
-	status.Allowed = true
-
-	c.log.V(logf.DebugLevel).Info("generated patch", "patch", string(patch))
-
-	return status
-}
diff --git a/pkg/webhook/handlers/mutation_test.go b/pkg/webhook/handlers/mutation_test.go
deleted file mode 100644
index d9e188bf4..000000000
--- a/pkg/webhook/handlers/mutation_test.go
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package handlers
-
-import (
-	"context"
-	"encoding/json"
-	"reflect"
-	"testing"
-
-	"gomodules.xyz/jsonpatch/v2"
-	admissionv1 "k8s.io/api/admission/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/types"
-	"k8s.io/klog/v2/klogr"
-	"k8s.io/utils/diff"
-
-	"github.com/jetstack/cert-manager/internal/api/mutation"
-	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/install"
-)
-
-var (
-	jsonPatchType = admissionv1.PatchTypeJSONPatch
-)
-
-func responseForOperations(ops ...jsonpatch.JsonPatchOperation) []byte {
-	b, err := json.Marshal(ops)
-	if err != nil {
-		// this shouldn't ever be reached
-		panic("failed to encode JSON test data")
-	}
-	return b
-}
-
-func TestDefaultCertificate(t *testing.T) {
-	scheme := runtime.NewScheme()
-	registry := mutation.NewRegistry(scheme)
-	install.Install(scheme)
-
-	log := klogr.New()
-	c := NewRegistryBackedMutator(log, scheme, registry)
-	tests := map[string]admissionTestT{
-		"apply defaults to TestType": {
-			inputRequest: admissionv1.AdmissionRequest{
-				UID:       types.UID("abc"),
-				Operation: admissionv1.Create,
-				RequestKind: &metav1.GroupVersionKind{
-					Group:   "testgroup.testing.cert-manager.io",
-					Version: "v1",
-					Kind:    "TestType",
-				},
-				Object: runtime.RawExtension{
-					Raw: []byte(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v1",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	}
-}
-`),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				UID:     types.UID("abc"),
-				Allowed: true,
-				Patch: responseForOperations(
-					jsonpatch.JsonPatchOperation{
-						Operation: "add",
-						Path:      "/testField",
-						Value:     "",
-					},
-					jsonpatch.JsonPatchOperation{
-						Operation: "add",
-						Path:      "/testFieldImmutable",
-						Value:     "",
-					},
-					jsonpatch.JsonPatchOperation{
-						Operation: "add",
-						Path:      "/testFieldPtr",
-						Value:     `teststr`,
-					},
-				),
-				PatchType: &jsonPatchType,
-			},
-		},
-	}
-
-	for n, test := range tests {
-		t.Run(n, func(t *testing.T) {
-			runAdmissionTest(t, c.Mutate, test)
-		})
-	}
-}
-
-type admissionTestT struct {
-	inputRequest     admissionv1.AdmissionRequest
-	expectedResponse admissionv1.AdmissionResponse
-}
-
-type admissionFn func(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse
-
-func runAdmissionTest(t *testing.T, fn admissionFn, test admissionTestT) {
-	resp := fn(context.TODO(), &test.inputRequest)
-	if !reflect.DeepEqual(&test.expectedResponse, resp) {
-		t.Errorf("Response was not as expected: %v", diff.ObjectGoPrintSideBySide(&test.expectedResponse, resp))
-	}
-}
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/crds/testgroup.testing.cert-manager.io_testtypes.yaml b/pkg/webhook/handlers/testdata/apis/testgroup/crds/testgroup.testing.cert-manager.io_testtypes.yaml
index 3dbcdfabe..e56e84b12 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/crds/testgroup.testing.cert-manager.io_testtypes.yaml
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/crds/testgroup.testing.cert-manager.io_testtypes.yaml
@@ -32,6 +32,10 @@ spec:
             type: string
           metadata:
             type: object
+          testDefaultingField:
+            description: TestDefaultingField is used to test defaulting. In the v1
+              API, it defaults to `set-in-v1`. In the v2 API, it defaults to `set-in-v2`.
+            type: string
           testField:
             description: TestField is used in tests. Validation doesn't allow this
               to be set to the value of TestFieldValueNotAllowed.
@@ -67,6 +71,10 @@ spec:
             type: string
           metadata:
             type: object
+          testDefaultingField:
+            description: TestDefaultingField is used to test defaulting. In the v1
+              API, it defaults to `set-in-v1`. In the v2 API, it defaults to `set-in-v2`.
+            type: string
           testField:
             description: TestField is used in tests. Validation doesn't allow this
               to be set to the value of TestFieldValueNotAllowed.
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/install/BUILD.bazel b/pkg/webhook/handlers/testdata/apis/testgroup/install/BUILD.bazel
index 541e06e2a..ddf471a60 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/install/BUILD.bazel
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/install/BUILD.bazel
@@ -6,11 +6,9 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/install",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup/v1:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup/v2:go_default_library",
-        "//pkg/webhook/handlers/testdata/apis/testgroup/validation:go_default_library",
         "@io_k8s_apimachinery//pkg/runtime:go_default_library",
         "@io_k8s_apimachinery//pkg/util/runtime:go_default_library",
     ],
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/install/install.go b/pkg/webhook/handlers/testdata/apis/testgroup/install/install.go
index 509ab07d9..c1b7c753f 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/install/install.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/install/install.go
@@ -22,11 +22,9 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup"
 	v1 "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v1"
 	v2 "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v2"
-	testval "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/validation"
 )
 
 // Install registers the API group and adds types to a scheme
@@ -35,8 +33,3 @@ func Install(scheme *runtime.Scheme) {
 	utilruntime.Must(v1.AddToScheme(scheme))
 	utilruntime.Must(v2.AddToScheme(scheme))
 }
-
-func InstallValidations(registry *validation.Registry) {
-	utilruntime.Must(testval.Register(registry))
-	utilruntime.Must(v2.RegisterValidations(registry))
-}
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/types.go b/pkg/webhook/handlers/testdata/apis/testgroup/types.go
index 30e9622e2..9c8b10b82 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/types.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/types.go
@@ -33,4 +33,7 @@ type TestType struct {
 
 	// TestFieldImmutable cannot be changed after being set to a non-zero value
 	TestFieldImmutable string
+
+	// TestDefaultingField is used to test defaulting.
+	TestDefaultingField string
 }
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v1/defaults.go b/pkg/webhook/handlers/testdata/apis/testgroup/v1/defaults.go
index d846c790c..740bf66b4 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v1/defaults.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v1/defaults.go
@@ -29,4 +29,7 @@ func SetDefaults_TestType(obj *TestType) {
 	if obj.TestFieldPtr == nil {
 		obj.TestFieldPtr = pointer.StringPtr("teststr")
 	}
+	if obj.TestDefaultingField == "" {
+		obj.TestDefaultingField = "set-in-v1"
+	}
 }
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v1/types.go b/pkg/webhook/handlers/testdata/apis/testgroup/v1/types.go
index b7788f968..8516e48be 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v1/types.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v1/types.go
@@ -33,6 +33,11 @@ type TestType struct {
 
 	// TestFieldImmutable cannot be changed after being set to a non-zero value
 	TestFieldImmutable string `json:"testFieldImmutable"`
+
+	// TestDefaultingField is used to test defaulting.
+	// In the v1 API, it defaults to `set-in-v1`.
+	// In the v2 API, it defaults to `set-in-v2`.
+	TestDefaultingField string `json:"testDefaultingField,omitempty"`
 }
 
 const (
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v1/zz_generated.conversion.go b/pkg/webhook/handlers/testdata/apis/testgroup/v1/zz_generated.conversion.go
index 61a7746f6..5eb4d516f 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v1/zz_generated.conversion.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v1/zz_generated.conversion.go
@@ -54,6 +54,7 @@ func autoConvert_v1_TestType_To_testgroup_TestType(in *TestType, out *testgroup.
 	out.TestField = in.TestField
 	out.TestFieldPtr = (*string)(unsafe.Pointer(in.TestFieldPtr))
 	out.TestFieldImmutable = in.TestFieldImmutable
+	out.TestDefaultingField = in.TestDefaultingField
 	return nil
 }
 
@@ -67,6 +68,7 @@ func autoConvert_testgroup_TestType_To_v1_TestType(in *testgroup.TestType, out *
 	out.TestField = in.TestField
 	out.TestFieldPtr = (*string)(unsafe.Pointer(in.TestFieldPtr))
 	out.TestFieldImmutable = in.TestFieldImmutable
+	out.TestDefaultingField = in.TestDefaultingField
 	return nil
 }
 
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v2/BUILD.bazel b/pkg/webhook/handlers/testdata/apis/testgroup/v2/BUILD.bazel
index 7ee189f54..01812fc44 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v2/BUILD.bazel
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v2/BUILD.bazel
@@ -16,7 +16,6 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v2",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/apis/meta/v1:go_default_library",
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v2/defaults.go b/pkg/webhook/handlers/testdata/apis/testgroup/v2/defaults.go
index 322813f66..7466c42f3 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v2/defaults.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v2/defaults.go
@@ -29,4 +29,7 @@ func SetDefaults_TestType(obj *TestType) {
 	if obj.TestFieldPtrAlt == nil {
 		obj.TestFieldPtrAlt = pointer.StringPtr("teststr")
 	}
+	if obj.TestDefaultingField == "" {
+		obj.TestDefaultingField = "set-in-v2"
+	}
 }
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v2/register.go b/pkg/webhook/handlers/testdata/apis/testgroup/v2/register.go
index ff05205fd..e19861668 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v2/register.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v2/register.go
@@ -21,7 +21,6 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup"
 )
 
@@ -39,13 +38,6 @@ var (
 	AddToScheme        = localSchemeBuilder.AddToScheme
 )
 
-func RegisterValidations(reg *validation.Registry) error {
-	if err := reg.AddValidateFunc(&TestType{}, ValidateTestType); err != nil {
-		return err
-	}
-	return nil
-}
-
 func init() {
 	// We only register manually written functions here. The registration of the
 	// generated functions takes place in the generated files. The separation
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v2/types.go b/pkg/webhook/handlers/testdata/apis/testgroup/v2/types.go
index b2e3c5017..a6f49622a 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v2/types.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v2/types.go
@@ -36,6 +36,11 @@ type TestType struct {
 
 	// TestFieldImmutable cannot be changed after being set to a non-zero value
 	TestFieldImmutable string `json:"testFieldImmutable"`
+
+	// TestDefaultingField is used to test defaulting.
+	// In the v1 API, it defaults to `set-in-v1`.
+	// In the v2 API, it defaults to `set-in-v2`.
+	TestDefaultingField string `json:"testDefaultingField,omitempty"`
 }
 
 const (
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v2/validation.go b/pkg/webhook/handlers/testdata/apis/testgroup/v2/validation.go
index 0d53007b1..0ad874e20 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v2/validation.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v2/validation.go
@@ -20,11 +20,9 @@ import (
 	admissionv1 "k8s.io/api/admission/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
 )
 
-func ValidateTestType(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateTestType(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
 	el := field.ErrorList{}
 	tt := obj.(*TestType)
 	if tt.TestField == DisallowedTestFieldValue {
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/v2/zz_generated.conversion.go b/pkg/webhook/handlers/testdata/apis/testgroup/v2/zz_generated.conversion.go
index 87b34690f..a432a790e 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/v2/zz_generated.conversion.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/v2/zz_generated.conversion.go
@@ -52,6 +52,7 @@ func autoConvert_v2_TestType_To_testgroup_TestType(in *TestType, out *testgroup.
 	out.TestField = in.TestField
 	// WARNING: in.TestFieldPtrAlt requires manual conversion: does not exist in peer-type
 	out.TestFieldImmutable = in.TestFieldImmutable
+	out.TestDefaultingField = in.TestDefaultingField
 	return nil
 }
 
@@ -60,5 +61,6 @@ func autoConvert_testgroup_TestType_To_v2_TestType(in *testgroup.TestType, out *
 	out.TestField = in.TestField
 	// WARNING: in.TestFieldPtr requires manual conversion: does not exist in peer-type
 	out.TestFieldImmutable = in.TestFieldImmutable
+	out.TestDefaultingField = in.TestDefaultingField
 	return nil
 }
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/validation/BUILD.bazel b/pkg/webhook/handlers/testdata/apis/testgroup/validation/BUILD.bazel
index 5d62e3aac..a556f1f20 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/validation/BUILD.bazel
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/validation/BUILD.bazel
@@ -2,14 +2,10 @@ load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
 
 go_library(
     name = "go_default_library",
-    srcs = [
-        "register.go",
-        "validation.go",
-    ],
+    srcs = ["validation.go"],
     importpath = "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/validation",
     visibility = ["//visibility:public"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup/v1:go_default_library",
         "@io_k8s_api//admission/v1:go_default_library",
@@ -23,7 +19,6 @@ go_test(
     srcs = ["validation_test.go"],
     embed = [":go_default_library"],
     deps = [
-        "//internal/api/validation:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup:go_default_library",
         "//pkg/webhook/handlers/testdata/apis/testgroup/v1:go_default_library",
         "@io_k8s_apimachinery//pkg/util/validation/field:go_default_library",
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/validation/register.go b/pkg/webhook/handlers/testdata/apis/testgroup/validation/register.go
deleted file mode 100644
index 63a36f9b0..000000000
--- a/pkg/webhook/handlers/testdata/apis/testgroup/validation/register.go
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package validation
-
-import (
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup"
-)
-
-func Register(reg *validation.Registry) error {
-	if err := reg.AddValidateFunc(&testgroup.TestType{}, ValidateTestType); err != nil {
-		return err
-	}
-	if err := reg.AddValidateUpdateFunc(&testgroup.TestType{}, ValidateTestTypeUpdate); err != nil {
-		return err
-	}
-	return nil
-}
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation.go b/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation.go
index ea7f42a5b..65898c109 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation.go
@@ -21,12 +21,11 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup"
 	v1 "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v1"
 )
 
-func ValidateTestType(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateTestType(_ *admissionv1.AdmissionRequest, obj runtime.Object) (field.ErrorList, []string) {
 	testType := obj.(*testgroup.TestType)
 	el := field.ErrorList{}
 	if testType.TestField == v1.TestFieldValueNotAllowed {
@@ -35,7 +34,7 @@ func ValidateTestType(_ *admissionv1.AdmissionRequest, obj runtime.Object) (fiel
 	return el, nil
 }
 
-func ValidateTestTypeUpdate(_ *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, validation.WarningList) {
+func ValidateTestTypeUpdate(_ *admissionv1.AdmissionRequest, oldObj, newObj runtime.Object) (field.ErrorList, []string) {
 	old, ok := oldObj.(*testgroup.TestType)
 	new := newObj.(*testgroup.TestType)
 	// if oldObj is not set, the Update operation is always valid.
diff --git a/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation_test.go b/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation_test.go
index 1ccb1fc84..cf005af70 100644
--- a/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation_test.go
+++ b/pkg/webhook/handlers/testdata/apis/testgroup/validation/validation_test.go
@@ -22,7 +22,6 @@ import (
 
 	"k8s.io/apimachinery/pkg/util/validation/field"
 
-	"github.com/jetstack/cert-manager/internal/api/validation"
 	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup"
 	v1 "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v1"
 )
@@ -31,7 +30,7 @@ func TestValidateTestType(t *testing.T) {
 	scenarios := map[string]struct {
 		obj      *testgroup.TestType
 		errs     []*field.Error
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"does not allow testField to be TestFieldValueNotAllowed": {
 			obj: &testgroup.TestType{
@@ -70,7 +69,7 @@ func TestValidateTestTypeUpdate(t *testing.T) {
 	scenarios := map[string]struct {
 		old, new *testgroup.TestType
 		errs     []*field.Error
-		warnings validation.WarningList
+		warnings []string
 	}{
 		"allows all updates if old is nil": {
 			new: &testgroup.TestType{
@@ -111,7 +110,7 @@ const (
 // is not set.
 func testImmutableTestTypeField(t *testing.T, fldPath *field.Path, setter func(*testgroup.TestType, testValue)) {
 	t.Run("should reject updates to "+fldPath.String(), func(t *testing.T) {
-		var expectedWarnings validation.WarningList
+		var expectedWarnings []string
 		expectedErrs := []*field.Error{
 			field.Forbidden(fldPath, "field is immutable once set"),
 		}
@@ -135,7 +134,7 @@ func testImmutableTestTypeField(t *testing.T, fldPath *field.Path, setter func(*
 		}
 	})
 	t.Run("should allow updates to "+fldPath.String()+" if not already set", func(t *testing.T) {
-		var expectedWarnings validation.WarningList
+		var expectedWarnings []string
 		expectedErrs := []*field.Error{}
 		old := &testgroup.TestType{}
 		new := &testgroup.TestType{}
diff --git a/pkg/webhook/handlers/validation.go b/pkg/webhook/handlers/validation.go
deleted file mode 100644
index 39452778f..000000000
--- a/pkg/webhook/handlers/validation.go
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package handlers
-
-import (
-	"context"
-	"net/http"
-
-	"github.com/go-logr/logr"
-	admissionv1 "k8s.io/api/admission/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/runtime/serializer"
-	"k8s.io/apimachinery/pkg/util/validation/field"
-	"k8s.io/client-go/kubernetes"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	"github.com/jetstack/cert-manager/internal/apis/certmanager/validation/plugins"
-)
-
-type registryBackedValidator struct {
-	log      logr.Logger
-	decoder  runtime.Decoder
-	registry *validation.Registry
-
-	plugins []plugins.Plugin
-}
-
-func NewRegistryBackedValidator(log logr.Logger, scheme *runtime.Scheme, registry *validation.Registry) *registryBackedValidator {
-	factory := serializer.NewCodecFactory(scheme)
-	return &registryBackedValidator{
-		log:      log,
-		decoder:  factory.UniversalDecoder(),
-		registry: registry,
-		plugins:  plugins.All(scheme),
-	}
-}
-
-func (r *registryBackedValidator) InitPlugins(client kubernetes.Interface) {
-	for _, plugin := range r.plugins {
-		plugin.Init(client)
-	}
-}
-
-func (r *registryBackedValidator) Validate(ctx context.Context, admissionSpec *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {
-	status := &admissionv1.AdmissionResponse{}
-	status.UID = admissionSpec.UID
-
-	// decode new version of object
-	obj, _, err := r.decoder.Decode(admissionSpec.Object.Raw, nil, nil)
-	if err != nil {
-		status.Allowed = false
-		status.Result = &metav1.Status{
-			Status: metav1.StatusFailure, Code: http.StatusBadRequest, Reason: metav1.StatusReasonBadRequest,
-			Message: err.Error(),
-		}
-		return status
-	}
-
-	// attempt to decode old object
-	var oldObj runtime.Object
-	if len(admissionSpec.OldObject.Raw) > 0 {
-		oldObj, _, err = r.decoder.Decode(admissionSpec.OldObject.Raw, nil, nil)
-		if err != nil {
-			status.Allowed = false
-			status.Result = &metav1.Status{
-				Status: metav1.StatusFailure, Code: http.StatusBadRequest, Reason: metav1.StatusReasonBadRequest,
-				Message: err.Error(),
-			}
-			return status
-		}
-	}
-
-	gvk := schema.GroupVersionKind{
-		Group:   admissionSpec.RequestKind.Group,
-		Version: admissionSpec.RequestKind.Version,
-		Kind:    admissionSpec.RequestKind.Kind,
-	}
-	errs := field.ErrorList{}
-	var warnings validation.WarningList
-
-	if admissionSpec.Operation == admissionv1.Create {
-		// perform validation on new version of resource
-		e, w := r.registry.Validate(admissionSpec, obj, gvk)
-		errs, warnings = append(errs, e...), append(warnings, w...)
-	} else if admissionSpec.Operation == admissionv1.Update {
-		// perform update validation on resource
-		e, w := r.registry.ValidateUpdate(admissionSpec, oldObj, obj, gvk)
-		errs, warnings = append(errs, e...), append(warnings, w...)
-	}
-
-	// TODO: implement warnings for Plugin interface
-	// If no validation errors occurred, perform plugin checks.
-	if len(errs) == 0 {
-		for _, plugin := range r.plugins {
-			if err := plugin.Validate(ctx, admissionSpec, oldObj, obj); err != nil {
-				errs = append(errs, err)
-			}
-		}
-	}
-
-	status.Warnings = warnings
-
-	// return with allowed = false if any errors occurred
-	if err := errs.ToAggregate(); err != nil {
-		status.Allowed = false
-		status.Result = &metav1.Status{
-			Status: metav1.StatusFailure, Code: http.StatusNotAcceptable, Reason: metav1.StatusReasonNotAcceptable,
-			Message: err.Error(),
-		}
-		return status
-	}
-
-	status.Allowed = true
-	return status
-}
diff --git a/pkg/webhook/handlers/validation_test.go b/pkg/webhook/handlers/validation_test.go
deleted file mode 100644
index ff3227160..000000000
--- a/pkg/webhook/handlers/validation_test.go
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package handlers
-
-import (
-	"fmt"
-	"net/http"
-	"testing"
-
-	admissionv1 "k8s.io/api/admission/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/types"
-
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	logf "github.com/jetstack/cert-manager/pkg/logs"
-	"github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/install"
-	v1 "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v1"
-	v2 "github.com/jetstack/cert-manager/pkg/webhook/handlers/testdata/apis/testgroup/v2"
-)
-
-func TestRegistryBackedValidator(t *testing.T) {
-	scheme := runtime.NewScheme()
-	registry := validation.NewRegistry(scheme)
-	install.Install(scheme)
-	install.InstallValidations(registry)
-
-	c := NewRegistryBackedValidator(logf.Log, scheme, registry)
-	testTypeGVK := &metav1.GroupVersionKind{
-		Group:   v1.SchemeGroupVersion.Group,
-		Version: v1.SchemeGroupVersion.Version,
-		Kind:    "TestType",
-	}
-	testTypeGVKV2 := &metav1.GroupVersionKind{
-		Group:   v2.SchemeGroupVersion.Group,
-		Version: v2.SchemeGroupVersion.Version,
-		Kind:    "TestType",
-	}
-	tests := map[string]admissionTestT{
-		"should not allow invalid value for 'testField' field": {
-			inputRequest: admissionv1.AdmissionRequest{
-				UID:         types.UID("abc"),
-				RequestKind: testTypeGVK,
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v1",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testField": "%s"
-}
-`, v1.TestFieldValueNotAllowed)),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				UID:     types.UID("abc"),
-				Allowed: false,
-				Result: &metav1.Status{
-					Status: metav1.StatusFailure, Code: http.StatusNotAcceptable, Reason: metav1.StatusReasonNotAcceptable,
-					Message: "testField: Invalid value: \"not-allowed-value\": invalid value",
-				},
-			},
-		},
-		"should allow setting immutable field if it is not already set": {
-			inputRequest: admissionv1.AdmissionRequest{
-				RequestKind: testTypeGVK,
-				Operation:   admissionv1.Update,
-				OldObject: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v1",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	}
-}
-`)),
-				},
-				Object: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v1",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testFieldImmutable": "abc"
-}
-`)),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				Allowed: true,
-			},
-		},
-		"should not allow setting immutable field if it is already set": {
-			inputRequest: admissionv1.AdmissionRequest{
-				RequestKind: testTypeGVK,
-				Operation:   admissionv1.Update,
-				OldObject: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v1",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testFieldImmutable": "oldvalue"
-}
-`)),
-				},
-				Object: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v1",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testFieldImmutable": "abc"
-}
-`)),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				Allowed: false,
-				Result: &metav1.Status{
-					Status: metav1.StatusFailure, Code: http.StatusNotAcceptable, Reason: metav1.StatusReasonNotAcceptable,
-					Message: "testFieldImmutable: Forbidden: field is immutable once set",
-				},
-			},
-		},
-		"should not allow setting immutable field if it is already set (v2)": {
-			inputRequest: admissionv1.AdmissionRequest{
-				RequestKind: testTypeGVKV2,
-				Operation:   admissionv1.Update,
-				OldObject: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v2",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testFieldImmutable": "oldvalue"
-}
-`)),
-				},
-				Object: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v2",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testFieldImmutable": "abc"
-}
-`)),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				Allowed: false,
-				Result: &metav1.Status{
-					Status: metav1.StatusFailure, Code: http.StatusNotAcceptable, Reason: metav1.StatusReasonNotAcceptable,
-					Message: "testFieldImmutable: Forbidden: field is immutable once set",
-				},
-			},
-		},
-		"should not allow invalid value for 'testField' field in v2": {
-			inputRequest: admissionv1.AdmissionRequest{
-				UID:         types.UID("abc"),
-				RequestKind: testTypeGVKV2,
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v2",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testField": "%s"
-}
-`, v2.DisallowedTestFieldValue)),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				UID:     types.UID("abc"),
-				Allowed: false,
-				Result: &metav1.Status{
-					Status: metav1.StatusFailure, Code: http.StatusNotAcceptable, Reason: metav1.StatusReasonNotAcceptable,
-					Message: "testField: Invalid value: \"not-allowed-in-v2\": value not allowed",
-				},
-			},
-		},
-		"should allow value for 'testField' field in v2 if requestKind is v1": {
-			inputRequest: admissionv1.AdmissionRequest{
-				UID:         types.UID("abc"),
-				RequestKind: testTypeGVK,
-				Operation:   admissionv1.Create,
-				Object: runtime.RawExtension{
-					Raw: []byte(fmt.Sprintf(`
-{
-	"apiVersion": "testgroup.testing.cert-manager.io/v2",
-	"kind": "TestType",
-	"metadata": {
-		"name": "testing",
-		"namespace": "abc",
-		"creationTimestamp": null
-	},
-	"testField": "%s"
-}
-`, v2.DisallowedTestFieldValue)),
-				},
-			},
-			expectedResponse: admissionv1.AdmissionResponse{
-				UID:     types.UID("abc"),
-				Allowed: true,
-			},
-		},
-	}
-
-	for n, test := range tests {
-		t.Run(n, func(t *testing.T) {
-			runAdmissionTest(t, c.Validate, test)
-		})
-	}
-}
diff --git a/pkg/webhook/scheme.go b/pkg/webhook/scheme.go
deleted file mode 100644
index 421963016..000000000
--- a/pkg/webhook/scheme.go
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
-Copyright 2020 The cert-manager Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package webhook
-
-import (
-	"k8s.io/apimachinery/pkg/runtime"
-
-	"github.com/jetstack/cert-manager/internal/api/mutation"
-	"github.com/jetstack/cert-manager/internal/api/validation"
-	acmeinstall "github.com/jetstack/cert-manager/internal/apis/acme/install"
-	cminstall "github.com/jetstack/cert-manager/internal/apis/certmanager/install"
-	metainstall "github.com/jetstack/cert-manager/internal/apis/meta/install"
-)
-
-// Define a Scheme that has all cert-manager API types registered, including
-// the internal API version, defaulting functions and conversion functions for
-// all external versions.
-// This scheme should *only* be used by the webhook as the conversion/defaulter
-// functions are likely to change in future, and all controllers consuming
-// cert-manager APIs should have a consistent view of all API kinds.
-
-var (
-	// Scheme is a Kubernetes runtime.Scheme with all internal and external API
-	// versions for cert-manager types registered.
-	Scheme = runtime.NewScheme()
-
-	// ValidationRegistry is a validation registry with all required
-	// validations that should be enforced by the webhook component.
-	ValidationRegistry = validation.NewRegistry(Scheme)
-
-	// MutationRegistry is a mutation registry with all required
-	// mutations that should be enforced by the webhook component.
-	MutationRegistry = mutation.NewRegistry(Scheme)
-)
-
-func init() {
-	cminstall.Install(Scheme)
-	acmeinstall.Install(Scheme)
-	metainstall.Install(Scheme)
-
-	cminstall.InstallValidation(ValidationRegistry)
-	acmeinstall.InstallValidation(ValidationRegistry)
-
-	cminstall.InstallMutation(MutationRegistry)
-}
diff --git a/test/integration/framework/BUILD.bazel b/test/integration/framework/BUILD.bazel
index 9ebf92b05..6894ff279 100644
--- a/test/integration/framework/BUILD.bazel
+++ b/test/integration/framework/BUILD.bazel
@@ -9,9 +9,9 @@ go_library(
     importpath = "github.com/jetstack/cert-manager/test/integration/framework",
     visibility = ["//visibility:public"],
     deps = [
-        "//cmd/webhook/app:go_default_library",
         "//cmd/webhook/app/testing:go_default_library",
         "//internal/test/paths:go_default_library",
+        "//internal/webhook:go_default_library",
         "//pkg/api:go_default_library",
         "//pkg/client/clientset/versioned:go_default_library",
         "//pkg/client/informers/externalversions:go_default_library",
diff --git a/test/integration/framework/apiserver.go b/test/integration/framework/apiserver.go
index 752db3b4a..12af673b4 100644
--- a/test/integration/framework/apiserver.go
+++ b/test/integration/framework/apiserver.go
@@ -19,6 +19,7 @@ package framework
 import (
 	"context"
 	"fmt"
+	"io/ioutil"
 	"os"
 	"path/filepath"
 	"strings"
@@ -38,9 +39,9 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/envtest"
 
-	"github.com/jetstack/cert-manager/cmd/webhook/app"
 	webhooktesting "github.com/jetstack/cert-manager/cmd/webhook/app/testing"
 	"github.com/jetstack/cert-manager/internal/test/paths"
+	"github.com/jetstack/cert-manager/internal/webhook"
 	"github.com/jetstack/cert-manager/pkg/api"
 	"github.com/jetstack/cert-manager/pkg/webhook/handlers"
 	"github.com/jetstack/cert-manager/test/internal/apiserver"
@@ -83,11 +84,31 @@ func RunControlPlane(t *testing.T, ctx context.Context, optionFunctions ...RunCo
 	}
 
 	env, stopControlPlane := apiserver.RunBareControlPlane(t)
-	config := env.Config
+	testuser, err := env.ControlPlane.AddUser(envtest.User{Name: "test-user", Groups: []string{"cluster-admin"}}, env.Config)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	kubeconfig, err := testuser.KubeConfig()
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	f, err := ioutil.TempFile("", "integration-")
+	if err != nil {
+		t.Fatal(err)
+	}
+	defer f.Close()
+	defer func() {
+		os.Remove(f.Name())
+	}()
+	if _, err := f.Write(kubeconfig); err != nil {
+		t.Fatal(err)
+	}
 
 	webhookOpts, stopWebhook := webhooktesting.StartWebhookServer(
-		t, ctx, []string{"--api-server-host=" + config.Host},
-		app.WithConversionHandler(options.webhookConversionHandler),
+		t, ctx, []string{"--kubeconfig", f.Name()},
+		webhook.WithConversionHandler(options.webhookConversionHandler),
 	)
 
 	crds := readCustomResourcesAtPath(t, *options.crdsDir)
@@ -96,13 +117,13 @@ func RunControlPlane(t *testing.T, ctx context.Context, optionFunctions ...RunCo
 	}
 	patchCRDConversion(crds, webhookOpts.URL, webhookOpts.CAPEM)
 
-	if _, err := envtest.InstallCRDs(config, envtest.CRDInstallOptions{
+	if _, err := envtest.InstallCRDs(env.Config, envtest.CRDInstallOptions{
 		CRDs: crds,
 	}); err != nil {
 		t.Fatal(err)
 	}
 
-	cl, err := client.New(config, client.Options{Scheme: api.Scheme})
+	cl, err := client.New(env.Config, client.Options{Scheme: api.Scheme})
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -119,7 +140,7 @@ func RunControlPlane(t *testing.T, ctx context.Context, optionFunctions ...RunCo
 		t.Fatal(err)
 	}
 
-	return config, func() {
+	return env.Config, func() {
 		defer stopWebhook()
 		stopControlPlane()
 	}
